// @bun
var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS((exports, module) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var promiseTag = "[object Promise]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  function addMapEntry(map3, pair) {
    map3.set(pair[0], pair[1]);
    return map3;
  }
  function addSetEntry(set3, value2) {
    set3.add(value2);
    return set3;
  }
  function arrayEach(array3, iteratee) {
    var index = -1, length = array3 ? array3.length : 0;
    while (++index < length) {
      if (iteratee(array3[index], index, array3) === false) {
        break;
      }
    }
    return array3;
  }
  function arrayPush(array3, values) {
    var index = -1, length = values.length, offset = array3.length;
    while (++index < length) {
      array3[offset + index] = values[index];
    }
    return array3;
  }
  function arrayReduce(array3, iteratee, accumulator, initAccum) {
    var index = -1, length = array3 ? array3.length : 0;
    if (initAccum && length) {
      accumulator = array3[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array3[index], index, array3);
    }
    return accumulator;
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function getValue(object3, key) {
    return object3 == null ? undefined : object3[key];
  }
  function isHostObject(value2) {
    var result = false;
    if (value2 != null && typeof value2.toString != "function") {
      try {
        result = !!(value2 + "");
      } catch (e) {
      }
    }
    return result;
  }
  function mapToArray(map3) {
    var index = -1, result = Array(map3.size);
    map3.forEach(function(value2, key) {
      result[++index] = [key, value2];
    });
    return result;
  }
  function overArg(func, transform4) {
    return function(arg) {
      return func(transform4(arg));
    };
  }
  function setToArray(set3) {
    var index = -1, result = Array(set3.size);
    set3.forEach(function(value2) {
      result[++index] = value2;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var Symbol3 = root.Symbol;
  var Uint8Array3 = root.Uint8Array;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectCreate = Object.create;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView");
  var Map2 = getNative(root, "Map");
  var Promise3 = getNative(root, "Promise");
  var Set5 = getNative(root, "Set");
  var WeakMap2 = getNative(root, "WeakMap");
  var nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise3);
  var setCtorString = toSource(Set5);
  var weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol3 ? Symbol3.prototype : undefined;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  function Hash3(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value2) {
    var data = this.__data__;
    data[key] = nativeCreate && value2 === undefined ? HASH_UNDEFINED : value2;
    return this;
  }
  Hash3.prototype.clear = hashClear;
  Hash3.prototype["delete"] = hashDelete;
  Hash3.prototype.get = hashGet;
  Hash3.prototype.has = hashHas;
  Hash3.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value2) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value2]);
    } else {
      data[index][1] = value2;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash3,
      map: new (Map2 || ListCache),
      string: new Hash3
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value2) {
    getMapData(this, key).set(key, value2);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache;
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value2) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value2]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value2);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value2, inherited) {
    var result = isArray(value2) || isArguments(value2) ? baseTimes(value2.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value2) {
      if ((inherited || hasOwnProperty.call(value2, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignValue(object3, key, value2) {
    var objValue = object3[key];
    if (!(hasOwnProperty.call(object3, key) && eq(objValue, value2)) || value2 === undefined && !(key in object3)) {
      object3[key] = value2;
    }
  }
  function assocIndexOf(array3, key) {
    var length = array3.length;
    while (length--) {
      if (eq(array3[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssign(object3, source) {
    return object3 && copyObject(source, keys(source), object3);
  }
  function baseClone(value2, isDeep, isFull, customizer, key, object3, stack) {
    var result;
    if (customizer) {
      result = object3 ? customizer(value2, key, object3, stack) : customizer(value2);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject2(value2)) {
      return value2;
    }
    var isArr = isArray(value2);
    if (isArr) {
      result = initCloneArray(value2);
      if (!isDeep) {
        return copyArray(value2, result);
      }
    } else {
      var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value2)) {
        return cloneBuffer(value2, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object3) {
        if (isHostObject(value2)) {
          return object3 ? value2 : {};
        }
        result = initCloneObject(isFunc ? {} : value2);
        if (!isDeep) {
          return copySymbols(value2, baseAssign(result, value2));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object3 ? value2 : {};
        }
        result = initCloneByTag(value2, tag, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack);
    var stacked = stack.get(value2);
    if (stacked) {
      return stacked;
    }
    stack.set(value2, result);
    if (!isArr) {
      var props = isFull ? getAllKeys(value2) : keys(value2);
    }
    arrayEach(props || value2, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value2[key2];
      }
      assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value2, stack));
    });
    return result;
  }
  function baseCreate(proto) {
    return isObject2(proto) ? objectCreate(proto) : {};
  }
  function baseGetAllKeys(object3, keysFunc, symbolsFunc) {
    var result = keysFunc(object3);
    return isArray(object3) ? result : arrayPush(result, symbolsFunc(object3));
  }
  function baseGetTag(value2) {
    return objectToString.call(value2);
  }
  function baseIsNative(value2) {
    if (!isObject2(value2) || isMasked(value2)) {
      return false;
    }
    var pattern2 = isFunction(value2) || isHostObject(value2) ? reIsNative : reIsHostCtor;
    return pattern2.test(toSource(value2));
  }
  function baseKeys(object3) {
    if (!isPrototype(object3)) {
      return nativeKeys(object3);
    }
    var result = [];
    for (var key in Object(object3)) {
      if (hasOwnProperty.call(object3, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array3(result).set(new Uint8Array3(arrayBuffer));
    return result;
  }
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }
  function cloneMap(map3, isDeep, cloneFunc) {
    var array3 = isDeep ? cloneFunc(mapToArray(map3), true) : mapToArray(map3);
    return arrayReduce(array3, addMapEntry, new map3.constructor);
  }
  function cloneRegExp(regexp3) {
    var result = new regexp3.constructor(regexp3.source, reFlags.exec(regexp3));
    result.lastIndex = regexp3.lastIndex;
    return result;
  }
  function cloneSet(set3, isDeep, cloneFunc) {
    var array3 = isDeep ? cloneFunc(setToArray(set3), true) : setToArray(set3);
    return arrayReduce(array3, addSetEntry, new set3.constructor);
  }
  function cloneSymbol(symbol3) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol3)) : {};
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array3) {
    var index = -1, length = source.length;
    array3 || (array3 = Array(length));
    while (++index < length) {
      array3[index] = source[index];
    }
    return array3;
  }
  function copyObject(source, props, object3, customizer) {
    object3 || (object3 = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object3[key], source[key], key, object3, source) : undefined;
      assignValue(object3, key, newValue === undefined ? source[key] : newValue);
    }
    return object3;
  }
  function copySymbols(source, object3) {
    return copyObject(source, getSymbols(source), object3);
  }
  function getAllKeys(object3) {
    return baseGetAllKeys(object3, keys, getSymbols);
  }
  function getMapData(map3, key) {
    var data = map3.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object3, key) {
    var value2 = getValue(object3, key);
    return baseIsNative(value2) ? value2 : undefined;
  }
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise3 && getTag(Promise3.resolve()) != promiseTag || Set5 && getTag(new Set5) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
    getTag = function(value2) {
      var result = objectToString.call(value2), Ctor = result == objectTag ? value2.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function initCloneArray(array3) {
    var length = array3.length, result = array3.constructor(length);
    if (length && typeof array3[0] == "string" && hasOwnProperty.call(array3, "index")) {
      result.index = array3.index;
      result.input = array3.input;
    }
    return result;
  }
  function initCloneObject(object3) {
    return typeof object3.constructor == "function" && !isPrototype(object3) ? baseCreate(getPrototype(object3)) : {};
  }
  function initCloneByTag(object3, tag, cloneFunc, isDeep) {
    var Ctor = object3.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object3);
      case boolTag:
      case dateTag:
        return new Ctor(+object3);
      case dataViewTag:
        return cloneDataView(object3, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object3, isDeep);
      case mapTag:
        return cloneMap(object3, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object3);
      case regexpTag:
        return cloneRegExp(object3);
      case setTag:
        return cloneSet(object3, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object3);
    }
  }
  function isIndex(value2, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value2 == "number" || reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
  }
  function isKeyable(value2) {
    var type3 = typeof value2;
    return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value2 !== "__proto__" : value2 === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value2) {
    var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value2 === proto;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function cloneDeep(value2) {
    return baseClone(value2, true, true);
  }
  function eq(value2, other) {
    return value2 === other || value2 !== value2 && other !== other;
  }
  function isArguments(value2) {
    return isArrayLikeObject(value2) && hasOwnProperty.call(value2, "callee") && (!propertyIsEnumerable.call(value2, "callee") || objectToString.call(value2) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value2) {
    return value2 != null && isLength(value2.length) && !isFunction(value2);
  }
  function isArrayLikeObject(value2) {
    return isObjectLike(value2) && isArrayLike(value2);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isFunction(value2) {
    var tag = isObject2(value2) ? objectToString.call(value2) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value2) {
    return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
  }
  function isObject2(value2) {
    var type3 = typeof value2;
    return !!value2 && (type3 == "object" || type3 == "function");
  }
  function isObjectLike(value2) {
    return !!value2 && typeof value2 == "object";
  }
  function keys(object3) {
    return isArrayLike(object3) ? arrayLikeKeys(object3) : baseKeys(object3);
  }
  function stubArray() {
    return [];
  }
  function stubFalse() {
    return false;
  }
  module.exports = cloneDeep;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/runtime.js
var require_runtime = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = undefined;
  exports.BASE_PATH = "https://api.pinecone.io".replace(/\/+$/, "");
  var Configuration = function() {
    function Configuration2(configuration) {
      if (configuration === undefined) {
        configuration = {};
      }
      this.configuration = configuration;
    }
    Object.defineProperty(Configuration2.prototype, "config", {
      set: function(configuration) {
        this.configuration = configuration;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "basePath", {
      get: function() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "fetchApi", {
      get: function() {
        return this.configuration.fetchApi;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "middleware", {
      get: function() {
        return this.configuration.middleware || [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "queryParamsStringify", {
      get: function() {
        return this.configuration.queryParamsStringify || querystring;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "username", {
      get: function() {
        return this.configuration.username;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "password", {
      get: function() {
        return this.configuration.password;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "apiKey", {
      get: function() {
        var apiKey = this.configuration.apiKey;
        if (apiKey) {
          return typeof apiKey === "function" ? apiKey : function() {
            return apiKey;
          };
        }
        return;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "accessToken", {
      get: function() {
        var _this = this;
        var accessToken = this.configuration.accessToken;
        if (accessToken) {
          return typeof accessToken === "function" ? accessToken : function() {
            return __awaiter(_this, undefined, undefined, function() {
              return __generator(this, function(_a2) {
                return [2, accessToken];
              });
            });
          };
        }
        return;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "headers", {
      get: function() {
        return this.configuration.headers;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "credentials", {
      get: function() {
        return this.configuration.credentials;
      },
      enumerable: false,
      configurable: true
    });
    return Configuration2;
  }();
  exports.Configuration = Configuration;
  exports.DefaultConfig = new Configuration;
  var BaseAPI = function() {
    function BaseAPI2(configuration) {
      if (configuration === undefined) {
        configuration = exports.DefaultConfig;
      }
      var _this = this;
      this.configuration = configuration;
      this.fetchApi = function(url, init) {
        return __awaiter(_this, undefined, undefined, function() {
          var fetchParams, _i, _a2, middleware, response, e_1, _b, _c, middleware, _d, _e, middleware;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                fetchParams = { url, init };
                _i = 0, _a2 = this.middleware;
                _f.label = 1;
              case 1:
                if (!(_i < _a2.length))
                  return [3, 4];
                middleware = _a2[_i];
                if (!middleware.pre)
                  return [3, 3];
                return [4, middleware.pre(__assign({ fetch: this.fetchApi }, fetchParams))];
              case 2:
                fetchParams = _f.sent() || fetchParams;
                _f.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                response = undefined;
                _f.label = 5;
              case 5:
                _f.trys.push([5, 7, , 12]);
                return [4, (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init)];
              case 6:
                response = _f.sent();
                return [3, 12];
              case 7:
                e_1 = _f.sent();
                _b = 0, _c = this.middleware;
                _f.label = 8;
              case 8:
                if (!(_b < _c.length))
                  return [3, 11];
                middleware = _c[_b];
                if (!middleware.onError)
                  return [3, 10];
                return [4, middleware.onError({
                  fetch: this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  error: e_1,
                  response: response ? response.clone() : undefined
                })];
              case 9:
                response = _f.sent() || response;
                _f.label = 10;
              case 10:
                _b++;
                return [3, 8];
              case 11:
                if (response === undefined) {
                  if (e_1 instanceof Error) {
                    throw new FetchError(e_1, "The request failed and the interceptors did not return an alternative response");
                  } else {
                    throw e_1;
                  }
                }
                return [3, 12];
              case 12:
                _d = 0, _e = this.middleware;
                _f.label = 13;
              case 13:
                if (!(_d < _e.length))
                  return [3, 16];
                middleware = _e[_d];
                if (!middleware.post)
                  return [3, 15];
                return [4, middleware.post({
                  fetch: this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  response: response.clone()
                })];
              case 14:
                response = _f.sent() || response;
                _f.label = 15;
              case 15:
                _d++;
                return [3, 13];
              case 16:
                return [2, response];
            }
          });
        });
      };
      this.middleware = configuration.middleware;
    }
    BaseAPI2.prototype.withMiddleware = function() {
      var _a2;
      var middlewares = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        middlewares[_i] = arguments[_i];
      }
      var next = this.clone();
      next.middleware = (_a2 = next.middleware).concat.apply(_a2, middlewares);
      return next;
    };
    BaseAPI2.prototype.withPreMiddleware = function() {
      var preMiddlewares = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        preMiddlewares[_i] = arguments[_i];
      }
      var middlewares = preMiddlewares.map(function(pre) {
        return { pre };
      });
      return this.withMiddleware.apply(this, middlewares);
    };
    BaseAPI2.prototype.withPostMiddleware = function() {
      var postMiddlewares = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        postMiddlewares[_i] = arguments[_i];
      }
      var middlewares = postMiddlewares.map(function(post) {
        return { post };
      });
      return this.withMiddleware.apply(this, middlewares);
    };
    BaseAPI2.prototype.isJsonMime = function(mime) {
      if (!mime) {
        return false;
      }
      return BaseAPI2.jsonRegex.test(mime);
    };
    BaseAPI2.prototype.request = function(context, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var _a2, url, init, response;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, this.createFetchParams(context, initOverrides)];
            case 1:
              _a2 = _b.sent(), url = _a2.url, init = _a2.init;
              return [4, this.fetchApi(url, init)];
            case 2:
              response = _b.sent();
              if (response && (response.status >= 200 && response.status < 300)) {
                return [2, response];
              }
              throw new ResponseError(response, "Response returned an error code");
          }
        });
      });
    };
    BaseAPI2.prototype.createFetchParams = function(context, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var url, headers, initOverrideFn, initParams, overriddenInit, _a2, body, init;
        var _this = this;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              url = this.configuration.basePath + context.path;
              if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                url += "?" + this.configuration.queryParamsStringify(context.query);
              }
              headers = Object.assign({}, this.configuration.headers, context.headers);
              Object.keys(headers).forEach(function(key) {
                return headers[key] === undefined ? delete headers[key] : {};
              });
              initOverrideFn = typeof initOverrides === "function" ? initOverrides : function() {
                return __awaiter(_this, undefined, undefined, function() {
                  return __generator(this, function(_a3) {
                    return [2, initOverrides];
                  });
                });
              };
              initParams = {
                method: context.method,
                headers,
                body: context.body,
                credentials: this.configuration.credentials
              };
              _a2 = [__assign({}, initParams)];
              return [4, initOverrideFn({
                init: initParams,
                context
              })];
            case 1:
              overriddenInit = __assign.apply(undefined, _a2.concat([_b.sent()]));
              if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
                body = overriddenInit.body;
              } else if (this.isJsonMime(headers["Content-Type"])) {
                body = JSON.stringify(overriddenInit.body);
              } else {
                body = overriddenInit.body;
              }
              init = __assign(__assign({}, overriddenInit), { body });
              return [2, { url, init }];
          }
        });
      });
    };
    BaseAPI2.prototype.clone = function() {
      var constructor3 = this.constructor;
      var next = new constructor3(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    };
    BaseAPI2.jsonRegex = new RegExp("^(:?application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$", "i");
    return BaseAPI2;
  }();
  exports.BaseAPI = BaseAPI;
  function isBlob(value2) {
    return typeof Blob !== "undefined" && value2 instanceof Blob;
  }
  function isFormData(value2) {
    return typeof FormData !== "undefined" && value2 instanceof FormData;
  }
  var ResponseError = function(_super) {
    __extends(ResponseError2, _super);
    function ResponseError2(response, msg) {
      var _this = _super.call(this, msg) || this;
      _this.response = response;
      _this.name = "ResponseError";
      return _this;
    }
    return ResponseError2;
  }(Error);
  exports.ResponseError = ResponseError;
  var FetchError = function(_super) {
    __extends(FetchError2, _super);
    function FetchError2(cause, msg) {
      var _this = _super.call(this, msg) || this;
      _this.cause = cause;
      _this.name = "FetchError";
      return _this;
    }
    return FetchError2;
  }(Error);
  exports.FetchError = FetchError;
  var RequiredError = function(_super) {
    __extends(RequiredError2, _super);
    function RequiredError2(field, msg) {
      var _this = _super.call(this, msg) || this;
      _this.field = field;
      _this.name = "RequiredError";
      return _this;
    }
    return RequiredError2;
  }(Error);
  exports.RequiredError = RequiredError;
  exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
  };
  function exists(json, key) {
    var value2 = json[key];
    return value2 !== null && value2 !== undefined;
  }
  exports.exists = exists;
  function querystring(params, prefix) {
    if (prefix === undefined) {
      prefix = "";
    }
    return Object.keys(params).map(function(key) {
      return querystringSingleKey(key, params[key], prefix);
    }).filter(function(part) {
      return part.length > 0;
    }).join("&");
  }
  exports.querystring = querystring;
  function querystringSingleKey(key, value2, keyPrefix) {
    if (keyPrefix === undefined) {
      keyPrefix = "";
    }
    var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
    if (value2 instanceof Array) {
      var multiValue = value2.map(function(singleValue) {
        return encodeURIComponent(String(singleValue));
      }).join("&".concat(encodeURIComponent(fullKey), "="));
      return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
    }
    if (value2 instanceof Set) {
      var valueAsArray = Array.from(value2);
      return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value2 instanceof Date) {
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value2.toISOString()));
    }
    if (value2 instanceof Object) {
      return querystring(value2, fullKey);
    }
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value2)));
  }
  function mapValues(data, fn) {
    return Object.keys(data).reduce(function(acc, key) {
      var _a2;
      return __assign(__assign({}, acc), (_a2 = {}, _a2[key] = fn(data[key]), _a2));
    }, {});
  }
  exports.mapValues = mapValues;
  function canConsumeForm(consumes) {
    for (var _i = 0, consumes_1 = consumes;_i < consumes_1.length; _i++) {
      var consume = consumes_1[_i];
      if (consume.contentType === "multipart/form-data") {
        return true;
      }
    }
    return false;
  }
  exports.canConsumeForm = canConsumeForm;
  var JSONApiResponse = function() {
    function JSONApiResponse2(raw, transformer) {
      if (transformer === undefined) {
        transformer = function(jsonValue) {
          return jsonValue;
        };
      }
      this.raw = raw;
      this.transformer = transformer;
    }
    JSONApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a2 = this.transformer;
              return [4, this.raw.json()];
            case 1:
              return [2, _a2.apply(this, [_b.sent()])];
          }
        });
      });
    };
    return JSONApiResponse2;
  }();
  exports.JSONApiResponse = JSONApiResponse;
  var VoidApiResponse = function() {
    function VoidApiResponse2(raw) {
      this.raw = raw;
    }
    VoidApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          return [2, undefined];
        });
      });
    };
    return VoidApiResponse2;
  }();
  exports.VoidApiResponse = VoidApiResponse;
  var BlobApiResponse = function() {
    function BlobApiResponse2(raw) {
      this.raw = raw;
    }
    BlobApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.raw.blob()];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return BlobApiResponse2;
  }();
  exports.BlobApiResponse = BlobApiResponse;
  var TextApiResponse = function() {
    function TextApiResponse2(raw) {
      this.raw = raw;
    }
    TextApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.raw.text()];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return TextApiResponse2;
  }();
  exports.TextApiResponse = TextApiResponse;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CollectionModel.js
var require_CollectionModel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CollectionModelToJSON = exports.CollectionModelFromJSONTyped = exports.CollectionModelFromJSON = exports.instanceOfCollectionModel = exports.CollectionModelStatusEnum = undefined;
  var runtime_1 = require_runtime();
  exports.CollectionModelStatusEnum = {
    Initializing: "Initializing",
    Ready: "Ready",
    Terminating: "Terminating"
  };
  function instanceOfCollectionModel(value2) {
    var isInstance = true;
    isInstance = isInstance && "name" in value2;
    isInstance = isInstance && "status" in value2;
    isInstance = isInstance && "environment" in value2;
    return isInstance;
  }
  exports.instanceOfCollectionModel = instanceOfCollectionModel;
  function CollectionModelFromJSON(json) {
    return CollectionModelFromJSONTyped(json, false);
  }
  exports.CollectionModelFromJSON = CollectionModelFromJSON;
  function CollectionModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      name: json["name"],
      size: !(0, runtime_1.exists)(json, "size") ? undefined : json["size"],
      status: json["status"],
      dimension: !(0, runtime_1.exists)(json, "dimension") ? undefined : json["dimension"],
      vectorCount: !(0, runtime_1.exists)(json, "vector_count") ? undefined : json["vector_count"],
      environment: json["environment"]
    };
  }
  exports.CollectionModelFromJSONTyped = CollectionModelFromJSONTyped;
  function CollectionModelToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      name: value2.name,
      size: value2.size,
      status: value2.status,
      dimension: value2.dimension,
      vector_count: value2.vectorCount,
      environment: value2.environment
    };
  }
  exports.CollectionModelToJSON = CollectionModelToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CollectionList.js
var require_CollectionList = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CollectionListToJSON = exports.CollectionListFromJSONTyped = exports.CollectionListFromJSON = exports.instanceOfCollectionList = undefined;
  var runtime_1 = require_runtime();
  var CollectionModel_1 = require_CollectionModel();
  function instanceOfCollectionList(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfCollectionList = instanceOfCollectionList;
  function CollectionListFromJSON(json) {
    return CollectionListFromJSONTyped(json, false);
  }
  exports.CollectionListFromJSON = CollectionListFromJSON;
  function CollectionListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      collections: !(0, runtime_1.exists)(json, "collections") ? undefined : json["collections"].map(CollectionModel_1.CollectionModelFromJSON)
    };
  }
  exports.CollectionListFromJSONTyped = CollectionListFromJSONTyped;
  function CollectionListToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      collections: value2.collections === undefined ? undefined : value2.collections.map(CollectionModel_1.CollectionModelToJSON)
    };
  }
  exports.CollectionListToJSON = CollectionListToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestSpecPod.js
var require_ConfigureIndexRequestSpecPod = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConfigureIndexRequestSpecPodToJSON = exports.ConfigureIndexRequestSpecPodFromJSONTyped = exports.ConfigureIndexRequestSpecPodFromJSON = exports.instanceOfConfigureIndexRequestSpecPod = undefined;
  var runtime_1 = require_runtime();
  function instanceOfConfigureIndexRequestSpecPod(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfConfigureIndexRequestSpecPod = instanceOfConfigureIndexRequestSpecPod;
  function ConfigureIndexRequestSpecPodFromJSON(json) {
    return ConfigureIndexRequestSpecPodFromJSONTyped(json, false);
  }
  exports.ConfigureIndexRequestSpecPodFromJSON = ConfigureIndexRequestSpecPodFromJSON;
  function ConfigureIndexRequestSpecPodFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      replicas: !(0, runtime_1.exists)(json, "replicas") ? undefined : json["replicas"],
      podType: !(0, runtime_1.exists)(json, "pod_type") ? undefined : json["pod_type"]
    };
  }
  exports.ConfigureIndexRequestSpecPodFromJSONTyped = ConfigureIndexRequestSpecPodFromJSONTyped;
  function ConfigureIndexRequestSpecPodToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      replicas: value2.replicas,
      pod_type: value2.podType
    };
  }
  exports.ConfigureIndexRequestSpecPodToJSON = ConfigureIndexRequestSpecPodToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequestSpec.js
var require_ConfigureIndexRequestSpec = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConfigureIndexRequestSpecToJSON = exports.ConfigureIndexRequestSpecFromJSONTyped = exports.ConfigureIndexRequestSpecFromJSON = exports.instanceOfConfigureIndexRequestSpec = undefined;
  var ConfigureIndexRequestSpecPod_1 = require_ConfigureIndexRequestSpecPod();
  function instanceOfConfigureIndexRequestSpec(value2) {
    var isInstance = true;
    isInstance = isInstance && "pod" in value2;
    return isInstance;
  }
  exports.instanceOfConfigureIndexRequestSpec = instanceOfConfigureIndexRequestSpec;
  function ConfigureIndexRequestSpecFromJSON(json) {
    return ConfigureIndexRequestSpecFromJSONTyped(json, false);
  }
  exports.ConfigureIndexRequestSpecFromJSON = ConfigureIndexRequestSpecFromJSON;
  function ConfigureIndexRequestSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      pod: (0, ConfigureIndexRequestSpecPod_1.ConfigureIndexRequestSpecPodFromJSON)(json["pod"])
    };
  }
  exports.ConfigureIndexRequestSpecFromJSONTyped = ConfigureIndexRequestSpecFromJSONTyped;
  function ConfigureIndexRequestSpecToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      pod: (0, ConfigureIndexRequestSpecPod_1.ConfigureIndexRequestSpecPodToJSON)(value2.pod)
    };
  }
  exports.ConfigureIndexRequestSpecToJSON = ConfigureIndexRequestSpecToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/DeletionProtection.js
var require_DeletionProtection = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeletionProtectionToJSON = exports.DeletionProtectionFromJSONTyped = exports.DeletionProtectionFromJSON = exports.DeletionProtection = undefined;
  exports.DeletionProtection = {
    Disabled: "disabled",
    Enabled: "enabled"
  };
  function DeletionProtectionFromJSON(json) {
    return DeletionProtectionFromJSONTyped(json, false);
  }
  exports.DeletionProtectionFromJSON = DeletionProtectionFromJSON;
  function DeletionProtectionFromJSONTyped(json, ignoreDiscriminator) {
    return json;
  }
  exports.DeletionProtectionFromJSONTyped = DeletionProtectionFromJSONTyped;
  function DeletionProtectionToJSON(value2) {
    return value2;
  }
  exports.DeletionProtectionToJSON = DeletionProtectionToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ConfigureIndexRequest.js
var require_ConfigureIndexRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ConfigureIndexRequestToJSON = exports.ConfigureIndexRequestFromJSONTyped = exports.ConfigureIndexRequestFromJSON = exports.instanceOfConfigureIndexRequest = undefined;
  var runtime_1 = require_runtime();
  var ConfigureIndexRequestSpec_1 = require_ConfigureIndexRequestSpec();
  var DeletionProtection_1 = require_DeletionProtection();
  function instanceOfConfigureIndexRequest(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfConfigureIndexRequest = instanceOfConfigureIndexRequest;
  function ConfigureIndexRequestFromJSON(json) {
    return ConfigureIndexRequestFromJSONTyped(json, false);
  }
  exports.ConfigureIndexRequestFromJSON = ConfigureIndexRequestFromJSON;
  function ConfigureIndexRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      spec: !(0, runtime_1.exists)(json, "spec") ? undefined : (0, ConfigureIndexRequestSpec_1.ConfigureIndexRequestSpecFromJSON)(json["spec"]),
      deletionProtection: !(0, runtime_1.exists)(json, "deletion_protection") ? undefined : (0, DeletionProtection_1.DeletionProtectionFromJSON)(json["deletion_protection"]),
      tags: !(0, runtime_1.exists)(json, "tags") ? undefined : json["tags"]
    };
  }
  exports.ConfigureIndexRequestFromJSONTyped = ConfigureIndexRequestFromJSONTyped;
  function ConfigureIndexRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      spec: (0, ConfigureIndexRequestSpec_1.ConfigureIndexRequestSpecToJSON)(value2.spec),
      deletion_protection: (0, DeletionProtection_1.DeletionProtectionToJSON)(value2.deletionProtection),
      tags: value2.tags
    };
  }
  exports.ConfigureIndexRequestToJSON = ConfigureIndexRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateCollectionRequest.js
var require_CreateCollectionRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateCollectionRequestToJSON = exports.CreateCollectionRequestFromJSONTyped = exports.CreateCollectionRequestFromJSON = exports.instanceOfCreateCollectionRequest = undefined;
  function instanceOfCreateCollectionRequest(value2) {
    var isInstance = true;
    isInstance = isInstance && "name" in value2;
    isInstance = isInstance && "source" in value2;
    return isInstance;
  }
  exports.instanceOfCreateCollectionRequest = instanceOfCreateCollectionRequest;
  function CreateCollectionRequestFromJSON(json) {
    return CreateCollectionRequestFromJSONTyped(json, false);
  }
  exports.CreateCollectionRequestFromJSON = CreateCollectionRequestFromJSON;
  function CreateCollectionRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      name: json["name"],
      source: json["source"]
    };
  }
  exports.CreateCollectionRequestFromJSONTyped = CreateCollectionRequestFromJSONTyped;
  function CreateCollectionRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      name: value2.name,
      source: value2.source
    };
  }
  exports.CreateCollectionRequestToJSON = CreateCollectionRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PodSpecMetadataConfig.js
var require_PodSpecMetadataConfig = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PodSpecMetadataConfigToJSON = exports.PodSpecMetadataConfigFromJSONTyped = exports.PodSpecMetadataConfigFromJSON = exports.instanceOfPodSpecMetadataConfig = undefined;
  var runtime_1 = require_runtime();
  function instanceOfPodSpecMetadataConfig(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfPodSpecMetadataConfig = instanceOfPodSpecMetadataConfig;
  function PodSpecMetadataConfigFromJSON(json) {
    return PodSpecMetadataConfigFromJSONTyped(json, false);
  }
  exports.PodSpecMetadataConfigFromJSON = PodSpecMetadataConfigFromJSON;
  function PodSpecMetadataConfigFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      indexed: !(0, runtime_1.exists)(json, "indexed") ? undefined : json["indexed"]
    };
  }
  exports.PodSpecMetadataConfigFromJSONTyped = PodSpecMetadataConfigFromJSONTyped;
  function PodSpecMetadataConfigToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      indexed: value2.indexed
    };
  }
  exports.PodSpecMetadataConfigToJSON = PodSpecMetadataConfigToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/PodSpec.js
var require_PodSpec = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PodSpecToJSON = exports.PodSpecFromJSONTyped = exports.PodSpecFromJSON = exports.instanceOfPodSpec = undefined;
  var runtime_1 = require_runtime();
  var PodSpecMetadataConfig_1 = require_PodSpecMetadataConfig();
  function instanceOfPodSpec(value2) {
    var isInstance = true;
    isInstance = isInstance && "environment" in value2;
    isInstance = isInstance && "podType" in value2;
    return isInstance;
  }
  exports.instanceOfPodSpec = instanceOfPodSpec;
  function PodSpecFromJSON(json) {
    return PodSpecFromJSONTyped(json, false);
  }
  exports.PodSpecFromJSON = PodSpecFromJSON;
  function PodSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      environment: json["environment"],
      replicas: !(0, runtime_1.exists)(json, "replicas") ? undefined : json["replicas"],
      shards: !(0, runtime_1.exists)(json, "shards") ? undefined : json["shards"],
      podType: json["pod_type"],
      pods: !(0, runtime_1.exists)(json, "pods") ? undefined : json["pods"],
      metadataConfig: !(0, runtime_1.exists)(json, "metadata_config") ? undefined : (0, PodSpecMetadataConfig_1.PodSpecMetadataConfigFromJSON)(json["metadata_config"]),
      sourceCollection: !(0, runtime_1.exists)(json, "source_collection") ? undefined : json["source_collection"]
    };
  }
  exports.PodSpecFromJSONTyped = PodSpecFromJSONTyped;
  function PodSpecToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      environment: value2.environment,
      replicas: value2.replicas,
      shards: value2.shards,
      pod_type: value2.podType,
      pods: value2.pods,
      metadata_config: (0, PodSpecMetadataConfig_1.PodSpecMetadataConfigToJSON)(value2.metadataConfig),
      source_collection: value2.sourceCollection
    };
  }
  exports.PodSpecToJSON = PodSpecToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ServerlessSpec.js
var require_ServerlessSpec = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ServerlessSpecToJSON = exports.ServerlessSpecFromJSONTyped = exports.ServerlessSpecFromJSON = exports.instanceOfServerlessSpec = exports.ServerlessSpecCloudEnum = undefined;
  exports.ServerlessSpecCloudEnum = {
    Gcp: "gcp",
    Aws: "aws",
    Azure: "azure"
  };
  function instanceOfServerlessSpec(value2) {
    var isInstance = true;
    isInstance = isInstance && "cloud" in value2;
    isInstance = isInstance && "region" in value2;
    return isInstance;
  }
  exports.instanceOfServerlessSpec = instanceOfServerlessSpec;
  function ServerlessSpecFromJSON(json) {
    return ServerlessSpecFromJSONTyped(json, false);
  }
  exports.ServerlessSpecFromJSON = ServerlessSpecFromJSON;
  function ServerlessSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      cloud: json["cloud"],
      region: json["region"]
    };
  }
  exports.ServerlessSpecFromJSONTyped = ServerlessSpecFromJSONTyped;
  function ServerlessSpecToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      cloud: value2.cloud,
      region: value2.region
    };
  }
  exports.ServerlessSpecToJSON = ServerlessSpecToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexSpec.js
var require_IndexSpec = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexSpecToJSON = exports.IndexSpecFromJSONTyped = exports.IndexSpecFromJSON = exports.instanceOfIndexSpec = undefined;
  var runtime_1 = require_runtime();
  var PodSpec_1 = require_PodSpec();
  var ServerlessSpec_1 = require_ServerlessSpec();
  function instanceOfIndexSpec(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfIndexSpec = instanceOfIndexSpec;
  function IndexSpecFromJSON(json) {
    return IndexSpecFromJSONTyped(json, false);
  }
  exports.IndexSpecFromJSON = IndexSpecFromJSON;
  function IndexSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      serverless: !(0, runtime_1.exists)(json, "serverless") ? undefined : (0, ServerlessSpec_1.ServerlessSpecFromJSON)(json["serverless"]),
      pod: !(0, runtime_1.exists)(json, "pod") ? undefined : (0, PodSpec_1.PodSpecFromJSON)(json["pod"])
    };
  }
  exports.IndexSpecFromJSONTyped = IndexSpecFromJSONTyped;
  function IndexSpecToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      serverless: (0, ServerlessSpec_1.ServerlessSpecToJSON)(value2.serverless),
      pod: (0, PodSpec_1.PodSpecToJSON)(value2.pod)
    };
  }
  exports.IndexSpecToJSON = IndexSpecToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/CreateIndexRequest.js
var require_CreateIndexRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CreateIndexRequestToJSON = exports.CreateIndexRequestFromJSONTyped = exports.CreateIndexRequestFromJSON = exports.instanceOfCreateIndexRequest = exports.CreateIndexRequestMetricEnum = undefined;
  var runtime_1 = require_runtime();
  var DeletionProtection_1 = require_DeletionProtection();
  var IndexSpec_1 = require_IndexSpec();
  exports.CreateIndexRequestMetricEnum = {
    Cosine: "cosine",
    Euclidean: "euclidean",
    Dotproduct: "dotproduct"
  };
  function instanceOfCreateIndexRequest(value2) {
    var isInstance = true;
    isInstance = isInstance && "name" in value2;
    isInstance = isInstance && "dimension" in value2;
    isInstance = isInstance && "spec" in value2;
    return isInstance;
  }
  exports.instanceOfCreateIndexRequest = instanceOfCreateIndexRequest;
  function CreateIndexRequestFromJSON(json) {
    return CreateIndexRequestFromJSONTyped(json, false);
  }
  exports.CreateIndexRequestFromJSON = CreateIndexRequestFromJSON;
  function CreateIndexRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      name: json["name"],
      dimension: json["dimension"],
      metric: !(0, runtime_1.exists)(json, "metric") ? undefined : json["metric"],
      deletionProtection: !(0, runtime_1.exists)(json, "deletion_protection") ? undefined : (0, DeletionProtection_1.DeletionProtectionFromJSON)(json["deletion_protection"]),
      tags: !(0, runtime_1.exists)(json, "tags") ? undefined : json["tags"],
      spec: (0, IndexSpec_1.IndexSpecFromJSON)(json["spec"])
    };
  }
  exports.CreateIndexRequestFromJSONTyped = CreateIndexRequestFromJSONTyped;
  function CreateIndexRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      name: value2.name,
      dimension: value2.dimension,
      metric: value2.metric,
      deletion_protection: (0, DeletionProtection_1.DeletionProtectionToJSON)(value2.deletionProtection),
      tags: value2.tags,
      spec: (0, IndexSpec_1.IndexSpecToJSON)(value2.spec)
    };
  }
  exports.CreateIndexRequestToJSON = CreateIndexRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ErrorResponseError.js
var require_ErrorResponseError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ErrorResponseErrorToJSON = exports.ErrorResponseErrorFromJSONTyped = exports.ErrorResponseErrorFromJSON = exports.instanceOfErrorResponseError = exports.ErrorResponseErrorCodeEnum = undefined;
  var runtime_1 = require_runtime();
  exports.ErrorResponseErrorCodeEnum = {
    Ok: "OK",
    Unknown: "UNKNOWN",
    InvalidArgument: "INVALID_ARGUMENT",
    DeadlineExceeded: "DEADLINE_EXCEEDED",
    QuotaExceeded: "QUOTA_EXCEEDED",
    NotFound: "NOT_FOUND",
    AlreadyExists: "ALREADY_EXISTS",
    PermissionDenied: "PERMISSION_DENIED",
    Unauthenticated: "UNAUTHENTICATED",
    ResourceExhausted: "RESOURCE_EXHAUSTED",
    FailedPrecondition: "FAILED_PRECONDITION",
    Aborted: "ABORTED",
    OutOfRange: "OUT_OF_RANGE",
    Unimplemented: "UNIMPLEMENTED",
    Internal: "INTERNAL",
    Unavailable: "UNAVAILABLE",
    DataLoss: "DATA_LOSS",
    Forbidden: "FORBIDDEN",
    UnprocessableEntity: "UNPROCESSABLE_ENTITY",
    PaymentRequired: "PAYMENT_REQUIRED"
  };
  function instanceOfErrorResponseError(value2) {
    var isInstance = true;
    isInstance = isInstance && "code" in value2;
    isInstance = isInstance && "message" in value2;
    return isInstance;
  }
  exports.instanceOfErrorResponseError = instanceOfErrorResponseError;
  function ErrorResponseErrorFromJSON(json) {
    return ErrorResponseErrorFromJSONTyped(json, false);
  }
  exports.ErrorResponseErrorFromJSON = ErrorResponseErrorFromJSON;
  function ErrorResponseErrorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      code: json["code"],
      message: json["message"],
      details: !(0, runtime_1.exists)(json, "details") ? undefined : json["details"]
    };
  }
  exports.ErrorResponseErrorFromJSONTyped = ErrorResponseErrorFromJSONTyped;
  function ErrorResponseErrorToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      code: value2.code,
      message: value2.message,
      details: value2.details
    };
  }
  exports.ErrorResponseErrorToJSON = ErrorResponseErrorToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/ErrorResponse.js
var require_ErrorResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ErrorResponseToJSON = exports.ErrorResponseFromJSONTyped = exports.ErrorResponseFromJSON = exports.instanceOfErrorResponse = undefined;
  var ErrorResponseError_1 = require_ErrorResponseError();
  function instanceOfErrorResponse(value2) {
    var isInstance = true;
    isInstance = isInstance && "status" in value2;
    isInstance = isInstance && "error" in value2;
    return isInstance;
  }
  exports.instanceOfErrorResponse = instanceOfErrorResponse;
  function ErrorResponseFromJSON(json) {
    return ErrorResponseFromJSONTyped(json, false);
  }
  exports.ErrorResponseFromJSON = ErrorResponseFromJSON;
  function ErrorResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      status: json["status"],
      error: (0, ErrorResponseError_1.ErrorResponseErrorFromJSON)(json["error"])
    };
  }
  exports.ErrorResponseFromJSONTyped = ErrorResponseFromJSONTyped;
  function ErrorResponseToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      status: value2.status,
      error: (0, ErrorResponseError_1.ErrorResponseErrorToJSON)(value2.error)
    };
  }
  exports.ErrorResponseToJSON = ErrorResponseToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModelSpec.js
var require_IndexModelSpec = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexModelSpecToJSON = exports.IndexModelSpecFromJSONTyped = exports.IndexModelSpecFromJSON = exports.instanceOfIndexModelSpec = undefined;
  var runtime_1 = require_runtime();
  var PodSpec_1 = require_PodSpec();
  var ServerlessSpec_1 = require_ServerlessSpec();
  function instanceOfIndexModelSpec(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfIndexModelSpec = instanceOfIndexModelSpec;
  function IndexModelSpecFromJSON(json) {
    return IndexModelSpecFromJSONTyped(json, false);
  }
  exports.IndexModelSpecFromJSON = IndexModelSpecFromJSON;
  function IndexModelSpecFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      pod: !(0, runtime_1.exists)(json, "pod") ? undefined : (0, PodSpec_1.PodSpecFromJSON)(json["pod"]),
      serverless: !(0, runtime_1.exists)(json, "serverless") ? undefined : (0, ServerlessSpec_1.ServerlessSpecFromJSON)(json["serverless"])
    };
  }
  exports.IndexModelSpecFromJSONTyped = IndexModelSpecFromJSONTyped;
  function IndexModelSpecToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      pod: (0, PodSpec_1.PodSpecToJSON)(value2.pod),
      serverless: (0, ServerlessSpec_1.ServerlessSpecToJSON)(value2.serverless)
    };
  }
  exports.IndexModelSpecToJSON = IndexModelSpecToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModelStatus.js
var require_IndexModelStatus = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexModelStatusToJSON = exports.IndexModelStatusFromJSONTyped = exports.IndexModelStatusFromJSON = exports.instanceOfIndexModelStatus = exports.IndexModelStatusStateEnum = undefined;
  exports.IndexModelStatusStateEnum = {
    Initializing: "Initializing",
    InitializationFailed: "InitializationFailed",
    ScalingUp: "ScalingUp",
    ScalingDown: "ScalingDown",
    ScalingUpPodSize: "ScalingUpPodSize",
    ScalingDownPodSize: "ScalingDownPodSize",
    Terminating: "Terminating",
    Ready: "Ready"
  };
  function instanceOfIndexModelStatus(value2) {
    var isInstance = true;
    isInstance = isInstance && "ready" in value2;
    isInstance = isInstance && "state" in value2;
    return isInstance;
  }
  exports.instanceOfIndexModelStatus = instanceOfIndexModelStatus;
  function IndexModelStatusFromJSON(json) {
    return IndexModelStatusFromJSONTyped(json, false);
  }
  exports.IndexModelStatusFromJSON = IndexModelStatusFromJSON;
  function IndexModelStatusFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      ready: json["ready"],
      state: json["state"]
    };
  }
  exports.IndexModelStatusFromJSONTyped = IndexModelStatusFromJSONTyped;
  function IndexModelStatusToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      ready: value2.ready,
      state: value2.state
    };
  }
  exports.IndexModelStatusToJSON = IndexModelStatusToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexModel.js
var require_IndexModel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexModelToJSON = exports.IndexModelFromJSONTyped = exports.IndexModelFromJSON = exports.instanceOfIndexModel = exports.IndexModelMetricEnum = undefined;
  var runtime_1 = require_runtime();
  var DeletionProtection_1 = require_DeletionProtection();
  var IndexModelSpec_1 = require_IndexModelSpec();
  var IndexModelStatus_1 = require_IndexModelStatus();
  exports.IndexModelMetricEnum = {
    Cosine: "cosine",
    Euclidean: "euclidean",
    Dotproduct: "dotproduct"
  };
  function instanceOfIndexModel(value2) {
    var isInstance = true;
    isInstance = isInstance && "name" in value2;
    isInstance = isInstance && "dimension" in value2;
    isInstance = isInstance && "metric" in value2;
    isInstance = isInstance && "host" in value2;
    isInstance = isInstance && "spec" in value2;
    isInstance = isInstance && "status" in value2;
    return isInstance;
  }
  exports.instanceOfIndexModel = instanceOfIndexModel;
  function IndexModelFromJSON(json) {
    return IndexModelFromJSONTyped(json, false);
  }
  exports.IndexModelFromJSON = IndexModelFromJSON;
  function IndexModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      name: json["name"],
      dimension: json["dimension"],
      metric: json["metric"],
      host: json["host"],
      deletionProtection: !(0, runtime_1.exists)(json, "deletion_protection") ? undefined : (0, DeletionProtection_1.DeletionProtectionFromJSON)(json["deletion_protection"]),
      tags: !(0, runtime_1.exists)(json, "tags") ? undefined : json["tags"],
      spec: (0, IndexModelSpec_1.IndexModelSpecFromJSON)(json["spec"]),
      status: (0, IndexModelStatus_1.IndexModelStatusFromJSON)(json["status"])
    };
  }
  exports.IndexModelFromJSONTyped = IndexModelFromJSONTyped;
  function IndexModelToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      name: value2.name,
      dimension: value2.dimension,
      metric: value2.metric,
      host: value2.host,
      deletion_protection: (0, DeletionProtection_1.DeletionProtectionToJSON)(value2.deletionProtection),
      tags: value2.tags,
      spec: (0, IndexModelSpec_1.IndexModelSpecToJSON)(value2.spec),
      status: (0, IndexModelStatus_1.IndexModelStatusToJSON)(value2.status)
    };
  }
  exports.IndexModelToJSON = IndexModelToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/IndexList.js
var require_IndexList = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexListToJSON = exports.IndexListFromJSONTyped = exports.IndexListFromJSON = exports.instanceOfIndexList = undefined;
  var runtime_1 = require_runtime();
  var IndexModel_1 = require_IndexModel();
  function instanceOfIndexList(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfIndexList = instanceOfIndexList;
  function IndexListFromJSON(json) {
    return IndexListFromJSONTyped(json, false);
  }
  exports.IndexListFromJSON = IndexListFromJSON;
  function IndexListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      indexes: !(0, runtime_1.exists)(json, "indexes") ? undefined : json["indexes"].map(IndexModel_1.IndexModelFromJSON)
    };
  }
  exports.IndexListFromJSONTyped = IndexListFromJSONTyped;
  function IndexListToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      indexes: value2.indexes === undefined ? undefined : value2.indexes.map(IndexModel_1.IndexModelToJSON)
    };
  }
  exports.IndexListToJSON = IndexListToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/models/index.js
var require_models = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_CollectionList(), exports);
  __exportStar(require_CollectionModel(), exports);
  __exportStar(require_ConfigureIndexRequest(), exports);
  __exportStar(require_ConfigureIndexRequestSpec(), exports);
  __exportStar(require_ConfigureIndexRequestSpecPod(), exports);
  __exportStar(require_CreateCollectionRequest(), exports);
  __exportStar(require_CreateIndexRequest(), exports);
  __exportStar(require_DeletionProtection(), exports);
  __exportStar(require_ErrorResponse(), exports);
  __exportStar(require_ErrorResponseError(), exports);
  __exportStar(require_IndexList(), exports);
  __exportStar(require_IndexModel(), exports);
  __exportStar(require_IndexModelSpec(), exports);
  __exportStar(require_IndexModelStatus(), exports);
  __exportStar(require_IndexSpec(), exports);
  __exportStar(require_PodSpec(), exports);
  __exportStar(require_PodSpecMetadataConfig(), exports);
  __exportStar(require_ServerlessSpec(), exports);
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/apis/ManageIndexesApi.js
var require_ManageIndexesApi = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ManageIndexesApi = undefined;
  var runtime = __importStar(require_runtime());
  var index_1 = require_models();
  var ManageIndexesApi = function(_super) {
    __extends(ManageIndexesApi2, _super);
    function ManageIndexesApi2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ManageIndexesApi2.prototype.configureIndexRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
                throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling configureIndex.");
              }
              if (requestParameters.configureIndexRequest === null || requestParameters.configureIndexRequest === undefined) {
                throw new runtime.RequiredError("configureIndexRequest", "Required parameter requestParameters.configureIndexRequest was null or undefined when calling configureIndex.");
              }
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/indexes/{index_name}".replace("{".concat("index_name", "}"), encodeURIComponent(String(requestParameters.indexName))),
                method: "PATCH",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.ConfigureIndexRequestToJSON)(requestParameters.configureIndexRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.IndexModelFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.configureIndex = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.configureIndexRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.createCollectionRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.createCollectionRequest === null || requestParameters.createCollectionRequest === undefined) {
                throw new runtime.RequiredError("createCollectionRequest", "Required parameter requestParameters.createCollectionRequest was null or undefined when calling createCollection.");
              }
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/collections",
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.CreateCollectionRequestToJSON)(requestParameters.createCollectionRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.CollectionModelFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.createCollection = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.createCollectionRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.createIndexRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.createIndexRequest === null || requestParameters.createIndexRequest === undefined) {
                throw new runtime.RequiredError("createIndexRequest", "Required parameter requestParameters.createIndexRequest was null or undefined when calling createIndex.");
              }
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/indexes",
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.CreateIndexRequestToJSON)(requestParameters.createIndexRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.IndexModelFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.createIndex = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.createIndexRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.deleteCollectionRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
                throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling deleteCollection.");
              }
              queryParameters = {};
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/collections/{collection_name}".replace("{".concat("collection_name", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.VoidApiResponse(response)];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.deleteCollection = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.deleteCollectionRaw(requestParameters, initOverrides)];
            case 1:
              _a2.sent();
              return [2];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.deleteIndexRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
                throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling deleteIndex.");
              }
              queryParameters = {};
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/indexes/{index_name}".replace("{".concat("index_name", "}"), encodeURIComponent(String(requestParameters.indexName))),
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.VoidApiResponse(response)];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.deleteIndex = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.deleteIndexRaw(requestParameters, initOverrides)];
            case 1:
              _a2.sent();
              return [2];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.describeCollectionRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.collectionName === null || requestParameters.collectionName === undefined) {
                throw new runtime.RequiredError("collectionName", "Required parameter requestParameters.collectionName was null or undefined when calling describeCollection.");
              }
              queryParameters = {};
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/collections/{collection_name}".replace("{".concat("collection_name", "}"), encodeURIComponent(String(requestParameters.collectionName))),
                method: "GET",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.CollectionModelFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.describeCollection = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.describeCollectionRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.describeIndexRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.indexName === null || requestParameters.indexName === undefined) {
                throw new runtime.RequiredError("indexName", "Required parameter requestParameters.indexName was null or undefined when calling describeIndex.");
              }
              queryParameters = {};
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/indexes/{index_name}".replace("{".concat("index_name", "}"), encodeURIComponent(String(requestParameters.indexName))),
                method: "GET",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.IndexModelFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.describeIndex = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.describeIndexRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.listCollectionsRaw = function(initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              queryParameters = {};
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/collections",
                method: "GET",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.CollectionListFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.listCollections = function(initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.listCollectionsRaw(initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.listIndexesRaw = function(initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              queryParameters = {};
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/indexes",
                method: "GET",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.IndexListFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    ManageIndexesApi2.prototype.listIndexes = function(initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.listIndexesRaw(initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return ManageIndexesApi2;
  }(runtime.BaseAPI);
  exports.ManageIndexesApi = ManageIndexesApi;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/apis/index.js
var require_apis = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_ManageIndexesApi(), exports);
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/api_version.js
var require_api_version = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.X_PINECONE_API_VERSION = undefined;
  exports.X_PINECONE_API_VERSION = "2024-10";
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_control/index.js
var require_db_control = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_runtime(), exports);
  __exportStar(require_apis(), exports);
  __exportStar(require_models(), exports);
  __exportStar(require_api_version(), exports);
});

// node_modules/@pinecone-database/pinecone/dist/utils/debugLog.js
var require_debugLog = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debugLog = undefined;
  var debugLog = function(str2) {
    if (typeof process !== "undefined" && process && process.env && process.env.PINECONE_DEBUG) {
      console.log(str2);
    }
  };
  exports.debugLog = debugLog;
});

// node_modules/@pinecone-database/pinecone/dist/utils/normalizeUrl.js
var require_normalizeUrl = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.normalizeUrl = undefined;
  function normalizeUrl(url) {
    if (!url || url.trim().length === 0) {
      return;
    }
    if (!url.startsWith("http://") && !url.startsWith("https://")) {
      return "https://" + url;
    }
    return url;
  }
  exports.normalizeUrl = normalizeUrl;
});

// node_modules/@pinecone-database/pinecone/dist/utils/queryParamsStringify.js
var require_queryParamsStringify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.queryParamsStringify = undefined;
  function queryParamsStringify(params, prefix) {
    if (prefix === undefined) {
      prefix = "";
    }
    return Object.keys(params).map(function(key) {
      return querystringSingleKey(key, params[key], prefix);
    }).filter(function(part) {
      return part.length > 0;
    }).join("&");
  }
  exports.queryParamsStringify = queryParamsStringify;
  function querystringSingleKey(key, value2, keyPrefix) {
    if (keyPrefix === undefined) {
      keyPrefix = "";
    }
    var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
    if (Array.isArray(value2)) {
      var multiValue = value2.map(function(singleValue) {
        return encodeURIComponent(String(singleValue));
      }).join("&".concat(encodeURIComponent(fullKey), "="));
      return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
    }
    if (value2 instanceof Set) {
      var valueAsArray = Array.from(value2);
      return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value2 instanceof Date) {
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value2.toISOString()));
    }
    if (value2 instanceof Object) {
      return queryParamsStringify(value2, fullKey);
    }
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value2)));
  }
});

// node_modules/@pinecone-database/pinecone/dist/utils/environment.js
var require_environment = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isBrowser = exports.isEdge = undefined;
  var isEdge = function() {
    return typeof EdgeRuntime === "string";
  };
  exports.isEdge = isEdge;
  var isBrowser = function() {
    return typeof window !== "undefined";
  };
  exports.isBrowser = isBrowser;
});

// node_modules/@pinecone-database/pinecone/dist/version.json
var require_version = __commonJS((exports, module) => {
  module.exports = {
    name: "@pinecone-database/pinecone",
    version: "3.0.3"
  };
});

// node_modules/@pinecone-database/pinecone/dist/utils/user-agent.js
var require_user_agent = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.buildUserAgent = undefined;
  var environment_1 = require_environment();
  var packageInfo = __importStar(require_version());
  var buildUserAgent = function(config) {
    var userAgentParts = [
      "".concat(packageInfo.name, " v").concat(packageInfo.version),
      "lang=typescript"
    ];
    if ((0, environment_1.isEdge)()) {
      userAgentParts.push("Edge Runtime");
    }
    if (typeof process !== "undefined" && process && process.version) {
      userAgentParts.push("node ".concat(process.version));
    }
    if (config.sourceTag) {
      userAgentParts.push("source_tag=".concat(normalizeSourceTag(config.sourceTag)));
    }
    return userAgentParts.join("; ");
  };
  exports.buildUserAgent = buildUserAgent;
  var normalizeSourceTag = function(sourceTag) {
    if (!sourceTag) {
      return;
    }
    return sourceTag.toLowerCase().replace(/[^a-z0-9_ :]/g, "").trim().replace(/[ ]+/g, "_");
  };
});

// node_modules/@pinecone-database/pinecone/dist/errors/base.js
var require_base = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BasePineconeError = undefined;
  var BasePineconeError = function(_super) {
    __extends(BasePineconeError2, _super);
    function BasePineconeError2(message2, cause) {
      var _newTarget = this.constructor;
      var _this = _super.call(this, message2) || this;
      Object.setPrototypeOf(_this, _newTarget.prototype);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_this, _newTarget);
      }
      _this.name = _this.constructor.name;
      _this.cause = cause;
      return _this;
    }
    return BasePineconeError2;
  }(Error);
  exports.BasePineconeError = BasePineconeError;
});

// node_modules/@pinecone-database/pinecone/dist/errors/config.js
var require_config = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PineconeUnableToResolveHostError = exports.PineconeEnvironmentVarsNotSupportedError = exports.PineconeUnexpectedResponseError = exports.PineconeConfigurationError = undefined;
  var base_1 = require_base();
  var CONFIG_HELP = "You can find the configuration values for your project in the Pinecone developer console at https://app.pinecone.io.";
  var PineconeConfigurationError = function(_super) {
    __extends(PineconeConfigurationError2, _super);
    function PineconeConfigurationError2(message2) {
      var _this = _super.call(this, "".concat(message2, " ").concat(CONFIG_HELP)) || this;
      _this.name = "PineconeConfigurationError";
      return _this;
    }
    return PineconeConfigurationError2;
  }(base_1.BasePineconeError);
  exports.PineconeConfigurationError = PineconeConfigurationError;
  var PineconeUnexpectedResponseError = function(_super) {
    __extends(PineconeUnexpectedResponseError2, _super);
    function PineconeUnexpectedResponseError2(url, status, body, message2) {
      var _this = _super.call(this, "Unexpected response while calling ".concat(url, ". ").concat(message2 ? message2 + " " : "", "Status: ").concat(status, ". Body: ").concat(body)) || this;
      _this.name = "PineconeUnexpectedResponseError";
      return _this;
    }
    return PineconeUnexpectedResponseError2;
  }(base_1.BasePineconeError);
  exports.PineconeUnexpectedResponseError = PineconeUnexpectedResponseError;
  var PineconeEnvironmentVarsNotSupportedError = function(_super) {
    __extends(PineconeEnvironmentVarsNotSupportedError2, _super);
    function PineconeEnvironmentVarsNotSupportedError2(message2) {
      var _this = _super.call(this, message2) || this;
      _this.name = "PineconeEnvironmentVarsNotSupportedError";
      return _this;
    }
    return PineconeEnvironmentVarsNotSupportedError2;
  }(base_1.BasePineconeError);
  exports.PineconeEnvironmentVarsNotSupportedError = PineconeEnvironmentVarsNotSupportedError;
  var PineconeUnableToResolveHostError = function(_super) {
    __extends(PineconeUnableToResolveHostError2, _super);
    function PineconeUnableToResolveHostError2(message2) {
      var _this = _super.call(this, message2) || this;
      _this.name = "PineconeUnableToResolveHostError";
      return _this;
    }
    return PineconeUnableToResolveHostError2;
  }(base_1.BasePineconeError);
  exports.PineconeUnableToResolveHostError = PineconeUnableToResolveHostError;
});

// node_modules/@pinecone-database/pinecone/dist/errors/http.js
var require_http = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mapHttpStatusError = exports.PineconeUnmappedHttpError = exports.PineconeNotImplementedError = exports.PineconeInternalServerError = exports.PineconeConflictError = exports.PineconeNotFoundError = exports.PineconeAuthorizationError = exports.PineconeBadRequestError = undefined;
  var base_1 = require_base();
  var CONFIG_HELP = "You can find the configuration values for your project in the Pinecone developer console at https://app.pinecone.io";
  var PineconeBadRequestError = function(_super) {
    __extends(PineconeBadRequestError2, _super);
    function PineconeBadRequestError2(failedRequest) {
      var _this = this;
      var message2 = failedRequest.message;
      _this = _super.call(this, message2) || this;
      _this.name = "PineconeBadRequestError";
      return _this;
    }
    return PineconeBadRequestError2;
  }(base_1.BasePineconeError);
  exports.PineconeBadRequestError = PineconeBadRequestError;
  var PineconeAuthorizationError = function(_super) {
    __extends(PineconeAuthorizationError2, _super);
    function PineconeAuthorizationError2(failedRequest) {
      var _this = this;
      var url = failedRequest.url;
      if (url) {
        _this = _super.call(this, "The API key you provided was rejected while calling ".concat(url, ". Please check your configuration values and try again. ").concat(CONFIG_HELP)) || this;
      } else {
        _this = _super.call(this, "The API key you provided was rejected. Please check your configuration values and try again. ".concat(CONFIG_HELP)) || this;
      }
      _this.name = "PineconeAuthorizationError";
      return _this;
    }
    return PineconeAuthorizationError2;
  }(base_1.BasePineconeError);
  exports.PineconeAuthorizationError = PineconeAuthorizationError;
  var PineconeNotFoundError = function(_super) {
    __extends(PineconeNotFoundError2, _super);
    function PineconeNotFoundError2(failedRequest) {
      var _this = this;
      var url = failedRequest.url;
      if (url) {
        _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 404.")) || this;
      } else {
        _this = _super.call(this, "The requested resource could not be found.") || this;
      }
      _this.name = "PineconeNotFoundError";
      return _this;
    }
    return PineconeNotFoundError2;
  }(base_1.BasePineconeError);
  exports.PineconeNotFoundError = PineconeNotFoundError;
  var PineconeConflictError = function(_super) {
    __extends(PineconeConflictError2, _super);
    function PineconeConflictError2(failedRequest) {
      var _this = this;
      var { url, message: message2 } = failedRequest;
      if (url) {
        _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 409. ").concat(message2 ? message2 : "")) || this;
      } else {
        _this = _super.call(this, "The resource you are attempting to create already exists.") || this;
      }
      _this.name = "PineconeConflictError";
      return _this;
    }
    return PineconeConflictError2;
  }(base_1.BasePineconeError);
  exports.PineconeConflictError = PineconeConflictError;
  var PineconeInternalServerError = function(_super) {
    __extends(PineconeInternalServerError2, _super);
    function PineconeInternalServerError2(failedRequest) {
      var _this = this;
      var { url, body } = failedRequest;
      var intro = url ? "An internal server error occured while calling the ".concat(url, " endpoint.") : "";
      var help = "To see overall service health and learn whether this seems like a large-scale problem or one specific to your request, please go to https://status.pinecone.io/ to view our status page. If you believe the error reflects a problem with this client, please file a bug report in the github issue tracker at https://github.com/pinecone-io/pinecone-ts-client";
      var bodyMessage = body ? "Body: ".concat(body) : "";
      _this = _super.call(this, [intro, help, bodyMessage].join(" ").trim()) || this;
      _this.name = "PineconeInternalServerError";
      return _this;
    }
    return PineconeInternalServerError2;
  }(base_1.BasePineconeError);
  exports.PineconeInternalServerError = PineconeInternalServerError;
  var PineconeNotImplementedError = function(_super) {
    __extends(PineconeNotImplementedError2, _super);
    function PineconeNotImplementedError2(requestInfo) {
      var _this = this;
      var { url, message: message2 } = requestInfo;
      if (url) {
        _this = _super.call(this, "A call to ".concat(url, " returned HTTP status 501. ").concat(message2 ? message2 : "")) || this;
      } else {
        _this = _super.call(this) || this;
      }
      _this.name = "PineconeNotImplementedError";
      return _this;
    }
    return PineconeNotImplementedError2;
  }(base_1.BasePineconeError);
  exports.PineconeNotImplementedError = PineconeNotImplementedError;
  var PineconeUnmappedHttpError = function(_super) {
    __extends(PineconeUnmappedHttpError2, _super);
    function PineconeUnmappedHttpError2(failedRequest) {
      var _this = this;
      var { url, status, body, message: message2 } = failedRequest;
      var intro = url ? "An unexpected error occured while calling the ".concat(url, " endpoint. ") : "";
      var statusMsg = status ? "Status: ".concat(status, ". ") : "";
      var bodyMsg = body ? "Body: ".concat(body) : "";
      _this = _super.call(this, [intro, message2, statusMsg, bodyMsg].join(" ").trim()) || this;
      _this.name = "PineconeUnmappedHttpError";
      return _this;
    }
    return PineconeUnmappedHttpError2;
  }(base_1.BasePineconeError);
  exports.PineconeUnmappedHttpError = PineconeUnmappedHttpError;
  var mapHttpStatusError = function(failedRequestInfo) {
    switch (failedRequestInfo.status) {
      case 400:
        return new PineconeBadRequestError(failedRequestInfo);
      case 401:
        return new PineconeAuthorizationError(failedRequestInfo);
      case 403:
        return new PineconeBadRequestError(failedRequestInfo);
      case 404:
        return new PineconeNotFoundError(failedRequestInfo);
      case 409:
        return new PineconeConflictError(failedRequestInfo);
      case 500:
        return new PineconeInternalServerError(failedRequestInfo);
      case 501:
        return new PineconeNotImplementedError(failedRequestInfo);
      default:
        throw new PineconeUnmappedHttpError(failedRequestInfo);
    }
  };
  exports.mapHttpStatusError = mapHttpStatusError;
});

// node_modules/@pinecone-database/pinecone/dist/errors/request.js
var require_request = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PineconeRequestError = exports.PineconeConnectionError = undefined;
  var base_1 = require_base();
  var PineconeConnectionError = function(_super) {
    __extends(PineconeConnectionError2, _super);
    function PineconeConnectionError2(e, url) {
      var _this = this;
      var urlMessage = "";
      if (url) {
        urlMessage = " while calling ".concat(url);
      }
      _this = _super.call(this, "Request failed to reach Pinecone".concat(urlMessage, ". This can occur for reasons such as network problems that prevent the request from being completed, or a Pinecone API outage. Check your network connection, and visit https://status.pinecone.io/ to see whether any outages are ongoing."), e) || this;
      _this.name = "PineconeConnectionError";
      return _this;
    }
    return PineconeConnectionError2;
  }(base_1.BasePineconeError);
  exports.PineconeConnectionError = PineconeConnectionError;
  var PineconeRequestError = function(_super) {
    __extends(PineconeRequestError2, _super);
    function PineconeRequestError2(context) {
      var _this = this;
      if (context.response) {
        _this = _super.call(this, "Request failed during a call to ".concat(context.init.method, " ").concat(context.url, " with status ").concat(context.response.status), context.error) || this;
      } else {
        _this = _super.call(this, "Request failed during a call to ".concat(context.init.method, " ").concat(context.url), context.error) || this;
      }
      return _this;
    }
    return PineconeRequestError2;
  }(base_1.BasePineconeError);
  exports.PineconeRequestError = PineconeRequestError;
});

// node_modules/@pinecone-database/pinecone/dist/errors/validation.js
var require_validation = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PineconeArgumentError = undefined;
  var base_1 = require_base();
  var PineconeArgumentError = function(_super) {
    __extends(PineconeArgumentError2, _super);
    function PineconeArgumentError2(message2) {
      var _this = _super.call(this, "".concat(message2)) || this;
      _this.name = "PineconeArgumentError";
      return _this;
    }
    return PineconeArgumentError2;
  }(base_1.BasePineconeError);
  exports.PineconeArgumentError = PineconeArgumentError;
});

// node_modules/@pinecone-database/pinecone/dist/errors/utils.js
var require_utils = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.extractMessage = undefined;
  var extractMessage = function(error4) {
    return __awaiter(undefined, undefined, undefined, function() {
      var message2, messageJSON;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, error4.response.text()];
          case 1:
            message2 = _a2.sent();
            try {
              messageJSON = JSON.parse(message2);
              if (messageJSON.message) {
                message2 = messageJSON.message;
              }
            } catch (e) {
            }
            return [2, message2];
        }
      });
    });
  };
  exports.extractMessage = extractMessage;
});

// node_modules/@pinecone-database/pinecone/dist/errors/handling.js
var require_handling = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.handleApiError = undefined;
  var utils_1 = require_utils();
  var http_1 = require_http();
  var request_1 = require_request();
  var handleApiError = function(e, customMessage, url) {
    return __awaiter(undefined, undefined, undefined, function() {
      var responseError, rawMessage, statusCode, message2, _a2, err;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (!(e instanceof Error && e.name === "ResponseError"))
              return [3, 5];
            responseError = e;
            return [4, (0, utils_1.extractMessage)(responseError)];
          case 1:
            rawMessage = _b.sent();
            statusCode = responseError.response.status;
            if (!customMessage)
              return [3, 3];
            return [4, customMessage(statusCode, rawMessage)];
          case 2:
            _a2 = _b.sent();
            return [3, 4];
          case 3:
            _a2 = rawMessage;
            _b.label = 4;
          case 4:
            message2 = _a2;
            return [2, (0, http_1.mapHttpStatusError)({
              status: responseError.response.status,
              url: responseError.response.url || url,
              message: message2
            })];
          case 5:
            if (e instanceof request_1.PineconeConnectionError) {
              return [2, e];
            } else {
              err = e;
              return [2, new request_1.PineconeConnectionError(err)];
            }
            _b.label = 6;
          case 6:
            return [2];
        }
      });
    });
  };
  exports.handleApiError = handleApiError;
});

// node_modules/@pinecone-database/pinecone/dist/errors/index.js
var require_errors = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.handleApiError = exports.extractMessage = exports.PineconeArgumentError = exports.BasePineconeError = exports.PineconeRequestError = exports.PineconeConnectionError = exports.PineconeUnableToResolveHostError = exports.PineconeEnvironmentVarsNotSupportedError = exports.PineconeUnexpectedResponseError = exports.PineconeConfigurationError = undefined;
  var config_1 = require_config();
  Object.defineProperty(exports, "PineconeConfigurationError", { enumerable: true, get: function() {
    return config_1.PineconeConfigurationError;
  } });
  Object.defineProperty(exports, "PineconeUnexpectedResponseError", { enumerable: true, get: function() {
    return config_1.PineconeUnexpectedResponseError;
  } });
  Object.defineProperty(exports, "PineconeEnvironmentVarsNotSupportedError", { enumerable: true, get: function() {
    return config_1.PineconeEnvironmentVarsNotSupportedError;
  } });
  Object.defineProperty(exports, "PineconeUnableToResolveHostError", { enumerable: true, get: function() {
    return config_1.PineconeUnableToResolveHostError;
  } });
  __exportStar(require_http(), exports);
  var request_1 = require_request();
  Object.defineProperty(exports, "PineconeConnectionError", { enumerable: true, get: function() {
    return request_1.PineconeConnectionError;
  } });
  Object.defineProperty(exports, "PineconeRequestError", { enumerable: true, get: function() {
    return request_1.PineconeRequestError;
  } });
  var base_1 = require_base();
  Object.defineProperty(exports, "BasePineconeError", { enumerable: true, get: function() {
    return base_1.BasePineconeError;
  } });
  var validation_1 = require_validation();
  Object.defineProperty(exports, "PineconeArgumentError", { enumerable: true, get: function() {
    return validation_1.PineconeArgumentError;
  } });
  var utils_1 = require_utils();
  Object.defineProperty(exports, "extractMessage", { enumerable: true, get: function() {
    return utils_1.extractMessage;
  } });
  var handling_1 = require_handling();
  Object.defineProperty(exports, "handleApiError", { enumerable: true, get: function() {
    return handling_1.handleApiError;
  } });
});

// node_modules/@pinecone-database/pinecone/dist/utils/fetch.js
var require_fetch = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFetch = undefined;
  var errors_1 = require_errors();
  var getFetch = function(config) {
    if (config.fetchApi) {
      return config.fetchApi;
    } else if (global.fetch) {
      return global.fetch;
    } else {
      throw new errors_1.PineconeConfigurationError("No global or user-provided fetch implementations found. Please supply a fetch implementation.");
    }
  };
  exports.getFetch = getFetch;
});

// node_modules/@pinecone-database/pinecone/dist/utils/index.js
var require_utils2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getFetch = exports.buildUserAgent = exports.queryParamsStringify = exports.normalizeUrl = exports.debugLog = undefined;
  var debugLog_1 = require_debugLog();
  Object.defineProperty(exports, "debugLog", { enumerable: true, get: function() {
    return debugLog_1.debugLog;
  } });
  var normalizeUrl_1 = require_normalizeUrl();
  Object.defineProperty(exports, "normalizeUrl", { enumerable: true, get: function() {
    return normalizeUrl_1.normalizeUrl;
  } });
  var queryParamsStringify_1 = require_queryParamsStringify();
  Object.defineProperty(exports, "queryParamsStringify", { enumerable: true, get: function() {
    return queryParamsStringify_1.queryParamsStringify;
  } });
  var user_agent_1 = require_user_agent();
  Object.defineProperty(exports, "buildUserAgent", { enumerable: true, get: function() {
    return user_agent_1.buildUserAgent;
  } });
  var fetch_1 = require_fetch();
  Object.defineProperty(exports, "getFetch", { enumerable: true, get: function() {
    return fetch_1.getFetch;
  } });
});

// node_modules/@pinecone-database/pinecone/dist/utils/middleware.js
var require_middleware = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar;i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.middleware = undefined;
  var db_control_1 = require_db_control();
  var errors_1 = require_errors();
  var debugMiddleware = [];
  var chalk = function(str2, color) {
    var colors = {
      blue: "\x1B[34m",
      red: "\x1B[31m",
      green: "\x1B[32m",
      yellow: "\x1B[33m"
    };
    return colors[color] + str2 + "\x1B[39m";
  };
  if (typeof process !== "undefined" && process && process.env && process.env.PINECONE_DEBUG) {
    debugLogMiddleware = {
      pre: function(context) {
        return __awaiter(undefined, undefined, undefined, function() {
          var headers;
          return __generator(this, function(_a2) {
            console.debug(chalk(">>> Request: ".concat(context.init.method, " ").concat(context.url), "blue"));
            headers = JSON.parse(JSON.stringify(context.init.headers));
            headers["Api-Key"] = "***REDACTED***";
            console.debug(chalk(">>> Headers: ".concat(JSON.stringify(headers)), "blue"));
            if (context.init.body) {
              console.debug(chalk(">>> Body: ".concat(context.init.body), "blue"));
            }
            console.debug("");
            return [2];
          });
        });
      },
      post: function(context) {
        return __awaiter(undefined, undefined, undefined, function() {
          var _a2, _b, _c, _d;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                console.debug(chalk("<<< Status: ".concat(context.response.status), "green"));
                _b = (_a2 = console).debug;
                _c = chalk;
                _d = "<<< Body: ".concat;
                return [4, context.response.text()];
              case 1:
                _b.apply(_a2, [_c.apply(undefined, [_d.apply("<<< Body: ", [_e.sent()]), "green"])]);
                console.debug("");
                return [2];
            }
          });
        });
      }
    };
    debugMiddleware.push(debugLogMiddleware);
  }
  var debugLogMiddleware;
  if (typeof process !== "undefined" && process && process.env && process.env.PINECONE_DEBUG_CURL) {
    debugCurlMiddleware = {
      post: function(context) {
        return __awaiter(undefined, undefined, undefined, function() {
          var headers, cmd;
          return __generator(this, function(_a2) {
            headers = "-H \"Api-Key: ".concat((context.init.headers || {})["Api-Key"], "\"");
            if (context.init.headers && context.init.headers["Content-Type"]) {
              headers += " -H \"Content-Type: ".concat(context.init.headers["Content-Type"], "\"");
            }
            cmd = "curl -X ".concat(context.init.method, " ").concat(context.url, " ").concat(headers, " ").concat(context.init.body ? "-d '".concat(context.init.body, "'") : "");
            console.debug(chalk(cmd, "red"));
            console.debug("");
            return [2];
          });
        });
      }
    };
    debugMiddleware.push(debugCurlMiddleware);
  }
  var debugCurlMiddleware;
  exports.middleware = __spreadArray(__spreadArray([], debugMiddleware, true), [
    {
      onError: function(context) {
        return __awaiter(undefined, undefined, undefined, function() {
          var err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, (0, errors_1.handleApiError)(context.error, undefined, context.url)];
              case 1:
                err = _a2.sent();
                throw err;
            }
          });
        });
      },
      post: function(context) {
        return __awaiter(undefined, undefined, undefined, function() {
          var response, err;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                response = context.response;
                if (!(response.status >= 200 && response.status < 300))
                  return [3, 1];
                return [2, response];
              case 1:
                return [4, (0, errors_1.handleApiError)(new db_control_1.ResponseError(response, "Response returned an error"), undefined, context.url)];
              case 2:
                err = _a2.sent();
                throw err;
            }
          });
        });
      }
    }
  ], false);
});

// node_modules/@pinecone-database/pinecone/dist/control/indexOperationsBuilder.js
var require_indexOperationsBuilder = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.indexOperationsBuilder = undefined;
  var db_control_1 = require_db_control();
  var utils_1 = require_utils2();
  var middleware_1 = require_middleware();
  var indexOperationsBuilder = function(config) {
    var apiKey = config.apiKey;
    var controllerPath = (0, utils_1.normalizeUrl)(config.controllerHostUrl) || "https://api.pinecone.io";
    var headers = config.additionalHeaders || null;
    var apiConfig = {
      basePath: controllerPath,
      apiKey,
      queryParamsStringify: utils_1.queryParamsStringify,
      headers: __assign({ "User-Agent": (0, utils_1.buildUserAgent)(config), "X-Pinecone-Api-Version": db_control_1.X_PINECONE_API_VERSION }, headers),
      fetchApi: (0, utils_1.getFetch)(config),
      middleware: middleware_1.middleware
    };
    return new db_control_1.ManageIndexesApi(new db_control_1.Configuration(apiConfig));
  };
  exports.indexOperationsBuilder = indexOperationsBuilder;
});

// node_modules/@pinecone-database/pinecone/dist/utils/validateProperties.js
var require_validateProperties = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValidateProperties = undefined;
  var errors_1 = require_errors();
  function ValidateProperties(item, validProperties) {
    var itemKeys = Object.keys(item);
    var invalidKeys = itemKeys.filter(function(key) {
      return !validProperties.includes(key);
    });
    if (invalidKeys.length > 0) {
      throw new errors_1.PineconeArgumentError("Object contained invalid properties: ".concat(invalidKeys.join(", "), ". Valid properties include ").concat(validProperties.join(", "), "."));
    }
  }
  exports.ValidateProperties = ValidateProperties;
});

// node_modules/@pinecone-database/pinecone/dist/control/configureIndex.js
var require_configureIndex = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.configureIndex = exports.ConfigureIndexRequestProperties = undefined;
  var errors_1 = require_errors();
  var validateProperties_1 = require_validateProperties();
  exports.ConfigureIndexRequestProperties = [
    "deletionProtection",
    "spec"
  ];
  var configureIndex = function(api) {
    var validator = function(indexName, options) {
      if (options) {
        (0, validateProperties_1.ValidateProperties)(options, exports.ConfigureIndexRequestProperties);
      }
      if (!indexName) {
        throw new errors_1.PineconeArgumentError("You must pass a non-empty string for `indexName` to configureIndex.");
      }
      if (!options.spec && !options.deletionProtection) {
        throw new errors_1.PineconeArgumentError("You must pass either a `spec`, `deletionProtection` or both to configureIndex in order to update.");
      }
      if (options.spec) {
        if (options.spec.pod) {
          (0, validateProperties_1.ValidateProperties)(options.spec.pod, ["replicas", "podType"]);
        }
        if (options.spec.pod && options.spec.pod.replicas) {
          if (options.spec.pod.replicas <= 0) {
            throw new errors_1.PineconeArgumentError("`replicas` must be a positive integer.");
          }
        }
      }
    };
    return function(indexName, options) {
      return __awaiter(undefined, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              validator(indexName, options);
              return [4, api.configureIndex({
                indexName,
                configureIndexRequest: options
              })];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
  };
  exports.configureIndex = configureIndex;
});

// node_modules/@pinecone-database/pinecone/dist/control/types.js
var require_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ValidPodTypes = undefined;
  exports.ValidPodTypes = [
    "s1.x1",
    "s1.x2",
    "s1.x4",
    "s1.x8",
    "p1.x1",
    "p1.x2",
    "p1.x4",
    "p1.x8",
    "p2.x1",
    "p2.x2",
    "p2.x4",
    "p2.x8"
  ];
});

// node_modules/@pinecone-database/pinecone/dist/control/createIndex.js
var require_createIndex = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createIndex = undefined;
  var db_control_1 = require_db_control();
  var utils_1 = require_utils2();
  var types_1 = require_types();
  var errors_1 = require_errors();
  var validateProperties_1 = require_validateProperties();
  var CreateIndexOptionsProperties = [
    "spec",
    "name",
    "dimension",
    "metric",
    "deletionProtection",
    "waitUntilReady",
    "suppressConflicts"
  ];
  var CreateIndexSpecProperties = ["serverless", "pod"];
  var CreateIndexServerlessSpecProperties = [
    "cloud",
    "region"
  ];
  var CreateIndexPodSpecProperties = [
    "environment",
    "replicas",
    "shards",
    "podType",
    "pods",
    "metadataConfig",
    "sourceCollection"
  ];
  var createIndex = function(api) {
    var validator = function(options) {
      if (options) {
        (0, validateProperties_1.ValidateProperties)(options, CreateIndexOptionsProperties);
      }
      if (!options) {
        throw new errors_1.PineconeArgumentError("You must pass an object with required properties (`name`, `dimension`, `spec`) to create an index.");
      }
      if (!options.name) {
        throw new errors_1.PineconeArgumentError("You must pass a non-empty string for `name` in order to create an index.");
      }
      if (!options.dimension || options.dimension <= 0) {
        throw new errors_1.PineconeArgumentError("You must pass a positive integer for `dimension` in order to create an index.");
      }
      if (!options.spec) {
        throw new errors_1.PineconeArgumentError("You must pass a `pods` or `serverless` `spec` object in order to create an index.");
      }
      if (options.spec) {
        (0, validateProperties_1.ValidateProperties)(options.spec, CreateIndexSpecProperties);
      }
      if (options.spec.serverless) {
        (0, validateProperties_1.ValidateProperties)(options.spec.serverless, CreateIndexServerlessSpecProperties);
        if (!options.spec.serverless.cloud) {
          throw new errors_1.PineconeArgumentError("You must pass a `cloud` for the serverless `spec` object in order to create an index.");
        }
        if (!options.spec.serverless.region) {
          throw new errors_1.PineconeArgumentError("You must pass a `region` for the serverless `spec` object in order to create an index.");
        }
      }
      if (options.spec.pod) {
        (0, validateProperties_1.ValidateProperties)(options.spec.pod, CreateIndexPodSpecProperties);
        if (!options.spec.pod.environment) {
          throw new errors_1.PineconeArgumentError("You must pass an `environment` for the pod `spec` object in order to create an index.");
        }
        if (!options.spec.pod.podType) {
          throw new errors_1.PineconeArgumentError("You must pass a `podType` for the pod `spec` object in order to create an index.");
        }
      }
      if (options.spec.serverless && options.spec.serverless.cloud && !Object.values(db_control_1.ServerlessSpecCloudEnum).includes(options.spec.serverless.cloud)) {
        throw new errors_1.PineconeArgumentError("Invalid cloud value: ".concat(options.spec.serverless.cloud, ". Valid values are: ").concat(Object.values(db_control_1.ServerlessSpecCloudEnum).join(", "), "."));
      }
      if (options.metric && !Object.values(db_control_1.IndexModelMetricEnum).includes(options.metric)) {
        {
          throw new errors_1.PineconeArgumentError("Invalid metric value: ".concat(options.metric, ". Valid values are: 'cosine', 'euclidean', or 'dotproduct.'"));
        }
      }
      if (options.spec.pod && options.spec.pod.replicas && options.spec.pod.replicas <= 0) {
        throw new errors_1.PineconeArgumentError("You must pass a positive integer for `replicas` in order to create an index.");
      }
      if (options.spec.pod && options.spec.pod.pods && options.spec.pod.pods <= 0) {
        throw new errors_1.PineconeArgumentError("You must pass a positive integer for `pods` in order to create an index.");
      }
      if (options.spec.pod && !types_1.ValidPodTypes.includes(options.spec.pod.podType)) {
        throw new errors_1.PineconeArgumentError("Invalid pod type: ".concat(options.spec.pod.podType, ". Valid values are: ").concat(types_1.ValidPodTypes.join(", "), "."));
      }
    };
    return function(options) {
      return __awaiter(undefined, undefined, undefined, function() {
        var createResponse, e_1;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (options && !options.metric) {
                options.metric = db_control_1.IndexModelMetricEnum.Cosine;
              }
              validator(options);
              _a2.label = 1;
            case 1:
              _a2.trys.push([1, 5, , 6]);
              return [4, api.createIndex({
                createIndexRequest: options
              })];
            case 2:
              createResponse = _a2.sent();
              if (!options.waitUntilReady)
                return [3, 4];
              return [4, waitUntilIndexIsReady(api, options.name)];
            case 3:
              return [2, _a2.sent()];
            case 4:
              return [2, createResponse];
            case 5:
              e_1 = _a2.sent();
              if (!(options.suppressConflicts && e_1 instanceof Error && e_1.name === "PineconeConflictError")) {
                throw e_1;
              }
              return [3, 6];
            case 6:
              return [2];
          }
        });
      });
    };
  };
  exports.createIndex = createIndex;
  var waitUntilIndexIsReady = function(api, indexName, seconds) {
    if (seconds === undefined) {
      seconds = 0;
    }
    return __awaiter(undefined, undefined, undefined, function() {
      var indexDescription, e_2, err;
      var _a2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 6, , 8]);
            return [4, api.describeIndex({ indexName })];
          case 1:
            indexDescription = _b.sent();
            if (!!((_a2 = indexDescription.status) === null || _a2 === undefined ? undefined : _a2.ready))
              return [3, 4];
            return [4, new Promise(function(r) {
              return setTimeout(r, 1000);
            })];
          case 2:
            _b.sent();
            return [4, waitUntilIndexIsReady(api, indexName, seconds + 1)];
          case 3:
            return [2, _b.sent()];
          case 4:
            (0, utils_1.debugLog)("Index ".concat(indexName, " is ready after ").concat(seconds));
            return [2, indexDescription];
          case 5:
            return [3, 8];
          case 6:
            e_2 = _b.sent();
            return [4, (0, errors_1.handleApiError)(e_2, function(_2, rawMessageText) {
              return __awaiter(undefined, undefined, undefined, function() {
                return __generator(this, function(_a3) {
                  return [2, "Error creating index ".concat(indexName, ": ").concat(rawMessageText)];
                });
              });
            })];
          case 7:
            err = _b.sent();
            throw err;
          case 8:
            return [2];
        }
      });
    });
  };
});

// node_modules/@pinecone-database/pinecone/dist/control/deleteIndex.js
var require_deleteIndex = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteIndex = undefined;
  var errors_1 = require_errors();
  var deleteIndex = function(api) {
    return function(indexName) {
      return __awaiter(undefined, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!indexName) {
                throw new errors_1.PineconeArgumentError("You must pass a non-empty string for `indexName` in order to delete an index");
              }
              return [4, api.deleteIndex({ indexName })];
            case 1:
              _a2.sent();
              return [2];
          }
        });
      });
    };
  };
  exports.deleteIndex = deleteIndex;
});

// node_modules/@pinecone-database/pinecone/dist/control/describeIndex.js
var require_describeIndex = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.describeIndex = undefined;
  var errors_1 = require_errors();
  var describeIndex = function(api) {
    var removeDeprecatedFields = function(result) {
      if (result.database) {
        for (var _i = 0, _a2 = Object.keys(result.database);_i < _a2.length; _i++) {
          var key = _a2[_i];
          if (result.database[key] === undefined) {
            delete result.database[key];
          }
        }
      }
    };
    return function(indexName) {
      return __awaiter(undefined, undefined, undefined, function() {
        var result;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!indexName) {
                throw new errors_1.PineconeArgumentError("You must pass a non-empty string for `name` in order to describe an index");
              }
              return [4, api.describeIndex({ indexName })];
            case 1:
              result = _a2.sent();
              removeDeprecatedFields(result);
              return [2, result];
          }
        });
      });
    };
  };
  exports.describeIndex = describeIndex;
});

// node_modules/@pinecone-database/pinecone/dist/control/listIndexes.js
var require_listIndexes = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listIndexes = undefined;
  var listIndexes = function(api) {
    return function() {
      return __awaiter(undefined, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, api.listIndexes()];
            case 1:
              response = _a2.sent();
              return [2, response];
          }
        });
      });
    };
  };
  exports.listIndexes = listIndexes;
});

// node_modules/@pinecone-database/pinecone/dist/control/createCollection.js
var require_createCollection = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createCollection = exports.CreateCollectionRequestProperties = undefined;
  var errors_1 = require_errors();
  var validateProperties_1 = require_validateProperties();
  exports.CreateCollectionRequestProperties = ["source", "name"];
  var createCollection = function(api) {
    var validator = function(options) {
      if (options) {
        (0, validateProperties_1.ValidateProperties)(options, exports.CreateCollectionRequestProperties);
      }
      if (!options || typeof options !== "object") {
        throw new errors_1.PineconeArgumentError("You must pass a non-empty object with `name` and `source` fields in order to create a collection.");
      }
      if (!options.name && !options.source) {
        throw new errors_1.PineconeArgumentError("The argument to createCollection must have required properties: `name`, `source`.");
      }
      if (!options.name) {
        throw new errors_1.PineconeArgumentError("You must pass a non-empty string for `name` in order to create a collection.");
      }
      if (!options.source) {
        throw new errors_1.PineconeArgumentError("You must pass a non-empty string for `source` in order to create a collection.");
      }
    };
    return function(options) {
      return __awaiter(undefined, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              validator(options);
              return [4, api.createCollection({ createCollectionRequest: options })];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
  };
  exports.createCollection = createCollection;
});

// node_modules/@pinecone-database/pinecone/dist/control/deleteCollection.js
var require_deleteCollection = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteCollection = undefined;
  var errors_1 = require_errors();
  var deleteCollection = function(api) {
    return function(collectionName) {
      return __awaiter(undefined, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!collectionName) {
                throw new errors_1.PineconeArgumentError("You must pass a non-empty string for `collectionName`");
              }
              return [4, api.deleteCollection({ collectionName })];
            case 1:
              _a2.sent();
              return [2];
          }
        });
      });
    };
  };
  exports.deleteCollection = deleteCollection;
});

// node_modules/@pinecone-database/pinecone/dist/control/describeCollection.js
var require_describeCollection = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.describeCollection = undefined;
  var errors_1 = require_errors();
  var describeCollection = function(api) {
    return function(name) {
      return __awaiter(undefined, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!name || name.length === 0) {
                throw new errors_1.PineconeArgumentError("You must pass a non-empty string for `name` in order to describe a collection");
              }
              return [4, api.describeCollection({ collectionName: name })];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
  };
  exports.describeCollection = describeCollection;
});

// node_modules/@pinecone-database/pinecone/dist/control/listCollections.js
var require_listCollections = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listCollections = undefined;
  var listCollections = function(api) {
    return function() {
      return __awaiter(undefined, undefined, undefined, function() {
        var results;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, api.listCollections()];
            case 1:
              results = _a2.sent();
              return [2, results];
          }
        });
      });
    };
  };
  exports.listCollections = listCollections;
});

// node_modules/@pinecone-database/pinecone/dist/control/index.js
var require_control = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listCollections = exports.describeCollection = exports.deleteCollection = exports.createCollection = exports.listIndexes = exports.describeIndex = exports.deleteIndex = exports.createIndex = exports.configureIndex = exports.indexOperationsBuilder = undefined;
  var indexOperationsBuilder_1 = require_indexOperationsBuilder();
  Object.defineProperty(exports, "indexOperationsBuilder", { enumerable: true, get: function() {
    return indexOperationsBuilder_1.indexOperationsBuilder;
  } });
  var configureIndex_1 = require_configureIndex();
  Object.defineProperty(exports, "configureIndex", { enumerable: true, get: function() {
    return configureIndex_1.configureIndex;
  } });
  var createIndex_1 = require_createIndex();
  Object.defineProperty(exports, "createIndex", { enumerable: true, get: function() {
    return createIndex_1.createIndex;
  } });
  var deleteIndex_1 = require_deleteIndex();
  Object.defineProperty(exports, "deleteIndex", { enumerable: true, get: function() {
    return deleteIndex_1.deleteIndex;
  } });
  var describeIndex_1 = require_describeIndex();
  Object.defineProperty(exports, "describeIndex", { enumerable: true, get: function() {
    return describeIndex_1.describeIndex;
  } });
  var listIndexes_1 = require_listIndexes();
  Object.defineProperty(exports, "listIndexes", { enumerable: true, get: function() {
    return listIndexes_1.listIndexes;
  } });
  var createCollection_1 = require_createCollection();
  Object.defineProperty(exports, "createCollection", { enumerable: true, get: function() {
    return createCollection_1.createCollection;
  } });
  var deleteCollection_1 = require_deleteCollection();
  Object.defineProperty(exports, "deleteCollection", { enumerable: true, get: function() {
    return deleteCollection_1.deleteCollection;
  } });
  var describeCollection_1 = require_describeCollection();
  Object.defineProperty(exports, "describeCollection", { enumerable: true, get: function() {
    return describeCollection_1.describeCollection;
  } });
  var listCollections_1 = require_listCollections();
  Object.defineProperty(exports, "listCollections", { enumerable: true, get: function() {
    return listCollections_1.listCollections;
  } });
});

// node_modules/@pinecone-database/pinecone/dist/data/indexHostSingleton.js
var require_indexHostSingleton = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexHostSingleton = undefined;
  var control_1 = require_control();
  var errors_1 = require_errors();
  var utils_1 = require_utils2();
  exports.IndexHostSingleton = function() {
    var _this = this;
    var hostUrls = {};
    var _describeIndex = function(config, indexName) {
      return __awaiter(_this, undefined, undefined, function() {
        var indexOperationsApi, describeResponse, host;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              indexOperationsApi = (0, control_1.indexOperationsBuilder)(config);
              return [4, (0, control_1.describeIndex)(indexOperationsApi)(indexName)];
            case 1:
              describeResponse = _a2.sent();
              host = describeResponse.host;
              if (!host) {
                throw new errors_1.PineconeUnableToResolveHostError("The HTTP call succeeded but the host URL could not be resolved. Please make sure the index exists and is in a ready state.");
              } else {
                return [2, host];
              }
              return [2];
          }
        });
      });
    };
    var _key = function(config, indexName) {
      return "".concat(config.apiKey, "-").concat(indexName);
    };
    var singleton = {
      getHostUrl: function(config, indexName) {
        return __awaiter(_this, undefined, undefined, function() {
          var cacheKey, hostUrl;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                cacheKey = _key(config, indexName);
                if (!(cacheKey in hostUrls))
                  return [3, 1];
                return [2, hostUrls[cacheKey]];
              case 1:
                return [4, _describeIndex(config, indexName)];
              case 2:
                hostUrl = _a2.sent();
                singleton._set(config, indexName, hostUrl);
                if (!hostUrls[cacheKey]) {
                  throw new errors_1.PineconeUnableToResolveHostError("Could not get host for index: ".concat(indexName, ". Call describeIndex('").concat(indexName, "') to check the current status."));
                }
                return [2, hostUrls[cacheKey]];
            }
          });
        });
      },
      _reset: function() {
        for (var _i = 0, _a2 = Object.keys(hostUrls);_i < _a2.length; _i++) {
          var key = _a2[_i];
          delete hostUrls[key];
        }
      },
      _set: function(config, indexName, hostUrl) {
        var normalizedHostUrl = (0, utils_1.normalizeUrl)(hostUrl);
        if (!normalizedHostUrl) {
          return;
        }
        var cacheKey = _key(config, indexName);
        hostUrls[cacheKey] = normalizedHostUrl;
      },
      _delete: function(config, indexName) {
        var cacheKey = _key(config, indexName);
        delete hostUrls[cacheKey];
      }
    };
    return singleton;
  }();
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/types.js
var require_types2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PineconeRecordsProperties = exports.PineconeConfigurationProperties = undefined;
  exports.PineconeConfigurationProperties = [
    "apiKey",
    "controllerHostUrl",
    "fetchApi",
    "additionalHeaders",
    "sourceTag"
  ];
  exports.PineconeRecordsProperties = [
    "id",
    "values",
    "sparseValues",
    "metadata"
  ];
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/upsert.js
var require_upsert = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpsertCommand = undefined;
  var types_1 = require_types2();
  var errors_1 = require_errors();
  var validateProperties_1 = require_validateProperties();
  var UpsertCommand = function() {
    function UpsertCommand2(apiProvider, namespace) {
      this.validator = function(records) {
        for (var _i = 0, records_1 = records;_i < records_1.length; _i++) {
          var record3 = records_1[_i];
          (0, validateProperties_1.ValidateProperties)(record3, types_1.PineconeRecordsProperties);
        }
        if (records.length === 0) {
          throw new errors_1.PineconeArgumentError("Must pass in at least 1 record to upsert.");
        }
        records.forEach(function(record4) {
          if (!record4.id) {
            throw new errors_1.PineconeArgumentError("Every record must include an `id` property in order to upsert.");
          }
          if (!record4.values) {
            throw new errors_1.PineconeArgumentError("Every record must include a `values` property in order to upsert.");
          }
        });
      };
      this.apiProvider = apiProvider;
      this.namespace = namespace;
    }
    UpsertCommand2.prototype.run = function(records) {
      return __awaiter(this, undefined, undefined, function() {
        var api;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.validator(records);
              return [4, this.apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.upsertVectors({
                upsertRequest: {
                  vectors: records,
                  namespace: this.namespace
                }
              })];
            case 2:
              _a2.sent();
              return [2];
          }
        });
      });
    };
    return UpsertCommand2;
  }();
  exports.UpsertCommand = UpsertCommand;
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/fetch.js
var require_fetch2 = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FetchCommand = undefined;
  var errors_1 = require_errors();
  var FetchCommand = function() {
    function FetchCommand2(apiProvider, namespace) {
      this.validator = function(options) {
        if (options.length === 0) {
          throw new errors_1.PineconeArgumentError("Must pass in at least 1 recordID.");
        }
      };
      this.apiProvider = apiProvider;
      this.namespace = namespace;
    }
    FetchCommand2.prototype.run = function(ids) {
      return __awaiter(this, undefined, undefined, function() {
        var api, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.validator(ids);
              return [4, this.apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.fetchVectors({
                ids,
                namespace: this.namespace
              })];
            case 2:
              response = _a2.sent();
              return [2, __assign({ records: response.vectors ? response.vectors : {}, namespace: response.namespace ? response.namespace : "" }, response.usage && { usage: response.usage })];
          }
        });
      });
    };
    return FetchCommand2;
  }();
  exports.FetchCommand = FetchCommand;
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/update.js
var require_update = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdateCommand = undefined;
  var errors_1 = require_errors();
  var validateProperties_1 = require_validateProperties();
  var UpdateOptionsProperties = [
    "id",
    "values",
    "sparseValues",
    "metadata"
  ];
  var UpdateCommand = function() {
    function UpdateCommand2(apiProvider, namespace) {
      this.validator = function(options) {
        if (options) {
          (0, validateProperties_1.ValidateProperties)(options, UpdateOptionsProperties);
        }
        if (options && !options.id) {
          throw new errors_1.PineconeArgumentError("You must enter a non-empty string for the `id` field in order to update a record.");
        }
      };
      this.apiProvider = apiProvider;
      this.namespace = namespace;
    }
    UpdateCommand2.prototype.run = function(options) {
      return __awaiter(this, undefined, undefined, function() {
        var requestOptions, api;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.validator(options);
              requestOptions = {
                id: options["id"],
                values: options["values"],
                sparseValues: options["sparseValues"],
                setMetadata: options["metadata"]
              };
              return [4, this.apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.updateVector({
                updateRequest: __assign(__assign({}, requestOptions), { namespace: this.namespace })
              })];
            case 2:
              _a2.sent();
              return [2];
          }
        });
      });
    };
    return UpdateCommand2;
  }();
  exports.UpdateCommand = UpdateCommand;
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/query.js
var require_query = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueryCommand = undefined;
  var errors_1 = require_errors();
  var validateProperties_1 = require_validateProperties();
  var QueryOptionsProperties = [
    "id",
    "vector",
    "sparseVector",
    "includeValues",
    "includeMetadata",
    "filter",
    "topK"
  ];
  var QueryCommand = function() {
    function QueryCommand2(apiProvider, namespace) {
      this.validator = function(options) {
        var _a2, _b;
        if (options) {
          (0, validateProperties_1.ValidateProperties)(options, QueryOptionsProperties);
        }
        if (!options) {
          throw new errors_1.PineconeArgumentError("You must enter a query configuration object to query the index.");
        }
        if (options && !options.topK) {
          throw new errors_1.PineconeArgumentError("You must enter an integer for the `topK` search results to be returned.");
        }
        if (options && options.topK && options.topK < 1) {
          throw new errors_1.PineconeArgumentError("`topK` property must be greater than 0.");
        }
        if (options && options.filter) {
          var keys = Object.keys(options.filter);
          if (keys.length === 0) {
            throw new errors_1.PineconeArgumentError("You must enter a `filter` object with at least one key-value pair.");
          }
        }
        if ("id" in options) {
          if (!options.id) {
            throw new errors_1.PineconeArgumentError("You must enter non-empty string for `id` to query by record ID.");
          }
        }
        if ("vector" in options) {
          if (options.vector.length === 0) {
            throw new errors_1.PineconeArgumentError("You must enter an array of `RecordValues` in order to query by vector values.");
          }
        }
        if ("sparseVector" in options) {
          if (((_a2 = options.sparseVector) === null || _a2 === undefined ? undefined : _a2.indices.length) === 0 || ((_b = options.sparseVector) === null || _b === undefined ? undefined : _b.values.length) === 0) {
            throw new errors_1.PineconeArgumentError("You must enter a `RecordSparseValues` object with `indices` and `values` properties in order to query by" + " sparse vector values.");
          }
        }
      };
      this.apiProvider = apiProvider;
      this.namespace = namespace;
    }
    QueryCommand2.prototype.run = function(query) {
      return __awaiter(this, undefined, undefined, function() {
        var api, results, matches;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.validator(query);
              return [4, this.apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.queryVectors({
                queryRequest: __assign(__assign({}, query), { namespace: this.namespace })
              })];
            case 2:
              results = _a2.sent();
              matches = results.matches ? results.matches : [];
              return [2, __assign({ matches, namespace: this.namespace }, results.usage && { usage: results.usage })];
          }
        });
      });
    };
    return QueryCommand2;
  }();
  exports.QueryCommand = QueryCommand;
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/deleteOne.js
var require_deleteOne = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteOne = undefined;
  var errors_1 = require_errors();
  var deleteOne = function(apiProvider, namespace) {
    var validator = function(options) {
      if (!options) {
        throw new errors_1.PineconeArgumentError("You must pass a non-empty string for `options` in order to delete a record.");
      }
    };
    return function(options) {
      return __awaiter(undefined, undefined, undefined, function() {
        var api;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              validator(options);
              return [4, apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.deleteVectors({ deleteRequest: { ids: [options], namespace } })];
            case 2:
              _a2.sent();
              return [2];
          }
        });
      });
    };
  };
  exports.deleteOne = deleteOne;
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/deleteMany.js
var require_deleteMany = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteMany = undefined;
  var errors_1 = require_errors();
  var deleteMany = function(apiProvider, namespace) {
    var FilterValidator = function(options) {
      for (var key in options) {
        if (!options[key]) {
          throw new errors_1.PineconeArgumentError("`filter` property cannot be empty for key ".concat(key));
        }
      }
    };
    var validator = function(options) {
      if (!Array.isArray(options)) {
        return FilterValidator(options);
      } else {
        if (options.length === 0) {
          throw new errors_1.PineconeArgumentError("Must pass in at least 1 record ID.");
        }
      }
    };
    return function(options) {
      return __awaiter(undefined, undefined, undefined, function() {
        var requestOptions, api;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              validator(options);
              requestOptions = {};
              if (Array.isArray(options)) {
                requestOptions.ids = options;
              } else {
                requestOptions.filter = options;
              }
              return [4, apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.deleteVectors({
                deleteRequest: __assign(__assign({}, requestOptions), { namespace })
              })];
            case 2:
              _a2.sent();
              return [2];
          }
        });
      });
    };
  };
  exports.deleteMany = deleteMany;
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/deleteAll.js
var require_deleteAll = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deleteAll = undefined;
  var deleteAll = function(apiProvider, namespace) {
    return function() {
      return __awaiter(undefined, undefined, undefined, function() {
        var api;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.deleteVectors({ deleteRequest: { deleteAll: true, namespace } })];
            case 2:
              _a2.sent();
              return [2];
          }
        });
      });
    };
  };
  exports.deleteAll = deleteAll;
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/describeIndexStats.js
var require_describeIndexStats = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.describeIndexStats = undefined;
  var errors_1 = require_errors();
  var validateProperties_1 = require_validateProperties();
  var describeIndexStats = function(apiProvider) {
    var validator = function(options) {
      if (options) {
        (0, validateProperties_1.ValidateProperties)(options, ["filter"]);
      }
      var map3 = options["filter"];
      for (var key in map3) {
        if (!map3[key]) {
          throw new errors_1.PineconeArgumentError("`filter` property cannot be empty for ".concat(key));
        }
      }
    };
    return function(options) {
      return __awaiter(undefined, undefined, undefined, function() {
        var api, results, mappedResult, key;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (options) {
                validator(options);
              }
              return [4, apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.describeIndexStats({
                describeIndexStatsRequest: __assign({}, options)
              })];
            case 2:
              results = _a2.sent();
              mappedResult = {
                namespaces: {},
                dimension: results.dimension,
                indexFullness: results.indexFullness,
                totalRecordCount: results.totalVectorCount
              };
              if (results.namespaces) {
                for (key in results.namespaces) {
                  mappedResult.namespaces[key] = {
                    recordCount: results.namespaces[key].vectorCount
                  };
                }
              }
              return [2, mappedResult];
          }
        });
      });
    };
  };
  exports.describeIndexStats = describeIndexStats;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/runtime.js
var require_runtime2 = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = undefined;
  exports.BASE_PATH = "https://unknown".replace(/\/+$/, "");
  var Configuration = function() {
    function Configuration2(configuration) {
      if (configuration === undefined) {
        configuration = {};
      }
      this.configuration = configuration;
    }
    Object.defineProperty(Configuration2.prototype, "config", {
      set: function(configuration) {
        this.configuration = configuration;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "basePath", {
      get: function() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "fetchApi", {
      get: function() {
        return this.configuration.fetchApi;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "middleware", {
      get: function() {
        return this.configuration.middleware || [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "queryParamsStringify", {
      get: function() {
        return this.configuration.queryParamsStringify || querystring;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "username", {
      get: function() {
        return this.configuration.username;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "password", {
      get: function() {
        return this.configuration.password;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "apiKey", {
      get: function() {
        var apiKey = this.configuration.apiKey;
        if (apiKey) {
          return typeof apiKey === "function" ? apiKey : function() {
            return apiKey;
          };
        }
        return;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "accessToken", {
      get: function() {
        var _this = this;
        var accessToken = this.configuration.accessToken;
        if (accessToken) {
          return typeof accessToken === "function" ? accessToken : function() {
            return __awaiter(_this, undefined, undefined, function() {
              return __generator(this, function(_a2) {
                return [2, accessToken];
              });
            });
          };
        }
        return;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "headers", {
      get: function() {
        return this.configuration.headers;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "credentials", {
      get: function() {
        return this.configuration.credentials;
      },
      enumerable: false,
      configurable: true
    });
    return Configuration2;
  }();
  exports.Configuration = Configuration;
  exports.DefaultConfig = new Configuration;
  var BaseAPI = function() {
    function BaseAPI2(configuration) {
      if (configuration === undefined) {
        configuration = exports.DefaultConfig;
      }
      var _this = this;
      this.configuration = configuration;
      this.fetchApi = function(url, init) {
        return __awaiter(_this, undefined, undefined, function() {
          var fetchParams, _i, _a2, middleware, response, e_1, _b, _c, middleware, _d, _e, middleware;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                fetchParams = { url, init };
                _i = 0, _a2 = this.middleware;
                _f.label = 1;
              case 1:
                if (!(_i < _a2.length))
                  return [3, 4];
                middleware = _a2[_i];
                if (!middleware.pre)
                  return [3, 3];
                return [4, middleware.pre(__assign({ fetch: this.fetchApi }, fetchParams))];
              case 2:
                fetchParams = _f.sent() || fetchParams;
                _f.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                response = undefined;
                _f.label = 5;
              case 5:
                _f.trys.push([5, 7, , 12]);
                return [4, (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init)];
              case 6:
                response = _f.sent();
                return [3, 12];
              case 7:
                e_1 = _f.sent();
                _b = 0, _c = this.middleware;
                _f.label = 8;
              case 8:
                if (!(_b < _c.length))
                  return [3, 11];
                middleware = _c[_b];
                if (!middleware.onError)
                  return [3, 10];
                return [4, middleware.onError({
                  fetch: this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  error: e_1,
                  response: response ? response.clone() : undefined
                })];
              case 9:
                response = _f.sent() || response;
                _f.label = 10;
              case 10:
                _b++;
                return [3, 8];
              case 11:
                if (response === undefined) {
                  if (e_1 instanceof Error) {
                    throw new FetchError(e_1, "The request failed and the interceptors did not return an alternative response");
                  } else {
                    throw e_1;
                  }
                }
                return [3, 12];
              case 12:
                _d = 0, _e = this.middleware;
                _f.label = 13;
              case 13:
                if (!(_d < _e.length))
                  return [3, 16];
                middleware = _e[_d];
                if (!middleware.post)
                  return [3, 15];
                return [4, middleware.post({
                  fetch: this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  response: response.clone()
                })];
              case 14:
                response = _f.sent() || response;
                _f.label = 15;
              case 15:
                _d++;
                return [3, 13];
              case 16:
                return [2, response];
            }
          });
        });
      };
      this.middleware = configuration.middleware;
    }
    BaseAPI2.prototype.withMiddleware = function() {
      var _a2;
      var middlewares = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        middlewares[_i] = arguments[_i];
      }
      var next = this.clone();
      next.middleware = (_a2 = next.middleware).concat.apply(_a2, middlewares);
      return next;
    };
    BaseAPI2.prototype.withPreMiddleware = function() {
      var preMiddlewares = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        preMiddlewares[_i] = arguments[_i];
      }
      var middlewares = preMiddlewares.map(function(pre) {
        return { pre };
      });
      return this.withMiddleware.apply(this, middlewares);
    };
    BaseAPI2.prototype.withPostMiddleware = function() {
      var postMiddlewares = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        postMiddlewares[_i] = arguments[_i];
      }
      var middlewares = postMiddlewares.map(function(post) {
        return { post };
      });
      return this.withMiddleware.apply(this, middlewares);
    };
    BaseAPI2.prototype.isJsonMime = function(mime) {
      if (!mime) {
        return false;
      }
      return BaseAPI2.jsonRegex.test(mime);
    };
    BaseAPI2.prototype.request = function(context, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var _a2, url, init, response;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, this.createFetchParams(context, initOverrides)];
            case 1:
              _a2 = _b.sent(), url = _a2.url, init = _a2.init;
              return [4, this.fetchApi(url, init)];
            case 2:
              response = _b.sent();
              if (response && (response.status >= 200 && response.status < 300)) {
                return [2, response];
              }
              throw new ResponseError(response, "Response returned an error code");
          }
        });
      });
    };
    BaseAPI2.prototype.createFetchParams = function(context, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var url, headers, initOverrideFn, initParams, overriddenInit, _a2, body, init;
        var _this = this;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              url = this.configuration.basePath + context.path;
              if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                url += "?" + this.configuration.queryParamsStringify(context.query);
              }
              headers = Object.assign({}, this.configuration.headers, context.headers);
              Object.keys(headers).forEach(function(key) {
                return headers[key] === undefined ? delete headers[key] : {};
              });
              initOverrideFn = typeof initOverrides === "function" ? initOverrides : function() {
                return __awaiter(_this, undefined, undefined, function() {
                  return __generator(this, function(_a3) {
                    return [2, initOverrides];
                  });
                });
              };
              initParams = {
                method: context.method,
                headers,
                body: context.body,
                credentials: this.configuration.credentials
              };
              _a2 = [__assign({}, initParams)];
              return [4, initOverrideFn({
                init: initParams,
                context
              })];
            case 1:
              overriddenInit = __assign.apply(undefined, _a2.concat([_b.sent()]));
              if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
                body = overriddenInit.body;
              } else if (this.isJsonMime(headers["Content-Type"])) {
                body = JSON.stringify(overriddenInit.body);
              } else {
                body = overriddenInit.body;
              }
              init = __assign(__assign({}, overriddenInit), { body });
              return [2, { url, init }];
          }
        });
      });
    };
    BaseAPI2.prototype.clone = function() {
      var constructor3 = this.constructor;
      var next = new constructor3(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    };
    BaseAPI2.jsonRegex = new RegExp("^(:?application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$", "i");
    return BaseAPI2;
  }();
  exports.BaseAPI = BaseAPI;
  function isBlob(value2) {
    return typeof Blob !== "undefined" && value2 instanceof Blob;
  }
  function isFormData(value2) {
    return typeof FormData !== "undefined" && value2 instanceof FormData;
  }
  var ResponseError = function(_super) {
    __extends(ResponseError2, _super);
    function ResponseError2(response, msg) {
      var _this = _super.call(this, msg) || this;
      _this.response = response;
      _this.name = "ResponseError";
      return _this;
    }
    return ResponseError2;
  }(Error);
  exports.ResponseError = ResponseError;
  var FetchError = function(_super) {
    __extends(FetchError2, _super);
    function FetchError2(cause, msg) {
      var _this = _super.call(this, msg) || this;
      _this.cause = cause;
      _this.name = "FetchError";
      return _this;
    }
    return FetchError2;
  }(Error);
  exports.FetchError = FetchError;
  var RequiredError = function(_super) {
    __extends(RequiredError2, _super);
    function RequiredError2(field, msg) {
      var _this = _super.call(this, msg) || this;
      _this.field = field;
      _this.name = "RequiredError";
      return _this;
    }
    return RequiredError2;
  }(Error);
  exports.RequiredError = RequiredError;
  exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
  };
  function exists(json, key) {
    var value2 = json[key];
    return value2 !== null && value2 !== undefined;
  }
  exports.exists = exists;
  function querystring(params, prefix) {
    if (prefix === undefined) {
      prefix = "";
    }
    return Object.keys(params).map(function(key) {
      return querystringSingleKey(key, params[key], prefix);
    }).filter(function(part) {
      return part.length > 0;
    }).join("&");
  }
  exports.querystring = querystring;
  function querystringSingleKey(key, value2, keyPrefix) {
    if (keyPrefix === undefined) {
      keyPrefix = "";
    }
    var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
    if (value2 instanceof Array) {
      var multiValue = value2.map(function(singleValue) {
        return encodeURIComponent(String(singleValue));
      }).join("&".concat(encodeURIComponent(fullKey), "="));
      return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
    }
    if (value2 instanceof Set) {
      var valueAsArray = Array.from(value2);
      return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value2 instanceof Date) {
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value2.toISOString()));
    }
    if (value2 instanceof Object) {
      return querystring(value2, fullKey);
    }
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value2)));
  }
  function mapValues(data, fn) {
    return Object.keys(data).reduce(function(acc, key) {
      var _a2;
      return __assign(__assign({}, acc), (_a2 = {}, _a2[key] = fn(data[key]), _a2));
    }, {});
  }
  exports.mapValues = mapValues;
  function canConsumeForm(consumes) {
    for (var _i = 0, consumes_1 = consumes;_i < consumes_1.length; _i++) {
      var consume = consumes_1[_i];
      if (consume.contentType === "multipart/form-data") {
        return true;
      }
    }
    return false;
  }
  exports.canConsumeForm = canConsumeForm;
  var JSONApiResponse = function() {
    function JSONApiResponse2(raw, transformer) {
      if (transformer === undefined) {
        transformer = function(jsonValue) {
          return jsonValue;
        };
      }
      this.raw = raw;
      this.transformer = transformer;
    }
    JSONApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a2 = this.transformer;
              return [4, this.raw.json()];
            case 1:
              return [2, _a2.apply(this, [_b.sent()])];
          }
        });
      });
    };
    return JSONApiResponse2;
  }();
  exports.JSONApiResponse = JSONApiResponse;
  var VoidApiResponse = function() {
    function VoidApiResponse2(raw) {
      this.raw = raw;
    }
    VoidApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          return [2, undefined];
        });
      });
    };
    return VoidApiResponse2;
  }();
  exports.VoidApiResponse = VoidApiResponse;
  var BlobApiResponse = function() {
    function BlobApiResponse2(raw) {
      this.raw = raw;
    }
    BlobApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.raw.blob()];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return BlobApiResponse2;
  }();
  exports.BlobApiResponse = BlobApiResponse;
  var TextApiResponse = function() {
    function TextApiResponse2(raw) {
      this.raw = raw;
    }
    TextApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.raw.text()];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return TextApiResponse2;
  }();
  exports.TextApiResponse = TextApiResponse;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/DeleteRequest.js
var require_DeleteRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DeleteRequestToJSON = exports.DeleteRequestFromJSONTyped = exports.DeleteRequestFromJSON = exports.instanceOfDeleteRequest = undefined;
  var runtime_1 = require_runtime2();
  function instanceOfDeleteRequest(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfDeleteRequest = instanceOfDeleteRequest;
  function DeleteRequestFromJSON(json) {
    return DeleteRequestFromJSONTyped(json, false);
  }
  exports.DeleteRequestFromJSON = DeleteRequestFromJSON;
  function DeleteRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      ids: !(0, runtime_1.exists)(json, "ids") ? undefined : json["ids"],
      deleteAll: !(0, runtime_1.exists)(json, "deleteAll") ? undefined : json["deleteAll"],
      namespace: !(0, runtime_1.exists)(json, "namespace") ? undefined : json["namespace"],
      filter: !(0, runtime_1.exists)(json, "filter") ? undefined : json["filter"]
    };
  }
  exports.DeleteRequestFromJSONTyped = DeleteRequestFromJSONTyped;
  function DeleteRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      ids: value2.ids,
      deleteAll: value2.deleteAll,
      namespace: value2.namespace,
      filter: value2.filter
    };
  }
  exports.DeleteRequestToJSON = DeleteRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/DescribeIndexStatsRequest.js
var require_DescribeIndexStatsRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DescribeIndexStatsRequestToJSON = exports.DescribeIndexStatsRequestFromJSONTyped = exports.DescribeIndexStatsRequestFromJSON = exports.instanceOfDescribeIndexStatsRequest = undefined;
  var runtime_1 = require_runtime2();
  function instanceOfDescribeIndexStatsRequest(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfDescribeIndexStatsRequest = instanceOfDescribeIndexStatsRequest;
  function DescribeIndexStatsRequestFromJSON(json) {
    return DescribeIndexStatsRequestFromJSONTyped(json, false);
  }
  exports.DescribeIndexStatsRequestFromJSON = DescribeIndexStatsRequestFromJSON;
  function DescribeIndexStatsRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      filter: !(0, runtime_1.exists)(json, "filter") ? undefined : json["filter"]
    };
  }
  exports.DescribeIndexStatsRequestFromJSONTyped = DescribeIndexStatsRequestFromJSONTyped;
  function DescribeIndexStatsRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      filter: value2.filter
    };
  }
  exports.DescribeIndexStatsRequestToJSON = DescribeIndexStatsRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Usage.js
var require_Usage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UsageToJSON = exports.UsageFromJSONTyped = exports.UsageFromJSON = exports.instanceOfUsage = undefined;
  var runtime_1 = require_runtime2();
  function instanceOfUsage(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfUsage = instanceOfUsage;
  function UsageFromJSON(json) {
    return UsageFromJSONTyped(json, false);
  }
  exports.UsageFromJSON = UsageFromJSON;
  function UsageFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      readUnits: !(0, runtime_1.exists)(json, "readUnits") ? undefined : json["readUnits"]
    };
  }
  exports.UsageFromJSONTyped = UsageFromJSONTyped;
  function UsageToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      readUnits: value2.readUnits
    };
  }
  exports.UsageToJSON = UsageToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SparseValues.js
var require_SparseValues = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SparseValuesToJSON = exports.SparseValuesFromJSONTyped = exports.SparseValuesFromJSON = exports.instanceOfSparseValues = undefined;
  function instanceOfSparseValues(value2) {
    var isInstance = true;
    isInstance = isInstance && "indices" in value2;
    isInstance = isInstance && "values" in value2;
    return isInstance;
  }
  exports.instanceOfSparseValues = instanceOfSparseValues;
  function SparseValuesFromJSON(json) {
    return SparseValuesFromJSONTyped(json, false);
  }
  exports.SparseValuesFromJSON = SparseValuesFromJSON;
  function SparseValuesFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      indices: json["indices"],
      values: json["values"]
    };
  }
  exports.SparseValuesFromJSONTyped = SparseValuesFromJSONTyped;
  function SparseValuesToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      indices: value2.indices,
      values: value2.values
    };
  }
  exports.SparseValuesToJSON = SparseValuesToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Vector.js
var require_Vector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VectorToJSON = exports.VectorFromJSONTyped = exports.VectorFromJSON = exports.instanceOfVector = undefined;
  var runtime_1 = require_runtime2();
  var SparseValues_1 = require_SparseValues();
  function instanceOfVector(value2) {
    var isInstance = true;
    isInstance = isInstance && "id" in value2;
    isInstance = isInstance && "values" in value2;
    return isInstance;
  }
  exports.instanceOfVector = instanceOfVector;
  function VectorFromJSON(json) {
    return VectorFromJSONTyped(json, false);
  }
  exports.VectorFromJSON = VectorFromJSON;
  function VectorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      id: json["id"],
      values: json["values"],
      sparseValues: !(0, runtime_1.exists)(json, "sparseValues") ? undefined : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
      metadata: !(0, runtime_1.exists)(json, "metadata") ? undefined : json["metadata"]
    };
  }
  exports.VectorFromJSONTyped = VectorFromJSONTyped;
  function VectorToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      id: value2.id,
      values: value2.values,
      sparseValues: (0, SparseValues_1.SparseValuesToJSON)(value2.sparseValues),
      metadata: value2.metadata
    };
  }
  exports.VectorToJSON = VectorToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/FetchResponse.js
var require_FetchResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FetchResponseToJSON = exports.FetchResponseFromJSONTyped = exports.FetchResponseFromJSON = exports.instanceOfFetchResponse = undefined;
  var runtime_1 = require_runtime2();
  var Usage_1 = require_Usage();
  var Vector_1 = require_Vector();
  function instanceOfFetchResponse(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfFetchResponse = instanceOfFetchResponse;
  function FetchResponseFromJSON(json) {
    return FetchResponseFromJSONTyped(json, false);
  }
  exports.FetchResponseFromJSON = FetchResponseFromJSON;
  function FetchResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      vectors: !(0, runtime_1.exists)(json, "vectors") ? undefined : (0, runtime_1.mapValues)(json["vectors"], Vector_1.VectorFromJSON),
      namespace: !(0, runtime_1.exists)(json, "namespace") ? undefined : json["namespace"],
      usage: !(0, runtime_1.exists)(json, "usage") ? undefined : (0, Usage_1.UsageFromJSON)(json["usage"])
    };
  }
  exports.FetchResponseFromJSONTyped = FetchResponseFromJSONTyped;
  function FetchResponseToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      vectors: value2.vectors === undefined ? undefined : (0, runtime_1.mapValues)(value2.vectors, Vector_1.VectorToJSON),
      namespace: value2.namespace,
      usage: (0, Usage_1.UsageToJSON)(value2.usage)
    };
  }
  exports.FetchResponseToJSON = FetchResponseToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ImportErrorMode.js
var require_ImportErrorMode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ImportErrorModeToJSON = exports.ImportErrorModeFromJSONTyped = exports.ImportErrorModeFromJSON = exports.instanceOfImportErrorMode = exports.ImportErrorModeOnErrorEnum = undefined;
  var runtime_1 = require_runtime2();
  exports.ImportErrorModeOnErrorEnum = {
    Abort: "abort",
    Continue: "continue"
  };
  function instanceOfImportErrorMode(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfImportErrorMode = instanceOfImportErrorMode;
  function ImportErrorModeFromJSON(json) {
    return ImportErrorModeFromJSONTyped(json, false);
  }
  exports.ImportErrorModeFromJSON = ImportErrorModeFromJSON;
  function ImportErrorModeFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      onError: !(0, runtime_1.exists)(json, "onError") ? undefined : json["onError"]
    };
  }
  exports.ImportErrorModeFromJSONTyped = ImportErrorModeFromJSONTyped;
  function ImportErrorModeToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      onError: value2.onError
    };
  }
  exports.ImportErrorModeToJSON = ImportErrorModeToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ImportModel.js
var require_ImportModel = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ImportModelToJSON = exports.ImportModelFromJSONTyped = exports.ImportModelFromJSON = exports.instanceOfImportModel = exports.ImportModelStatusEnum = undefined;
  var runtime_1 = require_runtime2();
  exports.ImportModelStatusEnum = {
    Pending: "Pending",
    InProgress: "InProgress",
    Failed: "Failed",
    Completed: "Completed",
    Cancelled: "Cancelled"
  };
  function instanceOfImportModel(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfImportModel = instanceOfImportModel;
  function ImportModelFromJSON(json) {
    return ImportModelFromJSONTyped(json, false);
  }
  exports.ImportModelFromJSON = ImportModelFromJSON;
  function ImportModelFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      id: !(0, runtime_1.exists)(json, "id") ? undefined : json["id"],
      uri: !(0, runtime_1.exists)(json, "uri") ? undefined : json["uri"],
      status: !(0, runtime_1.exists)(json, "status") ? undefined : json["status"],
      createdAt: !(0, runtime_1.exists)(json, "createdAt") ? undefined : new Date(json["createdAt"]),
      finishedAt: !(0, runtime_1.exists)(json, "finishedAt") ? undefined : new Date(json["finishedAt"]),
      percentComplete: !(0, runtime_1.exists)(json, "percentComplete") ? undefined : json["percentComplete"],
      recordsImported: !(0, runtime_1.exists)(json, "recordsImported") ? undefined : json["recordsImported"],
      error: !(0, runtime_1.exists)(json, "error") ? undefined : json["error"]
    };
  }
  exports.ImportModelFromJSONTyped = ImportModelFromJSONTyped;
  function ImportModelToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      id: value2.id,
      uri: value2.uri,
      status: value2.status,
      createdAt: value2.createdAt === undefined ? undefined : value2.createdAt.toISOString(),
      finishedAt: value2.finishedAt === undefined ? undefined : value2.finishedAt.toISOString(),
      percentComplete: value2.percentComplete,
      recordsImported: value2.recordsImported,
      error: value2.error
    };
  }
  exports.ImportModelToJSON = ImportModelToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/NamespaceSummary.js
var require_NamespaceSummary = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.NamespaceSummaryToJSON = exports.NamespaceSummaryFromJSONTyped = exports.NamespaceSummaryFromJSON = exports.instanceOfNamespaceSummary = undefined;
  var runtime_1 = require_runtime2();
  function instanceOfNamespaceSummary(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfNamespaceSummary = instanceOfNamespaceSummary;
  function NamespaceSummaryFromJSON(json) {
    return NamespaceSummaryFromJSONTyped(json, false);
  }
  exports.NamespaceSummaryFromJSON = NamespaceSummaryFromJSON;
  function NamespaceSummaryFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      vectorCount: !(0, runtime_1.exists)(json, "vectorCount") ? undefined : json["vectorCount"]
    };
  }
  exports.NamespaceSummaryFromJSONTyped = NamespaceSummaryFromJSONTyped;
  function NamespaceSummaryToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      vectorCount: value2.vectorCount
    };
  }
  exports.NamespaceSummaryToJSON = NamespaceSummaryToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/IndexDescription.js
var require_IndexDescription = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.IndexDescriptionToJSON = exports.IndexDescriptionFromJSONTyped = exports.IndexDescriptionFromJSON = exports.instanceOfIndexDescription = undefined;
  var runtime_1 = require_runtime2();
  var NamespaceSummary_1 = require_NamespaceSummary();
  function instanceOfIndexDescription(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfIndexDescription = instanceOfIndexDescription;
  function IndexDescriptionFromJSON(json) {
    return IndexDescriptionFromJSONTyped(json, false);
  }
  exports.IndexDescriptionFromJSON = IndexDescriptionFromJSON;
  function IndexDescriptionFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      namespaces: !(0, runtime_1.exists)(json, "namespaces") ? undefined : (0, runtime_1.mapValues)(json["namespaces"], NamespaceSummary_1.NamespaceSummaryFromJSON),
      dimension: !(0, runtime_1.exists)(json, "dimension") ? undefined : json["dimension"],
      indexFullness: !(0, runtime_1.exists)(json, "indexFullness") ? undefined : json["indexFullness"],
      totalVectorCount: !(0, runtime_1.exists)(json, "totalVectorCount") ? undefined : json["totalVectorCount"]
    };
  }
  exports.IndexDescriptionFromJSONTyped = IndexDescriptionFromJSONTyped;
  function IndexDescriptionToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      namespaces: value2.namespaces === undefined ? undefined : (0, runtime_1.mapValues)(value2.namespaces, NamespaceSummary_1.NamespaceSummaryToJSON),
      dimension: value2.dimension,
      indexFullness: value2.indexFullness,
      totalVectorCount: value2.totalVectorCount
    };
  }
  exports.IndexDescriptionToJSON = IndexDescriptionToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/Pagination.js
var require_Pagination = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.PaginationToJSON = exports.PaginationFromJSONTyped = exports.PaginationFromJSON = exports.instanceOfPagination = undefined;
  var runtime_1 = require_runtime2();
  function instanceOfPagination(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfPagination = instanceOfPagination;
  function PaginationFromJSON(json) {
    return PaginationFromJSONTyped(json, false);
  }
  exports.PaginationFromJSON = PaginationFromJSON;
  function PaginationFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      next: !(0, runtime_1.exists)(json, "next") ? undefined : json["next"]
    };
  }
  exports.PaginationFromJSONTyped = PaginationFromJSONTyped;
  function PaginationToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      next: value2.next
    };
  }
  exports.PaginationToJSON = PaginationToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListImportsResponse.js
var require_ListImportsResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListImportsResponseToJSON = exports.ListImportsResponseFromJSONTyped = exports.ListImportsResponseFromJSON = exports.instanceOfListImportsResponse = undefined;
  var runtime_1 = require_runtime2();
  var ImportModel_1 = require_ImportModel();
  var Pagination_1 = require_Pagination();
  function instanceOfListImportsResponse(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfListImportsResponse = instanceOfListImportsResponse;
  function ListImportsResponseFromJSON(json) {
    return ListImportsResponseFromJSONTyped(json, false);
  }
  exports.ListImportsResponseFromJSON = ListImportsResponseFromJSON;
  function ListImportsResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      data: !(0, runtime_1.exists)(json, "data") ? undefined : json["data"].map(ImportModel_1.ImportModelFromJSON),
      pagination: !(0, runtime_1.exists)(json, "pagination") ? undefined : (0, Pagination_1.PaginationFromJSON)(json["pagination"])
    };
  }
  exports.ListImportsResponseFromJSONTyped = ListImportsResponseFromJSONTyped;
  function ListImportsResponseToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      data: value2.data === undefined ? undefined : value2.data.map(ImportModel_1.ImportModelToJSON),
      pagination: (0, Pagination_1.PaginationToJSON)(value2.pagination)
    };
  }
  exports.ListImportsResponseToJSON = ListImportsResponseToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListItem.js
var require_ListItem = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListItemToJSON = exports.ListItemFromJSONTyped = exports.ListItemFromJSON = exports.instanceOfListItem = undefined;
  var runtime_1 = require_runtime2();
  function instanceOfListItem(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfListItem = instanceOfListItem;
  function ListItemFromJSON(json) {
    return ListItemFromJSONTyped(json, false);
  }
  exports.ListItemFromJSON = ListItemFromJSON;
  function ListItemFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      id: !(0, runtime_1.exists)(json, "id") ? undefined : json["id"]
    };
  }
  exports.ListItemFromJSONTyped = ListItemFromJSONTyped;
  function ListItemToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      id: value2.id
    };
  }
  exports.ListItemToJSON = ListItemToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ListResponse.js
var require_ListResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListResponseToJSON = exports.ListResponseFromJSONTyped = exports.ListResponseFromJSON = exports.instanceOfListResponse = undefined;
  var runtime_1 = require_runtime2();
  var ListItem_1 = require_ListItem();
  var Pagination_1 = require_Pagination();
  var Usage_1 = require_Usage();
  function instanceOfListResponse(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfListResponse = instanceOfListResponse;
  function ListResponseFromJSON(json) {
    return ListResponseFromJSONTyped(json, false);
  }
  exports.ListResponseFromJSON = ListResponseFromJSON;
  function ListResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      vectors: !(0, runtime_1.exists)(json, "vectors") ? undefined : json["vectors"].map(ListItem_1.ListItemFromJSON),
      pagination: !(0, runtime_1.exists)(json, "pagination") ? undefined : (0, Pagination_1.PaginationFromJSON)(json["pagination"]),
      namespace: !(0, runtime_1.exists)(json, "namespace") ? undefined : json["namespace"],
      usage: !(0, runtime_1.exists)(json, "usage") ? undefined : (0, Usage_1.UsageFromJSON)(json["usage"])
    };
  }
  exports.ListResponseFromJSONTyped = ListResponseFromJSONTyped;
  function ListResponseToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      vectors: value2.vectors === undefined ? undefined : value2.vectors.map(ListItem_1.ListItemToJSON),
      pagination: (0, Pagination_1.PaginationToJSON)(value2.pagination),
      namespace: value2.namespace,
      usage: (0, Usage_1.UsageToJSON)(value2.usage)
    };
  }
  exports.ListResponseToJSON = ListResponseToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ProtobufAny.js
var require_ProtobufAny = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProtobufAnyToJSON = exports.ProtobufAnyFromJSONTyped = exports.ProtobufAnyFromJSON = exports.instanceOfProtobufAny = undefined;
  var runtime_1 = require_runtime2();
  function instanceOfProtobufAny(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfProtobufAny = instanceOfProtobufAny;
  function ProtobufAnyFromJSON(json) {
    return ProtobufAnyFromJSONTyped(json, false);
  }
  exports.ProtobufAnyFromJSON = ProtobufAnyFromJSON;
  function ProtobufAnyFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      typeUrl: !(0, runtime_1.exists)(json, "typeUrl") ? undefined : json["typeUrl"],
      value: !(0, runtime_1.exists)(json, "value") ? undefined : json["value"]
    };
  }
  exports.ProtobufAnyFromJSONTyped = ProtobufAnyFromJSONTyped;
  function ProtobufAnyToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      typeUrl: value2.typeUrl,
      value: value2.value
    };
  }
  exports.ProtobufAnyToJSON = ProtobufAnyToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ProtobufNullValue.js
var require_ProtobufNullValue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ProtobufNullValueToJSON = exports.ProtobufNullValueFromJSONTyped = exports.ProtobufNullValueFromJSON = exports.ProtobufNullValue = undefined;
  exports.ProtobufNullValue = {
    NullValue: "NULL_VALUE"
  };
  function ProtobufNullValueFromJSON(json) {
    return ProtobufNullValueFromJSONTyped(json, false);
  }
  exports.ProtobufNullValueFromJSON = ProtobufNullValueFromJSON;
  function ProtobufNullValueFromJSONTyped(json, ignoreDiscriminator) {
    return json;
  }
  exports.ProtobufNullValueFromJSONTyped = ProtobufNullValueFromJSONTyped;
  function ProtobufNullValueToJSON(value2) {
    return value2;
  }
  exports.ProtobufNullValueToJSON = ProtobufNullValueToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/QueryVector.js
var require_QueryVector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueryVectorToJSON = exports.QueryVectorFromJSONTyped = exports.QueryVectorFromJSON = exports.instanceOfQueryVector = undefined;
  var runtime_1 = require_runtime2();
  var SparseValues_1 = require_SparseValues();
  function instanceOfQueryVector(value2) {
    var isInstance = true;
    isInstance = isInstance && "values" in value2;
    return isInstance;
  }
  exports.instanceOfQueryVector = instanceOfQueryVector;
  function QueryVectorFromJSON(json) {
    return QueryVectorFromJSONTyped(json, false);
  }
  exports.QueryVectorFromJSON = QueryVectorFromJSON;
  function QueryVectorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      values: json["values"],
      sparseValues: !(0, runtime_1.exists)(json, "sparseValues") ? undefined : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
      topK: !(0, runtime_1.exists)(json, "topK") ? undefined : json["topK"],
      namespace: !(0, runtime_1.exists)(json, "namespace") ? undefined : json["namespace"],
      filter: !(0, runtime_1.exists)(json, "filter") ? undefined : json["filter"]
    };
  }
  exports.QueryVectorFromJSONTyped = QueryVectorFromJSONTyped;
  function QueryVectorToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      values: value2.values,
      sparseValues: (0, SparseValues_1.SparseValuesToJSON)(value2.sparseValues),
      topK: value2.topK,
      namespace: value2.namespace,
      filter: value2.filter
    };
  }
  exports.QueryVectorToJSON = QueryVectorToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/QueryRequest.js
var require_QueryRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueryRequestToJSON = exports.QueryRequestFromJSONTyped = exports.QueryRequestFromJSON = exports.instanceOfQueryRequest = undefined;
  var runtime_1 = require_runtime2();
  var QueryVector_1 = require_QueryVector();
  var SparseValues_1 = require_SparseValues();
  function instanceOfQueryRequest(value2) {
    var isInstance = true;
    isInstance = isInstance && "topK" in value2;
    return isInstance;
  }
  exports.instanceOfQueryRequest = instanceOfQueryRequest;
  function QueryRequestFromJSON(json) {
    return QueryRequestFromJSONTyped(json, false);
  }
  exports.QueryRequestFromJSON = QueryRequestFromJSON;
  function QueryRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      namespace: !(0, runtime_1.exists)(json, "namespace") ? undefined : json["namespace"],
      topK: json["topK"],
      filter: !(0, runtime_1.exists)(json, "filter") ? undefined : json["filter"],
      includeValues: !(0, runtime_1.exists)(json, "includeValues") ? undefined : json["includeValues"],
      includeMetadata: !(0, runtime_1.exists)(json, "includeMetadata") ? undefined : json["includeMetadata"],
      queries: !(0, runtime_1.exists)(json, "queries") ? undefined : json["queries"].map(QueryVector_1.QueryVectorFromJSON),
      vector: !(0, runtime_1.exists)(json, "vector") ? undefined : json["vector"],
      sparseVector: !(0, runtime_1.exists)(json, "sparseVector") ? undefined : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseVector"]),
      id: !(0, runtime_1.exists)(json, "id") ? undefined : json["id"]
    };
  }
  exports.QueryRequestFromJSONTyped = QueryRequestFromJSONTyped;
  function QueryRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      namespace: value2.namespace,
      topK: value2.topK,
      filter: value2.filter,
      includeValues: value2.includeValues,
      includeMetadata: value2.includeMetadata,
      queries: value2.queries === undefined ? undefined : value2.queries.map(QueryVector_1.QueryVectorToJSON),
      vector: value2.vector,
      sparseVector: (0, SparseValues_1.SparseValuesToJSON)(value2.sparseVector),
      id: value2.id
    };
  }
  exports.QueryRequestToJSON = QueryRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/ScoredVector.js
var require_ScoredVector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ScoredVectorToJSON = exports.ScoredVectorFromJSONTyped = exports.ScoredVectorFromJSON = exports.instanceOfScoredVector = undefined;
  var runtime_1 = require_runtime2();
  var SparseValues_1 = require_SparseValues();
  function instanceOfScoredVector(value2) {
    var isInstance = true;
    isInstance = isInstance && "id" in value2;
    return isInstance;
  }
  exports.instanceOfScoredVector = instanceOfScoredVector;
  function ScoredVectorFromJSON(json) {
    return ScoredVectorFromJSONTyped(json, false);
  }
  exports.ScoredVectorFromJSON = ScoredVectorFromJSON;
  function ScoredVectorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      id: json["id"],
      score: !(0, runtime_1.exists)(json, "score") ? undefined : json["score"],
      values: !(0, runtime_1.exists)(json, "values") ? undefined : json["values"],
      sparseValues: !(0, runtime_1.exists)(json, "sparseValues") ? undefined : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
      metadata: !(0, runtime_1.exists)(json, "metadata") ? undefined : json["metadata"]
    };
  }
  exports.ScoredVectorFromJSONTyped = ScoredVectorFromJSONTyped;
  function ScoredVectorToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      id: value2.id,
      score: value2.score,
      values: value2.values,
      sparseValues: (0, SparseValues_1.SparseValuesToJSON)(value2.sparseValues),
      metadata: value2.metadata
    };
  }
  exports.ScoredVectorToJSON = ScoredVectorToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/SingleQueryResults.js
var require_SingleQueryResults = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SingleQueryResultsToJSON = exports.SingleQueryResultsFromJSONTyped = exports.SingleQueryResultsFromJSON = exports.instanceOfSingleQueryResults = undefined;
  var runtime_1 = require_runtime2();
  var ScoredVector_1 = require_ScoredVector();
  function instanceOfSingleQueryResults(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfSingleQueryResults = instanceOfSingleQueryResults;
  function SingleQueryResultsFromJSON(json) {
    return SingleQueryResultsFromJSONTyped(json, false);
  }
  exports.SingleQueryResultsFromJSON = SingleQueryResultsFromJSON;
  function SingleQueryResultsFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      matches: !(0, runtime_1.exists)(json, "matches") ? undefined : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
      namespace: !(0, runtime_1.exists)(json, "namespace") ? undefined : json["namespace"]
    };
  }
  exports.SingleQueryResultsFromJSONTyped = SingleQueryResultsFromJSONTyped;
  function SingleQueryResultsToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      matches: value2.matches === undefined ? undefined : value2.matches.map(ScoredVector_1.ScoredVectorToJSON),
      namespace: value2.namespace
    };
  }
  exports.SingleQueryResultsToJSON = SingleQueryResultsToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/QueryResponse.js
var require_QueryResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.QueryResponseToJSON = exports.QueryResponseFromJSONTyped = exports.QueryResponseFromJSON = exports.instanceOfQueryResponse = undefined;
  var runtime_1 = require_runtime2();
  var ScoredVector_1 = require_ScoredVector();
  var SingleQueryResults_1 = require_SingleQueryResults();
  var Usage_1 = require_Usage();
  function instanceOfQueryResponse(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfQueryResponse = instanceOfQueryResponse;
  function QueryResponseFromJSON(json) {
    return QueryResponseFromJSONTyped(json, false);
  }
  exports.QueryResponseFromJSON = QueryResponseFromJSON;
  function QueryResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      results: !(0, runtime_1.exists)(json, "results") ? undefined : json["results"].map(SingleQueryResults_1.SingleQueryResultsFromJSON),
      matches: !(0, runtime_1.exists)(json, "matches") ? undefined : json["matches"].map(ScoredVector_1.ScoredVectorFromJSON),
      namespace: !(0, runtime_1.exists)(json, "namespace") ? undefined : json["namespace"],
      usage: !(0, runtime_1.exists)(json, "usage") ? undefined : (0, Usage_1.UsageFromJSON)(json["usage"])
    };
  }
  exports.QueryResponseFromJSONTyped = QueryResponseFromJSONTyped;
  function QueryResponseToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      results: value2.results === undefined ? undefined : value2.results.map(SingleQueryResults_1.SingleQueryResultsToJSON),
      matches: value2.matches === undefined ? undefined : value2.matches.map(ScoredVector_1.ScoredVectorToJSON),
      namespace: value2.namespace,
      usage: (0, Usage_1.UsageToJSON)(value2.usage)
    };
  }
  exports.QueryResponseToJSON = QueryResponseToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/RpcStatus.js
var require_RpcStatus = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RpcStatusToJSON = exports.RpcStatusFromJSONTyped = exports.RpcStatusFromJSON = exports.instanceOfRpcStatus = undefined;
  var runtime_1 = require_runtime2();
  var ProtobufAny_1 = require_ProtobufAny();
  function instanceOfRpcStatus(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfRpcStatus = instanceOfRpcStatus;
  function RpcStatusFromJSON(json) {
    return RpcStatusFromJSONTyped(json, false);
  }
  exports.RpcStatusFromJSON = RpcStatusFromJSON;
  function RpcStatusFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      code: !(0, runtime_1.exists)(json, "code") ? undefined : json["code"],
      message: !(0, runtime_1.exists)(json, "message") ? undefined : json["message"],
      details: !(0, runtime_1.exists)(json, "details") ? undefined : json["details"].map(ProtobufAny_1.ProtobufAnyFromJSON)
    };
  }
  exports.RpcStatusFromJSONTyped = RpcStatusFromJSONTyped;
  function RpcStatusToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      code: value2.code,
      message: value2.message,
      details: value2.details === undefined ? undefined : value2.details.map(ProtobufAny_1.ProtobufAnyToJSON)
    };
  }
  exports.RpcStatusToJSON = RpcStatusToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/StartImportRequest.js
var require_StartImportRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StartImportRequestToJSON = exports.StartImportRequestFromJSONTyped = exports.StartImportRequestFromJSON = exports.instanceOfStartImportRequest = undefined;
  var runtime_1 = require_runtime2();
  var ImportErrorMode_1 = require_ImportErrorMode();
  function instanceOfStartImportRequest(value2) {
    var isInstance = true;
    isInstance = isInstance && "uri" in value2;
    return isInstance;
  }
  exports.instanceOfStartImportRequest = instanceOfStartImportRequest;
  function StartImportRequestFromJSON(json) {
    return StartImportRequestFromJSONTyped(json, false);
  }
  exports.StartImportRequestFromJSON = StartImportRequestFromJSON;
  function StartImportRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      integrationId: !(0, runtime_1.exists)(json, "integrationId") ? undefined : json["integrationId"],
      uri: json["uri"],
      errorMode: !(0, runtime_1.exists)(json, "errorMode") ? undefined : (0, ImportErrorMode_1.ImportErrorModeFromJSON)(json["errorMode"])
    };
  }
  exports.StartImportRequestFromJSONTyped = StartImportRequestFromJSONTyped;
  function StartImportRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      integrationId: value2.integrationId,
      uri: value2.uri,
      errorMode: (0, ImportErrorMode_1.ImportErrorModeToJSON)(value2.errorMode)
    };
  }
  exports.StartImportRequestToJSON = StartImportRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/StartImportResponse.js
var require_StartImportResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StartImportResponseToJSON = exports.StartImportResponseFromJSONTyped = exports.StartImportResponseFromJSON = exports.instanceOfStartImportResponse = undefined;
  var runtime_1 = require_runtime2();
  function instanceOfStartImportResponse(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfStartImportResponse = instanceOfStartImportResponse;
  function StartImportResponseFromJSON(json) {
    return StartImportResponseFromJSONTyped(json, false);
  }
  exports.StartImportResponseFromJSON = StartImportResponseFromJSON;
  function StartImportResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      id: !(0, runtime_1.exists)(json, "id") ? undefined : json["id"]
    };
  }
  exports.StartImportResponseFromJSONTyped = StartImportResponseFromJSONTyped;
  function StartImportResponseToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      id: value2.id
    };
  }
  exports.StartImportResponseToJSON = StartImportResponseToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpdateRequest.js
var require_UpdateRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpdateRequestToJSON = exports.UpdateRequestFromJSONTyped = exports.UpdateRequestFromJSON = exports.instanceOfUpdateRequest = undefined;
  var runtime_1 = require_runtime2();
  var SparseValues_1 = require_SparseValues();
  function instanceOfUpdateRequest(value2) {
    var isInstance = true;
    isInstance = isInstance && "id" in value2;
    return isInstance;
  }
  exports.instanceOfUpdateRequest = instanceOfUpdateRequest;
  function UpdateRequestFromJSON(json) {
    return UpdateRequestFromJSONTyped(json, false);
  }
  exports.UpdateRequestFromJSON = UpdateRequestFromJSON;
  function UpdateRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      id: json["id"],
      values: !(0, runtime_1.exists)(json, "values") ? undefined : json["values"],
      sparseValues: !(0, runtime_1.exists)(json, "sparseValues") ? undefined : (0, SparseValues_1.SparseValuesFromJSON)(json["sparseValues"]),
      setMetadata: !(0, runtime_1.exists)(json, "setMetadata") ? undefined : json["setMetadata"],
      namespace: !(0, runtime_1.exists)(json, "namespace") ? undefined : json["namespace"]
    };
  }
  exports.UpdateRequestFromJSONTyped = UpdateRequestFromJSONTyped;
  function UpdateRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      id: value2.id,
      values: value2.values,
      sparseValues: (0, SparseValues_1.SparseValuesToJSON)(value2.sparseValues),
      setMetadata: value2.setMetadata,
      namespace: value2.namespace
    };
  }
  exports.UpdateRequestToJSON = UpdateRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpsertRequest.js
var require_UpsertRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpsertRequestToJSON = exports.UpsertRequestFromJSONTyped = exports.UpsertRequestFromJSON = exports.instanceOfUpsertRequest = undefined;
  var runtime_1 = require_runtime2();
  var Vector_1 = require_Vector();
  function instanceOfUpsertRequest(value2) {
    var isInstance = true;
    isInstance = isInstance && "vectors" in value2;
    return isInstance;
  }
  exports.instanceOfUpsertRequest = instanceOfUpsertRequest;
  function UpsertRequestFromJSON(json) {
    return UpsertRequestFromJSONTyped(json, false);
  }
  exports.UpsertRequestFromJSON = UpsertRequestFromJSON;
  function UpsertRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      vectors: json["vectors"].map(Vector_1.VectorFromJSON),
      namespace: !(0, runtime_1.exists)(json, "namespace") ? undefined : json["namespace"]
    };
  }
  exports.UpsertRequestFromJSONTyped = UpsertRequestFromJSONTyped;
  function UpsertRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      vectors: value2.vectors.map(Vector_1.VectorToJSON),
      namespace: value2.namespace
    };
  }
  exports.UpsertRequestToJSON = UpsertRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/UpsertResponse.js
var require_UpsertResponse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.UpsertResponseToJSON = exports.UpsertResponseFromJSONTyped = exports.UpsertResponseFromJSON = exports.instanceOfUpsertResponse = undefined;
  var runtime_1 = require_runtime2();
  function instanceOfUpsertResponse(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfUpsertResponse = instanceOfUpsertResponse;
  function UpsertResponseFromJSON(json) {
    return UpsertResponseFromJSONTyped(json, false);
  }
  exports.UpsertResponseFromJSON = UpsertResponseFromJSON;
  function UpsertResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      upsertedCount: !(0, runtime_1.exists)(json, "upsertedCount") ? undefined : json["upsertedCount"]
    };
  }
  exports.UpsertResponseFromJSONTyped = UpsertResponseFromJSONTyped;
  function UpsertResponseToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      upsertedCount: value2.upsertedCount
    };
  }
  exports.UpsertResponseToJSON = UpsertResponseToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/models/index.js
var require_models2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_DeleteRequest(), exports);
  __exportStar(require_DescribeIndexStatsRequest(), exports);
  __exportStar(require_FetchResponse(), exports);
  __exportStar(require_ImportErrorMode(), exports);
  __exportStar(require_ImportModel(), exports);
  __exportStar(require_IndexDescription(), exports);
  __exportStar(require_ListImportsResponse(), exports);
  __exportStar(require_ListItem(), exports);
  __exportStar(require_ListResponse(), exports);
  __exportStar(require_NamespaceSummary(), exports);
  __exportStar(require_Pagination(), exports);
  __exportStar(require_ProtobufAny(), exports);
  __exportStar(require_ProtobufNullValue(), exports);
  __exportStar(require_QueryRequest(), exports);
  __exportStar(require_QueryResponse(), exports);
  __exportStar(require_QueryVector(), exports);
  __exportStar(require_RpcStatus(), exports);
  __exportStar(require_ScoredVector(), exports);
  __exportStar(require_SingleQueryResults(), exports);
  __exportStar(require_SparseValues(), exports);
  __exportStar(require_StartImportRequest(), exports);
  __exportStar(require_StartImportResponse(), exports);
  __exportStar(require_UpdateRequest(), exports);
  __exportStar(require_UpsertRequest(), exports);
  __exportStar(require_UpsertResponse(), exports);
  __exportStar(require_Usage(), exports);
  __exportStar(require_Vector(), exports);
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/BulkOperationsApi.js
var require_BulkOperationsApi = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BulkOperationsApi = undefined;
  var runtime = __importStar(require_runtime2());
  var index_1 = require_models2();
  var BulkOperationsApi = function(_super) {
    __extends(BulkOperationsApi2, _super);
    function BulkOperationsApi2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    BulkOperationsApi2.prototype.cancelBulkImportRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new runtime.RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling cancelBulkImport.");
              }
              queryParameters = {};
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/bulk/imports/{id}".replace("{".concat("id", "}"), encodeURIComponent(String(requestParameters.id))),
                method: "DELETE",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response)];
          }
        });
      });
    };
    BulkOperationsApi2.prototype.cancelBulkImport = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.cancelBulkImportRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    BulkOperationsApi2.prototype.describeBulkImportRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.id === null || requestParameters.id === undefined) {
                throw new runtime.RequiredError("id", "Required parameter requestParameters.id was null or undefined when calling describeBulkImport.");
              }
              queryParameters = {};
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/bulk/imports/{id}".replace("{".concat("id", "}"), encodeURIComponent(String(requestParameters.id))),
                method: "GET",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.ImportModelFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    BulkOperationsApi2.prototype.describeBulkImport = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.describeBulkImportRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    BulkOperationsApi2.prototype.listBulkImportsRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              queryParameters = {};
              if (requestParameters.limit !== undefined) {
                queryParameters["limit"] = requestParameters.limit;
              }
              if (requestParameters.paginationToken !== undefined) {
                queryParameters["paginationToken"] = requestParameters.paginationToken;
              }
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/bulk/imports",
                method: "GET",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.ListImportsResponseFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    BulkOperationsApi2.prototype.listBulkImports = function(requestParameters, initOverrides) {
      if (requestParameters === undefined) {
        requestParameters = {};
      }
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.listBulkImportsRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    BulkOperationsApi2.prototype.startBulkImportRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.startImportRequest === null || requestParameters.startImportRequest === undefined) {
                throw new runtime.RequiredError("startImportRequest", "Required parameter requestParameters.startImportRequest was null or undefined when calling startBulkImport.");
              }
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/bulk/imports",
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.StartImportRequestToJSON)(requestParameters.startImportRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.StartImportResponseFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    BulkOperationsApi2.prototype.startBulkImport = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.startBulkImportRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return BulkOperationsApi2;
  }(runtime.BaseAPI);
  exports.BulkOperationsApi = BulkOperationsApi;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/VectorOperationsApi.js
var require_VectorOperationsApi = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VectorOperationsApi = undefined;
  var runtime = __importStar(require_runtime2());
  var index_1 = require_models2();
  var VectorOperationsApi = function(_super) {
    __extends(VectorOperationsApi2, _super);
    function VectorOperationsApi2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VectorOperationsApi2.prototype.deleteVectorsRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.deleteRequest === null || requestParameters.deleteRequest === undefined) {
                throw new runtime.RequiredError("deleteRequest", "Required parameter requestParameters.deleteRequest was null or undefined when calling deleteVectors.");
              }
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/vectors/delete",
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.DeleteRequestToJSON)(requestParameters.deleteRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response)];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.deleteVectors = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.deleteVectorsRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.describeIndexStatsRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.describeIndexStatsRequest === null || requestParameters.describeIndexStatsRequest === undefined) {
                throw new runtime.RequiredError("describeIndexStatsRequest", "Required parameter requestParameters.describeIndexStatsRequest was null or undefined when calling describeIndexStats.");
              }
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/describe_index_stats",
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.DescribeIndexStatsRequestToJSON)(requestParameters.describeIndexStatsRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.IndexDescriptionFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.describeIndexStats = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.describeIndexStatsRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.fetchVectorsRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.ids === null || requestParameters.ids === undefined) {
                throw new runtime.RequiredError("ids", "Required parameter requestParameters.ids was null or undefined when calling fetchVectors.");
              }
              queryParameters = {};
              if (requestParameters.ids) {
                queryParameters["ids"] = requestParameters.ids;
              }
              if (requestParameters.namespace !== undefined) {
                queryParameters["namespace"] = requestParameters.namespace;
              }
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/vectors/fetch",
                method: "GET",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.FetchResponseFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.fetchVectors = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.fetchVectorsRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.listVectorsRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              queryParameters = {};
              if (requestParameters.prefix !== undefined) {
                queryParameters["prefix"] = requestParameters.prefix;
              }
              if (requestParameters.limit !== undefined) {
                queryParameters["limit"] = requestParameters.limit;
              }
              if (requestParameters.paginationToken !== undefined) {
                queryParameters["paginationToken"] = requestParameters.paginationToken;
              }
              if (requestParameters.namespace !== undefined) {
                queryParameters["namespace"] = requestParameters.namespace;
              }
              headerParameters = {};
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/vectors/list",
                method: "GET",
                headers: headerParameters,
                query: queryParameters
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.ListResponseFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.listVectors = function(requestParameters, initOverrides) {
      if (requestParameters === undefined) {
        requestParameters = {};
      }
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.listVectorsRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.queryVectorsRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.queryRequest === null || requestParameters.queryRequest === undefined) {
                throw new runtime.RequiredError("queryRequest", "Required parameter requestParameters.queryRequest was null or undefined when calling queryVectors.");
              }
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/query",
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.QueryRequestToJSON)(requestParameters.queryRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.QueryResponseFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.queryVectors = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.queryVectorsRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.updateVectorRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.updateRequest === null || requestParameters.updateRequest === undefined) {
                throw new runtime.RequiredError("updateRequest", "Required parameter requestParameters.updateRequest was null or undefined when calling updateVector.");
              }
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/vectors/update",
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.UpdateRequestToJSON)(requestParameters.updateRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response)];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.updateVector = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.updateVectorRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.upsertVectorsRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (requestParameters.upsertRequest === null || requestParameters.upsertRequest === undefined) {
                throw new runtime.RequiredError("upsertRequest", "Required parameter requestParameters.upsertRequest was null or undefined when calling upsertVectors.");
              }
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/vectors/upsert",
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.UpsertRequestToJSON)(requestParameters.upsertRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.UpsertResponseFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    VectorOperationsApi2.prototype.upsertVectors = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.upsertVectorsRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return VectorOperationsApi2;
  }(runtime.BaseAPI);
  exports.VectorOperationsApi = VectorOperationsApi;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/apis/index.js
var require_apis2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_BulkOperationsApi(), exports);
  __exportStar(require_VectorOperationsApi(), exports);
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/api_version.js
var require_api_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.X_PINECONE_API_VERSION = undefined;
  exports.X_PINECONE_API_VERSION = "2024-10";
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/db_data/index.js
var require_db_data = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_runtime2(), exports);
  __exportStar(require_apis2(), exports);
  __exportStar(require_models2(), exports);
  __exportStar(require_api_version2(), exports);
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/vectorOperationsProvider.js
var require_vectorOperationsProvider = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.VectorOperationsProvider = undefined;
  var db_data_1 = require_db_data();
  var utils_1 = require_utils2();
  var indexHostSingleton_1 = require_indexHostSingleton();
  var middleware_1 = require_middleware();
  var VectorOperationsProvider = function() {
    function VectorOperationsProvider2(config, indexName, indexHostUrl, additionalHeaders) {
      this.config = config;
      this.indexName = indexName;
      this.indexHostUrl = (0, utils_1.normalizeUrl)(indexHostUrl);
      this.additionalHeaders = additionalHeaders;
    }
    VectorOperationsProvider2.prototype.provide = function() {
      return __awaiter(this, undefined, undefined, function() {
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (this.vectorOperations) {
                return [2, this.vectorOperations];
              }
              if (!this.indexHostUrl)
                return [3, 1];
              this.vectorOperations = this.buildDataOperationsConfig();
              return [3, 3];
            case 1:
              _a2 = this;
              return [4, indexHostSingleton_1.IndexHostSingleton.getHostUrl(this.config, this.indexName)];
            case 2:
              _a2.indexHostUrl = _b.sent();
              this.vectorOperations = this.buildDataOperationsConfig();
              _b.label = 3;
            case 3:
              return [2, this.vectorOperations];
          }
        });
      });
    };
    VectorOperationsProvider2.prototype.buildDataOperationsConfig = function() {
      var headers = this.additionalHeaders || null;
      var indexConfigurationParameters = {
        basePath: this.indexHostUrl,
        apiKey: this.config.apiKey,
        queryParamsStringify: utils_1.queryParamsStringify,
        headers: __assign({ "User-Agent": (0, utils_1.buildUserAgent)(this.config), "X-Pinecone-Api-Version": db_data_1.X_PINECONE_API_VERSION }, headers),
        fetchApi: (0, utils_1.getFetch)(this.config),
        middleware: middleware_1.middleware
      };
      var indexConfiguration = new db_data_1.Configuration(indexConfigurationParameters);
      return new db_data_1.VectorOperationsApi(indexConfiguration);
    };
    return VectorOperationsProvider2;
  }();
  exports.VectorOperationsProvider = VectorOperationsProvider;
});

// node_modules/@pinecone-database/pinecone/dist/data/vectors/list.js
var require_list = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.listPaginated = undefined;
  var validateProperties_1 = require_validateProperties();
  var ListOptionsProperties = [
    "prefix",
    "limit",
    "paginationToken"
  ];
  var listPaginated = function(apiProvider, namespace) {
    var validator = function(options) {
      if (options) {
        (0, validateProperties_1.ValidateProperties)(options, ListOptionsProperties);
      }
      if (options.limit && options.limit < 0) {
        throw new Error("`limit` property must be greater than 0");
      }
    };
    return function(options) {
      return __awaiter(undefined, undefined, undefined, function() {
        var listRequest, api;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (options) {
                validator(options);
              }
              listRequest = __assign(__assign({}, options), { namespace });
              return [4, apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.listVectors(listRequest)];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
  };
  exports.listPaginated = listPaginated;
});

// node_modules/@pinecone-database/pinecone/dist/data/bulk/startImport.js
var require_startImport = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.StartImportCommand = undefined;
  var db_data_1 = require_db_data();
  var errors_1 = require_errors();
  var StartImportCommand = function() {
    function StartImportCommand2(apiProvider, namespace) {
      this.apiProvider = apiProvider;
      this.namespace = namespace;
    }
    StartImportCommand2.prototype.run = function(uri2, errorMode, integrationId) {
      return __awaiter(this, undefined, undefined, function() {
        var error4, req, api;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!uri2) {
                throw new errors_1.PineconeArgumentError("`uri` field is required and must start with the scheme of a supported storage provider.");
              }
              error4 = db_data_1.ImportErrorModeOnErrorEnum.Continue;
              if (errorMode) {
                if (errorMode.toLowerCase() !== "continue" && errorMode.toLowerCase() !== "abort") {
                  throw new errors_1.PineconeArgumentError('`errorMode` must be one of "Continue" or "Abort"');
                }
                if ((errorMode === null || errorMode === undefined ? undefined : errorMode.toLowerCase()) == "abort") {
                  error4 = db_data_1.ImportErrorModeOnErrorEnum.Abort;
                }
              }
              req = {
                startImportRequest: {
                  uri: uri2,
                  errorMode: { onError: error4 },
                  integrationId
                }
              };
              return [4, this.apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.startBulkImport(req)];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return StartImportCommand2;
  }();
  exports.StartImportCommand = StartImportCommand;
});

// node_modules/@pinecone-database/pinecone/dist/data/bulk/listImports.js
var require_listImports = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ListImportsCommand = undefined;
  var ListImportsCommand = function() {
    function ListImportsCommand2(apiProvider, namespace) {
      this.apiProvider = apiProvider;
      this.namespace = namespace;
    }
    ListImportsCommand2.prototype.run = function(limit, paginationToken) {
      return __awaiter(this, undefined, undefined, function() {
        var req, api;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              req = {
                limit,
                paginationToken
              };
              return [4, this.apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.listBulkImports(req)];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return ListImportsCommand2;
  }();
  exports.ListImportsCommand = ListImportsCommand;
});

// node_modules/@pinecone-database/pinecone/dist/data/bulk/describeImport.js
var require_describeImport = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DescribeImportCommand = undefined;
  var DescribeImportCommand = function() {
    function DescribeImportCommand2(apiProvider, namespace) {
      this.apiProvider = apiProvider;
      this.namespace = namespace;
    }
    DescribeImportCommand2.prototype.run = function(id) {
      return __awaiter(this, undefined, undefined, function() {
        var req, api;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              req = {
                id
              };
              return [4, this.apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.describeBulkImport(req)];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return DescribeImportCommand2;
  }();
  exports.DescribeImportCommand = DescribeImportCommand;
});

// node_modules/@pinecone-database/pinecone/dist/data/bulk/cancelImport.js
var require_cancelImport = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.CancelImportCommand = undefined;
  var CancelImportCommand = function() {
    function CancelImportCommand2(apiProvider, namespace) {
      this.apiProvider = apiProvider;
      this.namespace = namespace;
    }
    CancelImportCommand2.prototype.run = function(id) {
      return __awaiter(this, undefined, undefined, function() {
        var req, api;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              req = {
                id
              };
              return [4, this.apiProvider.provide()];
            case 1:
              api = _a2.sent();
              return [4, api.cancelBulkImport(req)];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return CancelImportCommand2;
  }();
  exports.CancelImportCommand = CancelImportCommand;
});

// node_modules/@pinecone-database/pinecone/dist/data/bulk/bulkOperationsProvider.js
var require_bulkOperationsProvider = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BulkOperationsProvider = undefined;
  var db_data_1 = require_db_data();
  var utils_1 = require_utils2();
  var indexHostSingleton_1 = require_indexHostSingleton();
  var middleware_1 = require_middleware();
  var BulkOperationsProvider = function() {
    function BulkOperationsProvider2(config, indexName, indexHostUrl, additionalHeaders) {
      this.config = config;
      this.indexName = indexName;
      this.indexHostUrl = (0, utils_1.normalizeUrl)(indexHostUrl);
      this.additionalHeaders = additionalHeaders;
    }
    BulkOperationsProvider2.prototype.provide = function() {
      return __awaiter(this, undefined, undefined, function() {
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (this.bulkOperations) {
                return [2, this.bulkOperations];
              }
              if (!this.indexHostUrl)
                return [3, 1];
              this.bulkOperations = this.buildBulkOperationsConfig();
              return [3, 3];
            case 1:
              _a2 = this;
              return [4, indexHostSingleton_1.IndexHostSingleton.getHostUrl(this.config, this.indexName)];
            case 2:
              _a2.indexHostUrl = _b.sent();
              this.bulkOperations = this.buildBulkOperationsConfig();
              _b.label = 3;
            case 3:
              return [2, this.bulkOperations];
          }
        });
      });
    };
    BulkOperationsProvider2.prototype.buildBulkOperationsConfig = function() {
      var headers = this.additionalHeaders || null;
      var indexConfigurationParameters = {
        basePath: this.indexHostUrl,
        apiKey: this.config.apiKey,
        queryParamsStringify: utils_1.queryParamsStringify,
        headers: __assign({ "User-Agent": (0, utils_1.buildUserAgent)(this.config), "X-Pinecone-Api-Version": db_data_1.X_PINECONE_API_VERSION }, headers),
        fetchApi: (0, utils_1.getFetch)(this.config),
        middleware: middleware_1.middleware
      };
      var indexConfiguration = new db_data_1.Configuration(indexConfigurationParameters);
      return new db_data_1.BulkOperationsApi(indexConfiguration);
    };
    return BulkOperationsProvider2;
  }();
  exports.BulkOperationsProvider = BulkOperationsProvider;
});

// node_modules/@pinecone-database/pinecone/dist/data/index.js
var require_data = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Index = undefined;
  var upsert_1 = require_upsert();
  var fetch_1 = require_fetch2();
  var update_1 = require_update();
  var query_1 = require_query();
  var deleteOne_1 = require_deleteOne();
  var deleteMany_1 = require_deleteMany();
  var deleteAll_1 = require_deleteAll();
  var describeIndexStats_1 = require_describeIndexStats();
  var vectorOperationsProvider_1 = require_vectorOperationsProvider();
  var list_1 = require_list();
  var startImport_1 = require_startImport();
  var listImports_1 = require_listImports();
  var describeImport_1 = require_describeImport();
  var cancelImport_1 = require_cancelImport();
  var bulkOperationsProvider_1 = require_bulkOperationsProvider();
  var Index3 = function() {
    function Index4(indexName, config, namespace, indexHostUrl, additionalHeaders) {
      if (namespace === undefined) {
        namespace = "";
      }
      this.config = config;
      this.target = {
        index: indexName,
        namespace,
        indexHostUrl
      };
      var dataOperationsProvider = new vectorOperationsProvider_1.VectorOperationsProvider(config, indexName, indexHostUrl, additionalHeaders);
      this._deleteAll = (0, deleteAll_1.deleteAll)(dataOperationsProvider, namespace);
      this._deleteMany = (0, deleteMany_1.deleteMany)(dataOperationsProvider, namespace);
      this._deleteOne = (0, deleteOne_1.deleteOne)(dataOperationsProvider, namespace);
      this._describeIndexStats = (0, describeIndexStats_1.describeIndexStats)(dataOperationsProvider);
      this._listPaginated = (0, list_1.listPaginated)(dataOperationsProvider, namespace);
      this._fetchCommand = new fetch_1.FetchCommand(dataOperationsProvider, namespace);
      this._queryCommand = new query_1.QueryCommand(dataOperationsProvider, namespace);
      this._updateCommand = new update_1.UpdateCommand(dataOperationsProvider, namespace);
      this._upsertCommand = new upsert_1.UpsertCommand(dataOperationsProvider, namespace);
      var bulkApiProvider = new bulkOperationsProvider_1.BulkOperationsProvider(config, indexName, indexHostUrl, additionalHeaders);
      this._startImportCommand = new startImport_1.StartImportCommand(bulkApiProvider, namespace);
      this._listImportsCommand = new listImports_1.ListImportsCommand(bulkApiProvider, namespace);
      this._describeImportCommand = new describeImport_1.DescribeImportCommand(bulkApiProvider, namespace);
      this._cancelImportCommand = new cancelImport_1.CancelImportCommand(bulkApiProvider, namespace);
    }
    Index4.prototype.deleteAll = function() {
      return this._deleteAll();
    };
    Index4.prototype.deleteMany = function(options) {
      return this._deleteMany(options);
    };
    Index4.prototype.deleteOne = function(id) {
      return this._deleteOne(id);
    };
    Index4.prototype.describeIndexStats = function() {
      return this._describeIndexStats();
    };
    Index4.prototype.listPaginated = function(options) {
      return this._listPaginated(options);
    };
    Index4.prototype.namespace = function(namespace) {
      return new Index4(this.target.index, this.config, namespace, this.target.indexHostUrl);
    };
    Index4.prototype.upsert = function(data) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._upsertCommand.run(data)];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    Index4.prototype.fetch = function(options) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._fetchCommand.run(options)];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    Index4.prototype.query = function(options) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._queryCommand.run(options)];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    Index4.prototype.update = function(options) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._updateCommand.run(options)];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    Index4.prototype.startImport = function(uri2, errorMode, integration) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._startImportCommand.run(uri2, errorMode, integration)];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    Index4.prototype.listImports = function(limit, paginationToken) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._listImportsCommand.run(limit, paginationToken)];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    Index4.prototype.describeImport = function(id) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._describeImportCommand.run(id)];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    Index4.prototype.cancelImport = function(id) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._cancelImportCommand.run(id)];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return Index4;
  }();
  exports.Index = Index3;
});

// node_modules/@pinecone-database/pinecone/dist/models/embeddingsList.js
var require_embeddingsList = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from.length, ar;i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmbeddingsList = undefined;
  var EmbeddingsList = function(_super) {
    __extends(EmbeddingsList2, _super);
    function EmbeddingsList2(model, data, usage) {
      if (data === undefined) {
        data = [];
      }
      var _this = _super.apply(this, data) || this;
      Object.setPrototypeOf(_this, EmbeddingsList2.prototype);
      _this.model = model;
      _this.data = data;
      _this.usage = usage;
      return _this;
    }
    EmbeddingsList2.prototype.toString = function() {
      var truncatedData = this.truncateDataForDisplay();
      var dataObject = truncatedData.map(function(embedding) {
        var _a2;
        if (typeof embedding === "string") {
          return "    ".concat(embedding);
        }
        var embeddingObject = JSON.stringify(embedding, function(key, value2) {
          return key === "values" && Array.isArray(value2) ? value2 : value2;
        });
        embeddingObject = embeddingObject.replace(/:/g, ": ");
        var valuesArray = ((_a2 = embeddingObject.match(/"values": \[(.*?)\]/)) === null || _a2 === undefined ? undefined : _a2[1]) || "";
        var formattedEmbedding = valuesArray.split(",").join(", ").replace(/"/g, "");
        embeddingObject = embeddingObject.replace(/("values": )\[(.*?)\]/, "$1[".concat(formattedEmbedding, "]"));
        return "    ".concat(embeddingObject);
      }).join(",\n");
      var usageObject = JSON.stringify(this.usage).replace(/:/g, ": ");
      return "EmbeddingsList({\n" + "  \"model\": \"".concat(this.model, "\",\n") + "  \"data\": [\n" + "".concat(dataObject, "\n") + "   ],\n" + "  \"usage\": ".concat(usageObject, "\n") + "  })";
    };
    EmbeddingsList2.prototype.toJSON = function() {
      return {
        model: this.model,
        data: this.truncateDataForDisplay(),
        usage: this.usage
      };
    };
    EmbeddingsList2.prototype.get = function(index) {
      return this[index];
    };
    EmbeddingsList2.prototype.indexOf = function(element) {
      return this.data ? this.data.indexOf(element) : -1;
    };
    EmbeddingsList2.prototype.truncateValuesForDisplay = function(values) {
      if (!values || values.length <= 4) {
        return values ? values : [];
      }
      return __spreadArray(__spreadArray(__spreadArray([], values.slice(0, 2), true), ["..."], false), values.slice(-2), true);
    };
    EmbeddingsList2.prototype.truncateDataForDisplay = function() {
      var _this = this;
      if (!this.data)
        return [];
      if (this.data.length <= 5) {
        return this.data.map(function(embedding) {
          return {
            values: embedding.values ? _this.truncateValuesForDisplay(embedding.values) : []
          };
        });
      }
      return __spreadArray(__spreadArray(__spreadArray([], this.data.slice(0, 2).map(function(embedding) {
        return {
          values: embedding.values ? _this.truncateValuesForDisplay(embedding.values) : []
        };
      }), true), [
        "   ... (".concat(this.data.length - 4, " more embeddings) ...")
      ], false), this.data.slice(-2).map(function(embedding) {
        return {
          values: embedding.values ? _this.truncateValuesForDisplay(embedding.values) : []
        };
      }), true);
    };
    return EmbeddingsList2;
  }(Array);
  exports.EmbeddingsList = EmbeddingsList;
});

// node_modules/@pinecone-database/pinecone/dist/models/index.js
var require_models3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmbeddingsList = undefined;
  var embeddingsList_1 = require_embeddingsList();
  Object.defineProperty(exports, "EmbeddingsList", { enumerable: true, get: function() {
    return embeddingsList_1.EmbeddingsList;
  } });
});

// node_modules/@pinecone-database/pinecone/dist/inference/inference.js
var require_inference = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Inference = undefined;
  var models_1 = require_models3();
  var errors_1 = require_errors();
  var Inference = function() {
    function Inference2(inferenceApi) {
      this._inferenceApi = inferenceApi;
    }
    Inference2.prototype._formatInputs = function(data) {
      return data.map(function(str2) {
        return { text: str2 };
      });
    };
    Inference2.prototype.embed = function(model, inputs, params) {
      return __awaiter(this, undefined, undefined, function() {
        var typedAndFormattedInputs, typedRequest, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              typedAndFormattedInputs = this._formatInputs(inputs);
              typedRequest = {
                embedRequest: {
                  model,
                  inputs: typedAndFormattedInputs,
                  parameters: params
                }
              };
              return [4, this._inferenceApi.embed(typedRequest)];
            case 1:
              response = _a2.sent();
              return [2, new models_1.EmbeddingsList(response.model, response.data, response.usage)];
          }
        });
      });
    };
    Inference2.prototype.rerank = function(model, query, documents, options) {
      if (options === undefined) {
        options = {};
      }
      return __awaiter(this, undefined, undefined, function() {
        var _a2, topN, _b, returnDocuments, _c, parameters3, _d, rankFields, newDocuments, req;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              if (documents.length == 0) {
                throw new errors_1.PineconeArgumentError("You must pass at least one document to rerank");
              }
              if (query.length == 0) {
                throw new errors_1.PineconeArgumentError("You must pass a query to rerank");
              }
              if (model.length == 0) {
                throw new errors_1.PineconeArgumentError("You must pass the name of a supported reranking model in order to rerank" + " documents. See https://docs.pinecone.io/models for supported models.");
              }
              _a2 = options.topN, topN = _a2 === undefined ? documents.length : _a2, _b = options.returnDocuments, returnDocuments = _b === undefined ? true : _b, _c = options.parameters, parameters3 = _c === undefined ? {} : _c;
              _d = options.rankFields, rankFields = _d === undefined ? ["text"] : _d;
              newDocuments = documents.map(function(doc) {
                return typeof doc === "string" ? { text: doc } : doc;
              });
              if (!options.rankFields) {
                if (!newDocuments.every(function(doc) {
                  return typeof doc === "object" && doc.text;
                })) {
                  throw new errors_1.PineconeArgumentError('Documents must be a list of strings or objects containing the "text" field');
                }
              }
              if (options.rankFields) {
                rankFields = options.rankFields;
              }
              req = {
                rerankRequest: {
                  model,
                  query,
                  documents: newDocuments,
                  topN,
                  returnDocuments,
                  rankFields,
                  parameters: parameters3
                }
              };
              return [4, this._inferenceApi.rerank(req)];
            case 1:
              return [2, _e.sent()];
          }
        });
      });
    };
    return Inference2;
  }();
  exports.Inference = Inference;
});

// node_modules/@pinecone-database/pinecone/dist/inference/index.js
var require_inference2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_inference(), exports);
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/runtime.js
var require_runtime3 = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TextApiResponse = exports.BlobApiResponse = exports.VoidApiResponse = exports.JSONApiResponse = exports.canConsumeForm = exports.mapValues = exports.querystring = exports.exists = exports.COLLECTION_FORMATS = exports.RequiredError = exports.FetchError = exports.ResponseError = exports.BaseAPI = exports.DefaultConfig = exports.Configuration = exports.BASE_PATH = undefined;
  exports.BASE_PATH = "https://api.pinecone.io".replace(/\/+$/, "");
  var Configuration = function() {
    function Configuration2(configuration) {
      if (configuration === undefined) {
        configuration = {};
      }
      this.configuration = configuration;
    }
    Object.defineProperty(Configuration2.prototype, "config", {
      set: function(configuration) {
        this.configuration = configuration;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "basePath", {
      get: function() {
        return this.configuration.basePath != null ? this.configuration.basePath : exports.BASE_PATH;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "fetchApi", {
      get: function() {
        return this.configuration.fetchApi;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "middleware", {
      get: function() {
        return this.configuration.middleware || [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "queryParamsStringify", {
      get: function() {
        return this.configuration.queryParamsStringify || querystring;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "username", {
      get: function() {
        return this.configuration.username;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "password", {
      get: function() {
        return this.configuration.password;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "apiKey", {
      get: function() {
        var apiKey = this.configuration.apiKey;
        if (apiKey) {
          return typeof apiKey === "function" ? apiKey : function() {
            return apiKey;
          };
        }
        return;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "accessToken", {
      get: function() {
        var _this = this;
        var accessToken = this.configuration.accessToken;
        if (accessToken) {
          return typeof accessToken === "function" ? accessToken : function() {
            return __awaiter(_this, undefined, undefined, function() {
              return __generator(this, function(_a2) {
                return [2, accessToken];
              });
            });
          };
        }
        return;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "headers", {
      get: function() {
        return this.configuration.headers;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Configuration2.prototype, "credentials", {
      get: function() {
        return this.configuration.credentials;
      },
      enumerable: false,
      configurable: true
    });
    return Configuration2;
  }();
  exports.Configuration = Configuration;
  exports.DefaultConfig = new Configuration;
  var BaseAPI = function() {
    function BaseAPI2(configuration) {
      if (configuration === undefined) {
        configuration = exports.DefaultConfig;
      }
      var _this = this;
      this.configuration = configuration;
      this.fetchApi = function(url, init) {
        return __awaiter(_this, undefined, undefined, function() {
          var fetchParams, _i, _a2, middleware, response, e_1, _b, _c, middleware, _d, _e, middleware;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                fetchParams = { url, init };
                _i = 0, _a2 = this.middleware;
                _f.label = 1;
              case 1:
                if (!(_i < _a2.length))
                  return [3, 4];
                middleware = _a2[_i];
                if (!middleware.pre)
                  return [3, 3];
                return [4, middleware.pre(__assign({ fetch: this.fetchApi }, fetchParams))];
              case 2:
                fetchParams = _f.sent() || fetchParams;
                _f.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                response = undefined;
                _f.label = 5;
              case 5:
                _f.trys.push([5, 7, , 12]);
                return [4, (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init)];
              case 6:
                response = _f.sent();
                return [3, 12];
              case 7:
                e_1 = _f.sent();
                _b = 0, _c = this.middleware;
                _f.label = 8;
              case 8:
                if (!(_b < _c.length))
                  return [3, 11];
                middleware = _c[_b];
                if (!middleware.onError)
                  return [3, 10];
                return [4, middleware.onError({
                  fetch: this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  error: e_1,
                  response: response ? response.clone() : undefined
                })];
              case 9:
                response = _f.sent() || response;
                _f.label = 10;
              case 10:
                _b++;
                return [3, 8];
              case 11:
                if (response === undefined) {
                  if (e_1 instanceof Error) {
                    throw new FetchError(e_1, "The request failed and the interceptors did not return an alternative response");
                  } else {
                    throw e_1;
                  }
                }
                return [3, 12];
              case 12:
                _d = 0, _e = this.middleware;
                _f.label = 13;
              case 13:
                if (!(_d < _e.length))
                  return [3, 16];
                middleware = _e[_d];
                if (!middleware.post)
                  return [3, 15];
                return [4, middleware.post({
                  fetch: this.fetchApi,
                  url: fetchParams.url,
                  init: fetchParams.init,
                  response: response.clone()
                })];
              case 14:
                response = _f.sent() || response;
                _f.label = 15;
              case 15:
                _d++;
                return [3, 13];
              case 16:
                return [2, response];
            }
          });
        });
      };
      this.middleware = configuration.middleware;
    }
    BaseAPI2.prototype.withMiddleware = function() {
      var _a2;
      var middlewares = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        middlewares[_i] = arguments[_i];
      }
      var next = this.clone();
      next.middleware = (_a2 = next.middleware).concat.apply(_a2, middlewares);
      return next;
    };
    BaseAPI2.prototype.withPreMiddleware = function() {
      var preMiddlewares = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        preMiddlewares[_i] = arguments[_i];
      }
      var middlewares = preMiddlewares.map(function(pre) {
        return { pre };
      });
      return this.withMiddleware.apply(this, middlewares);
    };
    BaseAPI2.prototype.withPostMiddleware = function() {
      var postMiddlewares = [];
      for (var _i = 0;_i < arguments.length; _i++) {
        postMiddlewares[_i] = arguments[_i];
      }
      var middlewares = postMiddlewares.map(function(post) {
        return { post };
      });
      return this.withMiddleware.apply(this, middlewares);
    };
    BaseAPI2.prototype.isJsonMime = function(mime) {
      if (!mime) {
        return false;
      }
      return BaseAPI2.jsonRegex.test(mime);
    };
    BaseAPI2.prototype.request = function(context, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var _a2, url, init, response;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, this.createFetchParams(context, initOverrides)];
            case 1:
              _a2 = _b.sent(), url = _a2.url, init = _a2.init;
              return [4, this.fetchApi(url, init)];
            case 2:
              response = _b.sent();
              if (response && (response.status >= 200 && response.status < 300)) {
                return [2, response];
              }
              throw new ResponseError(response, "Response returned an error code");
          }
        });
      });
    };
    BaseAPI2.prototype.createFetchParams = function(context, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var url, headers, initOverrideFn, initParams, overriddenInit, _a2, body, init;
        var _this = this;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              url = this.configuration.basePath + context.path;
              if (context.query !== undefined && Object.keys(context.query).length !== 0) {
                url += "?" + this.configuration.queryParamsStringify(context.query);
              }
              headers = Object.assign({}, this.configuration.headers, context.headers);
              Object.keys(headers).forEach(function(key) {
                return headers[key] === undefined ? delete headers[key] : {};
              });
              initOverrideFn = typeof initOverrides === "function" ? initOverrides : function() {
                return __awaiter(_this, undefined, undefined, function() {
                  return __generator(this, function(_a3) {
                    return [2, initOverrides];
                  });
                });
              };
              initParams = {
                method: context.method,
                headers,
                body: context.body,
                credentials: this.configuration.credentials
              };
              _a2 = [__assign({}, initParams)];
              return [4, initOverrideFn({
                init: initParams,
                context
              })];
            case 1:
              overriddenInit = __assign.apply(undefined, _a2.concat([_b.sent()]));
              if (isFormData(overriddenInit.body) || overriddenInit.body instanceof URLSearchParams || isBlob(overriddenInit.body)) {
                body = overriddenInit.body;
              } else if (this.isJsonMime(headers["Content-Type"])) {
                body = JSON.stringify(overriddenInit.body);
              } else {
                body = overriddenInit.body;
              }
              init = __assign(__assign({}, overriddenInit), { body });
              return [2, { url, init }];
          }
        });
      });
    };
    BaseAPI2.prototype.clone = function() {
      var constructor3 = this.constructor;
      var next = new constructor3(this.configuration);
      next.middleware = this.middleware.slice();
      return next;
    };
    BaseAPI2.jsonRegex = new RegExp("^(:?application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(:?;.*)?$", "i");
    return BaseAPI2;
  }();
  exports.BaseAPI = BaseAPI;
  function isBlob(value2) {
    return typeof Blob !== "undefined" && value2 instanceof Blob;
  }
  function isFormData(value2) {
    return typeof FormData !== "undefined" && value2 instanceof FormData;
  }
  var ResponseError = function(_super) {
    __extends(ResponseError2, _super);
    function ResponseError2(response, msg) {
      var _this = _super.call(this, msg) || this;
      _this.response = response;
      _this.name = "ResponseError";
      return _this;
    }
    return ResponseError2;
  }(Error);
  exports.ResponseError = ResponseError;
  var FetchError = function(_super) {
    __extends(FetchError2, _super);
    function FetchError2(cause, msg) {
      var _this = _super.call(this, msg) || this;
      _this.cause = cause;
      _this.name = "FetchError";
      return _this;
    }
    return FetchError2;
  }(Error);
  exports.FetchError = FetchError;
  var RequiredError = function(_super) {
    __extends(RequiredError2, _super);
    function RequiredError2(field, msg) {
      var _this = _super.call(this, msg) || this;
      _this.field = field;
      _this.name = "RequiredError";
      return _this;
    }
    return RequiredError2;
  }(Error);
  exports.RequiredError = RequiredError;
  exports.COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|"
  };
  function exists(json, key) {
    var value2 = json[key];
    return value2 !== null && value2 !== undefined;
  }
  exports.exists = exists;
  function querystring(params, prefix) {
    if (prefix === undefined) {
      prefix = "";
    }
    return Object.keys(params).map(function(key) {
      return querystringSingleKey(key, params[key], prefix);
    }).filter(function(part) {
      return part.length > 0;
    }).join("&");
  }
  exports.querystring = querystring;
  function querystringSingleKey(key, value2, keyPrefix) {
    if (keyPrefix === undefined) {
      keyPrefix = "";
    }
    var fullKey = keyPrefix + (keyPrefix.length ? "[".concat(key, "]") : key);
    if (value2 instanceof Array) {
      var multiValue = value2.map(function(singleValue) {
        return encodeURIComponent(String(singleValue));
      }).join("&".concat(encodeURIComponent(fullKey), "="));
      return "".concat(encodeURIComponent(fullKey), "=").concat(multiValue);
    }
    if (value2 instanceof Set) {
      var valueAsArray = Array.from(value2);
      return querystringSingleKey(key, valueAsArray, keyPrefix);
    }
    if (value2 instanceof Date) {
      return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(value2.toISOString()));
    }
    if (value2 instanceof Object) {
      return querystring(value2, fullKey);
    }
    return "".concat(encodeURIComponent(fullKey), "=").concat(encodeURIComponent(String(value2)));
  }
  function mapValues(data, fn) {
    return Object.keys(data).reduce(function(acc, key) {
      var _a2;
      return __assign(__assign({}, acc), (_a2 = {}, _a2[key] = fn(data[key]), _a2));
    }, {});
  }
  exports.mapValues = mapValues;
  function canConsumeForm(consumes) {
    for (var _i = 0, consumes_1 = consumes;_i < consumes_1.length; _i++) {
      var consume = consumes_1[_i];
      if (consume.contentType === "multipart/form-data") {
        return true;
      }
    }
    return false;
  }
  exports.canConsumeForm = canConsumeForm;
  var JSONApiResponse = function() {
    function JSONApiResponse2(raw, transformer) {
      if (transformer === undefined) {
        transformer = function(jsonValue) {
          return jsonValue;
        };
      }
      this.raw = raw;
      this.transformer = transformer;
    }
    JSONApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        var _a2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _a2 = this.transformer;
              return [4, this.raw.json()];
            case 1:
              return [2, _a2.apply(this, [_b.sent()])];
          }
        });
      });
    };
    return JSONApiResponse2;
  }();
  exports.JSONApiResponse = JSONApiResponse;
  var VoidApiResponse = function() {
    function VoidApiResponse2(raw) {
      this.raw = raw;
    }
    VoidApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          return [2, undefined];
        });
      });
    };
    return VoidApiResponse2;
  }();
  exports.VoidApiResponse = VoidApiResponse;
  var BlobApiResponse = function() {
    function BlobApiResponse2(raw) {
      this.raw = raw;
    }
    BlobApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.raw.blob()];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return BlobApiResponse2;
  }();
  exports.BlobApiResponse = BlobApiResponse;
  var TextApiResponse = function() {
    function TextApiResponse2(raw) {
      this.raw = raw;
    }
    TextApiResponse2.prototype.value = function() {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.raw.text()];
            case 1:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return TextApiResponse2;
  }();
  exports.TextApiResponse = TextApiResponse;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbedRequestInputsInner.js
var require_EmbedRequestInputsInner = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmbedRequestInputsInnerToJSON = exports.EmbedRequestInputsInnerFromJSONTyped = exports.EmbedRequestInputsInnerFromJSON = exports.instanceOfEmbedRequestInputsInner = undefined;
  var runtime_1 = require_runtime3();
  function instanceOfEmbedRequestInputsInner(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfEmbedRequestInputsInner = instanceOfEmbedRequestInputsInner;
  function EmbedRequestInputsInnerFromJSON(json) {
    return EmbedRequestInputsInnerFromJSONTyped(json, false);
  }
  exports.EmbedRequestInputsInnerFromJSON = EmbedRequestInputsInnerFromJSON;
  function EmbedRequestInputsInnerFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      text: !(0, runtime_1.exists)(json, "text") ? undefined : json["text"]
    };
  }
  exports.EmbedRequestInputsInnerFromJSONTyped = EmbedRequestInputsInnerFromJSONTyped;
  function EmbedRequestInputsInnerToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      text: value2.text
    };
  }
  exports.EmbedRequestInputsInnerToJSON = EmbedRequestInputsInnerToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbedRequestParameters.js
var require_EmbedRequestParameters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmbedRequestParametersToJSON = exports.EmbedRequestParametersFromJSONTyped = exports.EmbedRequestParametersFromJSON = exports.instanceOfEmbedRequestParameters = undefined;
  var runtime_1 = require_runtime3();
  function instanceOfEmbedRequestParameters(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfEmbedRequestParameters = instanceOfEmbedRequestParameters;
  function EmbedRequestParametersFromJSON(json) {
    return EmbedRequestParametersFromJSONTyped(json, false);
  }
  exports.EmbedRequestParametersFromJSON = EmbedRequestParametersFromJSON;
  function EmbedRequestParametersFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      inputType: !(0, runtime_1.exists)(json, "input_type") ? undefined : json["input_type"],
      truncate: !(0, runtime_1.exists)(json, "truncate") ? undefined : json["truncate"]
    };
  }
  exports.EmbedRequestParametersFromJSONTyped = EmbedRequestParametersFromJSONTyped;
  function EmbedRequestParametersToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      input_type: value2.inputType,
      truncate: value2.truncate
    };
  }
  exports.EmbedRequestParametersToJSON = EmbedRequestParametersToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbedRequest.js
var require_EmbedRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmbedRequestToJSON = exports.EmbedRequestFromJSONTyped = exports.EmbedRequestFromJSON = exports.instanceOfEmbedRequest = undefined;
  var runtime_1 = require_runtime3();
  var EmbedRequestInputsInner_1 = require_EmbedRequestInputsInner();
  var EmbedRequestParameters_1 = require_EmbedRequestParameters();
  function instanceOfEmbedRequest(value2) {
    var isInstance = true;
    isInstance = isInstance && "model" in value2;
    isInstance = isInstance && "inputs" in value2;
    return isInstance;
  }
  exports.instanceOfEmbedRequest = instanceOfEmbedRequest;
  function EmbedRequestFromJSON(json) {
    return EmbedRequestFromJSONTyped(json, false);
  }
  exports.EmbedRequestFromJSON = EmbedRequestFromJSON;
  function EmbedRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      model: json["model"],
      parameters: !(0, runtime_1.exists)(json, "parameters") ? undefined : (0, EmbedRequestParameters_1.EmbedRequestParametersFromJSON)(json["parameters"]),
      inputs: json["inputs"].map(EmbedRequestInputsInner_1.EmbedRequestInputsInnerFromJSON)
    };
  }
  exports.EmbedRequestFromJSONTyped = EmbedRequestFromJSONTyped;
  function EmbedRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      model: value2.model,
      parameters: (0, EmbedRequestParameters_1.EmbedRequestParametersToJSON)(value2.parameters),
      inputs: value2.inputs.map(EmbedRequestInputsInner_1.EmbedRequestInputsInnerToJSON)
    };
  }
  exports.EmbedRequestToJSON = EmbedRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/Embedding.js
var require_Embedding = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmbeddingToJSON = exports.EmbeddingFromJSONTyped = exports.EmbeddingFromJSON = exports.instanceOfEmbedding = undefined;
  var runtime_1 = require_runtime3();
  function instanceOfEmbedding(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfEmbedding = instanceOfEmbedding;
  function EmbeddingFromJSON(json) {
    return EmbeddingFromJSONTyped(json, false);
  }
  exports.EmbeddingFromJSON = EmbeddingFromJSON;
  function EmbeddingFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      values: !(0, runtime_1.exists)(json, "values") ? undefined : json["values"]
    };
  }
  exports.EmbeddingFromJSONTyped = EmbeddingFromJSONTyped;
  function EmbeddingToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      values: value2.values
    };
  }
  exports.EmbeddingToJSON = EmbeddingToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbeddingsListUsage.js
var require_EmbeddingsListUsage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmbeddingsListUsageToJSON = exports.EmbeddingsListUsageFromJSONTyped = exports.EmbeddingsListUsageFromJSON = exports.instanceOfEmbeddingsListUsage = undefined;
  var runtime_1 = require_runtime3();
  function instanceOfEmbeddingsListUsage(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfEmbeddingsListUsage = instanceOfEmbeddingsListUsage;
  function EmbeddingsListUsageFromJSON(json) {
    return EmbeddingsListUsageFromJSONTyped(json, false);
  }
  exports.EmbeddingsListUsageFromJSON = EmbeddingsListUsageFromJSON;
  function EmbeddingsListUsageFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      totalTokens: !(0, runtime_1.exists)(json, "total_tokens") ? undefined : json["total_tokens"]
    };
  }
  exports.EmbeddingsListUsageFromJSONTyped = EmbeddingsListUsageFromJSONTyped;
  function EmbeddingsListUsageToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      total_tokens: value2.totalTokens
    };
  }
  exports.EmbeddingsListUsageToJSON = EmbeddingsListUsageToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/EmbeddingsList.js
var require_EmbeddingsList = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmbeddingsListToJSON = exports.EmbeddingsListFromJSONTyped = exports.EmbeddingsListFromJSON = exports.instanceOfEmbeddingsList = undefined;
  var Embedding_1 = require_Embedding();
  var EmbeddingsListUsage_1 = require_EmbeddingsListUsage();
  function instanceOfEmbeddingsList(value2) {
    var isInstance = true;
    isInstance = isInstance && "model" in value2;
    isInstance = isInstance && "data" in value2;
    isInstance = isInstance && "usage" in value2;
    return isInstance;
  }
  exports.instanceOfEmbeddingsList = instanceOfEmbeddingsList;
  function EmbeddingsListFromJSON(json) {
    return EmbeddingsListFromJSONTyped(json, false);
  }
  exports.EmbeddingsListFromJSON = EmbeddingsListFromJSON;
  function EmbeddingsListFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      model: json["model"],
      data: json["data"].map(Embedding_1.EmbeddingFromJSON),
      usage: (0, EmbeddingsListUsage_1.EmbeddingsListUsageFromJSON)(json["usage"])
    };
  }
  exports.EmbeddingsListFromJSONTyped = EmbeddingsListFromJSONTyped;
  function EmbeddingsListToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      model: value2.model,
      data: value2.data.map(Embedding_1.EmbeddingToJSON),
      usage: (0, EmbeddingsListUsage_1.EmbeddingsListUsageToJSON)(value2.usage)
    };
  }
  exports.EmbeddingsListToJSON = EmbeddingsListToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ErrorResponseError.js
var require_ErrorResponseError2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ErrorResponseErrorToJSON = exports.ErrorResponseErrorFromJSONTyped = exports.ErrorResponseErrorFromJSON = exports.instanceOfErrorResponseError = exports.ErrorResponseErrorCodeEnum = undefined;
  var runtime_1 = require_runtime3();
  exports.ErrorResponseErrorCodeEnum = {
    Ok: "OK",
    Unknown: "UNKNOWN",
    InvalidArgument: "INVALID_ARGUMENT",
    DeadlineExceeded: "DEADLINE_EXCEEDED",
    QuotaExceeded: "QUOTA_EXCEEDED",
    NotFound: "NOT_FOUND",
    AlreadyExists: "ALREADY_EXISTS",
    PermissionDenied: "PERMISSION_DENIED",
    Unauthenticated: "UNAUTHENTICATED",
    ResourceExhausted: "RESOURCE_EXHAUSTED",
    FailedPrecondition: "FAILED_PRECONDITION",
    Aborted: "ABORTED",
    OutOfRange: "OUT_OF_RANGE",
    Unimplemented: "UNIMPLEMENTED",
    Internal: "INTERNAL",
    Unavailable: "UNAVAILABLE",
    DataLoss: "DATA_LOSS",
    Forbidden: "FORBIDDEN"
  };
  function instanceOfErrorResponseError(value2) {
    var isInstance = true;
    isInstance = isInstance && "code" in value2;
    isInstance = isInstance && "message" in value2;
    return isInstance;
  }
  exports.instanceOfErrorResponseError = instanceOfErrorResponseError;
  function ErrorResponseErrorFromJSON(json) {
    return ErrorResponseErrorFromJSONTyped(json, false);
  }
  exports.ErrorResponseErrorFromJSON = ErrorResponseErrorFromJSON;
  function ErrorResponseErrorFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      code: json["code"],
      message: json["message"],
      details: !(0, runtime_1.exists)(json, "details") ? undefined : json["details"]
    };
  }
  exports.ErrorResponseErrorFromJSONTyped = ErrorResponseErrorFromJSONTyped;
  function ErrorResponseErrorToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      code: value2.code,
      message: value2.message,
      details: value2.details
    };
  }
  exports.ErrorResponseErrorToJSON = ErrorResponseErrorToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/ErrorResponse.js
var require_ErrorResponse2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ErrorResponseToJSON = exports.ErrorResponseFromJSONTyped = exports.ErrorResponseFromJSON = exports.instanceOfErrorResponse = undefined;
  var ErrorResponseError_1 = require_ErrorResponseError2();
  function instanceOfErrorResponse(value2) {
    var isInstance = true;
    isInstance = isInstance && "status" in value2;
    isInstance = isInstance && "error" in value2;
    return isInstance;
  }
  exports.instanceOfErrorResponse = instanceOfErrorResponse;
  function ErrorResponseFromJSON(json) {
    return ErrorResponseFromJSONTyped(json, false);
  }
  exports.ErrorResponseFromJSON = ErrorResponseFromJSON;
  function ErrorResponseFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      status: json["status"],
      error: (0, ErrorResponseError_1.ErrorResponseErrorFromJSON)(json["error"])
    };
  }
  exports.ErrorResponseFromJSONTyped = ErrorResponseFromJSONTyped;
  function ErrorResponseToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      status: value2.status,
      error: (0, ErrorResponseError_1.ErrorResponseErrorToJSON)(value2.error)
    };
  }
  exports.ErrorResponseToJSON = ErrorResponseToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RankedDocument.js
var require_RankedDocument = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RankedDocumentToJSON = exports.RankedDocumentFromJSONTyped = exports.RankedDocumentFromJSON = exports.instanceOfRankedDocument = undefined;
  var runtime_1 = require_runtime3();
  function instanceOfRankedDocument(value2) {
    var isInstance = true;
    isInstance = isInstance && "index" in value2;
    isInstance = isInstance && "score" in value2;
    return isInstance;
  }
  exports.instanceOfRankedDocument = instanceOfRankedDocument;
  function RankedDocumentFromJSON(json) {
    return RankedDocumentFromJSONTyped(json, false);
  }
  exports.RankedDocumentFromJSON = RankedDocumentFromJSON;
  function RankedDocumentFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      index: json["index"],
      score: json["score"],
      document: !(0, runtime_1.exists)(json, "document") ? undefined : json["document"]
    };
  }
  exports.RankedDocumentFromJSONTyped = RankedDocumentFromJSONTyped;
  function RankedDocumentToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      index: value2.index,
      score: value2.score,
      document: value2.document
    };
  }
  exports.RankedDocumentToJSON = RankedDocumentToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RerankRequest.js
var require_RerankRequest = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RerankRequestToJSON = exports.RerankRequestFromJSONTyped = exports.RerankRequestFromJSON = exports.instanceOfRerankRequest = undefined;
  var runtime_1 = require_runtime3();
  function instanceOfRerankRequest(value2) {
    var isInstance = true;
    isInstance = isInstance && "model" in value2;
    isInstance = isInstance && "query" in value2;
    isInstance = isInstance && "documents" in value2;
    return isInstance;
  }
  exports.instanceOfRerankRequest = instanceOfRerankRequest;
  function RerankRequestFromJSON(json) {
    return RerankRequestFromJSONTyped(json, false);
  }
  exports.RerankRequestFromJSON = RerankRequestFromJSON;
  function RerankRequestFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      model: json["model"],
      query: json["query"],
      topN: !(0, runtime_1.exists)(json, "top_n") ? undefined : json["top_n"],
      returnDocuments: !(0, runtime_1.exists)(json, "return_documents") ? undefined : json["return_documents"],
      rankFields: !(0, runtime_1.exists)(json, "rank_fields") ? undefined : json["rank_fields"],
      documents: json["documents"],
      parameters: !(0, runtime_1.exists)(json, "parameters") ? undefined : json["parameters"]
    };
  }
  exports.RerankRequestFromJSONTyped = RerankRequestFromJSONTyped;
  function RerankRequestToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      model: value2.model,
      query: value2.query,
      top_n: value2.topN,
      return_documents: value2.returnDocuments,
      rank_fields: value2.rankFields,
      documents: value2.documents,
      parameters: value2.parameters
    };
  }
  exports.RerankRequestToJSON = RerankRequestToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RerankResultUsage.js
var require_RerankResultUsage = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RerankResultUsageToJSON = exports.RerankResultUsageFromJSONTyped = exports.RerankResultUsageFromJSON = exports.instanceOfRerankResultUsage = undefined;
  var runtime_1 = require_runtime3();
  function instanceOfRerankResultUsage(value2) {
    var isInstance = true;
    return isInstance;
  }
  exports.instanceOfRerankResultUsage = instanceOfRerankResultUsage;
  function RerankResultUsageFromJSON(json) {
    return RerankResultUsageFromJSONTyped(json, false);
  }
  exports.RerankResultUsageFromJSON = RerankResultUsageFromJSON;
  function RerankResultUsageFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      rerankUnits: !(0, runtime_1.exists)(json, "rerank_units") ? undefined : json["rerank_units"]
    };
  }
  exports.RerankResultUsageFromJSONTyped = RerankResultUsageFromJSONTyped;
  function RerankResultUsageToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      rerank_units: value2.rerankUnits
    };
  }
  exports.RerankResultUsageToJSON = RerankResultUsageToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/RerankResult.js
var require_RerankResult = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RerankResultToJSON = exports.RerankResultFromJSONTyped = exports.RerankResultFromJSON = exports.instanceOfRerankResult = undefined;
  var RankedDocument_1 = require_RankedDocument();
  var RerankResultUsage_1 = require_RerankResultUsage();
  function instanceOfRerankResult(value2) {
    var isInstance = true;
    isInstance = isInstance && "model" in value2;
    isInstance = isInstance && "data" in value2;
    isInstance = isInstance && "usage" in value2;
    return isInstance;
  }
  exports.instanceOfRerankResult = instanceOfRerankResult;
  function RerankResultFromJSON(json) {
    return RerankResultFromJSONTyped(json, false);
  }
  exports.RerankResultFromJSON = RerankResultFromJSON;
  function RerankResultFromJSONTyped(json, ignoreDiscriminator) {
    if (json === undefined || json === null) {
      return json;
    }
    return {
      model: json["model"],
      data: json["data"].map(RankedDocument_1.RankedDocumentFromJSON),
      usage: (0, RerankResultUsage_1.RerankResultUsageFromJSON)(json["usage"])
    };
  }
  exports.RerankResultFromJSONTyped = RerankResultFromJSONTyped;
  function RerankResultToJSON(value2) {
    if (value2 === undefined) {
      return;
    }
    if (value2 === null) {
      return null;
    }
    return {
      model: value2.model,
      data: value2.data.map(RankedDocument_1.RankedDocumentToJSON),
      usage: (0, RerankResultUsage_1.RerankResultUsageToJSON)(value2.usage)
    };
  }
  exports.RerankResultToJSON = RerankResultToJSON;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/models/index.js
var require_models4 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_EmbedRequest(), exports);
  __exportStar(require_EmbedRequestInputsInner(), exports);
  __exportStar(require_EmbedRequestParameters(), exports);
  __exportStar(require_Embedding(), exports);
  __exportStar(require_EmbeddingsList(), exports);
  __exportStar(require_EmbeddingsListUsage(), exports);
  __exportStar(require_ErrorResponse2(), exports);
  __exportStar(require_ErrorResponseError2(), exports);
  __exportStar(require_RankedDocument(), exports);
  __exportStar(require_RerankRequest(), exports);
  __exportStar(require_RerankResult(), exports);
  __exportStar(require_RerankResultUsage(), exports);
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/apis/InferenceApi.js
var require_InferenceApi = __commonJS((exports) => {
  var __extends = exports && exports.__extends || function() {
    var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
    };
  }();
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InferenceApi = undefined;
  var runtime = __importStar(require_runtime3());
  var index_1 = require_models4();
  var InferenceApi = function(_super) {
    __extends(InferenceApi2, _super);
    function InferenceApi2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    InferenceApi2.prototype.embedRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/embed",
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.EmbedRequestToJSON)(requestParameters.embedRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.EmbeddingsListFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    InferenceApi2.prototype.embed = function(requestParameters, initOverrides) {
      if (requestParameters === undefined) {
        requestParameters = {};
      }
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.embedRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    InferenceApi2.prototype.rerankRaw = function(requestParameters, initOverrides) {
      return __awaiter(this, undefined, undefined, function() {
        var queryParameters, headerParameters, response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              queryParameters = {};
              headerParameters = {};
              headerParameters["Content-Type"] = "application/json";
              if (this.configuration && this.configuration.apiKey) {
                headerParameters["Api-Key"] = this.configuration.apiKey("Api-Key");
              }
              return [4, this.request({
                path: "/rerank",
                method: "POST",
                headers: headerParameters,
                query: queryParameters,
                body: (0, index_1.RerankRequestToJSON)(requestParameters.rerankRequest)
              }, initOverrides)];
            case 1:
              response = _a2.sent();
              return [2, new runtime.JSONApiResponse(response, function(jsonValue) {
                return (0, index_1.RerankResultFromJSON)(jsonValue);
              })];
          }
        });
      });
    };
    InferenceApi2.prototype.rerank = function(requestParameters, initOverrides) {
      if (requestParameters === undefined) {
        requestParameters = {};
      }
      return __awaiter(this, undefined, undefined, function() {
        var response;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this.rerankRaw(requestParameters, initOverrides)];
            case 1:
              response = _a2.sent();
              return [4, response.value()];
            case 2:
              return [2, _a2.sent()];
          }
        });
      });
    };
    return InferenceApi2;
  }(runtime.BaseAPI);
  exports.InferenceApi = InferenceApi;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/apis/index.js
var require_apis3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_InferenceApi(), exports);
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/api_version.js
var require_api_version3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.X_PINECONE_API_VERSION = undefined;
  exports.X_PINECONE_API_VERSION = "2024-10";
});

// node_modules/@pinecone-database/pinecone/dist/pinecone-generated-ts-fetch/inference/index.js
var require_inference3 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_runtime3(), exports);
  __exportStar(require_apis3(), exports);
  __exportStar(require_models4(), exports);
  __exportStar(require_api_version3(), exports);
});

// node_modules/@pinecone-database/pinecone/dist/inference/inferenceOperationsBuilder.js
var require_inferenceOperationsBuilder = __commonJS((exports) => {
  var __assign = exports && exports.__assign || function() {
    __assign = Object.assign || function(t2) {
      for (var s, i = 1, n = arguments.length;i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.inferenceOperationsBuilder = undefined;
  var inference_1 = require_inference3();
  var utils_1 = require_utils2();
  var middleware_1 = require_middleware();
  var inferenceOperationsBuilder = function(config) {
    var apiKey = config.apiKey;
    var controllerPath = (0, utils_1.normalizeUrl)(config.controllerHostUrl) || "https://api.pinecone.io";
    var headers = config.additionalHeaders || null;
    var apiConfig = {
      basePath: controllerPath,
      apiKey,
      queryParamsStringify: utils_1.queryParamsStringify,
      headers: __assign({ "User-Agent": (0, utils_1.buildUserAgent)(config), "X-Pinecone-Api-Version": inference_1.X_PINECONE_API_VERSION }, headers),
      fetchApi: (0, utils_1.getFetch)(config),
      middleware: middleware_1.middleware
    };
    return new inference_1.InferenceApi(new inference_1.Configuration(apiConfig));
  };
  exports.inferenceOperationsBuilder = inferenceOperationsBuilder;
});

// node_modules/@pinecone-database/pinecone/dist/pinecone.js
var require_pinecone = __commonJS((exports) => {
  var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __generator = exports && exports.__generator || function(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1)
        throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f, y, t2, g;
    return g = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2)
        try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
            return t2;
          if (y = 0, t2)
            op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _2.label++;
              return { value: op[1], done: false };
            case 5:
              _2.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _2.ops.pop();
              _2.trys.pop();
              continue;
            default:
              if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _2 = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _2.label = op[1];
                break;
              }
              if (op[0] === 6 && _2.label < t2[1]) {
                _2.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _2.label < t2[2]) {
                _2.label = t2[2];
                _2.ops.push(op);
                break;
              }
              if (t2[2])
                _2.ops.pop();
              _2.trys.pop();
              continue;
          }
          op = body.call(thisArg, _2);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t2 = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : undefined, done: true };
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Pinecone = undefined;
  var control_1 = require_control();
  var indexHostSingleton_1 = require_indexHostSingleton();
  var errors_1 = require_errors();
  var data_1 = require_data();
  var inference_1 = require_inference2();
  var inferenceOperationsBuilder_1 = require_inferenceOperationsBuilder();
  var environment_1 = require_environment();
  var validateProperties_1 = require_validateProperties();
  var types_1 = require_types2();
  var Pinecone = function() {
    function Pinecone2(options) {
      if (options === undefined) {
        options = this._readEnvironmentConfig();
      }
      if (!options.apiKey) {
        throw new errors_1.PineconeConfigurationError("The client configuration must have required property: apiKey.");
      }
      (0, validateProperties_1.ValidateProperties)(options, types_1.PineconeConfigurationProperties);
      this.config = options;
      this._checkForBrowser();
      var api = (0, control_1.indexOperationsBuilder)(this.config);
      var infApi = (0, inferenceOperationsBuilder_1.inferenceOperationsBuilder)(this.config);
      this._configureIndex = (0, control_1.configureIndex)(api);
      this._createCollection = (0, control_1.createCollection)(api);
      this._createIndex = (0, control_1.createIndex)(api);
      this._describeCollection = (0, control_1.describeCollection)(api);
      this._deleteCollection = (0, control_1.deleteCollection)(api);
      this._describeIndex = (0, control_1.describeIndex)(api);
      this._deleteIndex = (0, control_1.deleteIndex)(api);
      this._listCollections = (0, control_1.listCollections)(api);
      this._listIndexes = (0, control_1.listIndexes)(api);
      this.inference = new inference_1.Inference(infApi);
    }
    Pinecone2.prototype._readEnvironmentConfig = function() {
      if (typeof process === "undefined" || !process || !process.env) {
        throw new errors_1.PineconeEnvironmentVarsNotSupportedError("Your execution environment does not support reading environment variables from process.env, so a" + " configuration object is required when calling new Pinecone().");
      }
      var environmentConfig = {};
      var requiredEnvVarMap = {
        apiKey: "PINECONE_API_KEY"
      };
      var missingVars = [];
      for (var _i = 0, _a2 = Object.entries(requiredEnvVarMap);_i < _a2.length; _i++) {
        var _b = _a2[_i], key = _b[0], envVar = _b[1];
        var value2 = process.env[envVar] || "";
        if (!value2) {
          missingVars.push(envVar);
        }
        environmentConfig[key] = value2;
      }
      if (missingVars.length > 0) {
        throw new errors_1.PineconeConfigurationError("Since you called 'new Pinecone()' with no configuration object, we attempted to find client configuration in environment variables but the required environment variables were not set. Missing variables: ".concat(missingVars.join(", "), "."));
      }
      var optionalEnvVarMap = {
        controllerHostUrl: "PINECONE_CONTROLLER_HOST"
      };
      for (var _c = 0, _d = Object.entries(optionalEnvVarMap);_c < _d.length; _c++) {
        var _e = _d[_c], key = _e[0], envVar = _e[1];
        var value2 = process.env[envVar];
        if (value2 !== undefined) {
          environmentConfig[key] = value2;
        }
      }
      return environmentConfig;
    };
    Pinecone2.prototype.describeIndex = function(indexName) {
      return __awaiter(this, undefined, undefined, function() {
        var indexModel;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._describeIndex(indexName)];
            case 1:
              indexModel = _a2.sent();
              if (indexModel.host) {
                indexHostSingleton_1.IndexHostSingleton._set(this.config, indexName, indexModel.host);
              }
              return [2, Promise.resolve(indexModel)];
          }
        });
      });
    };
    Pinecone2.prototype.listIndexes = function() {
      return __awaiter(this, undefined, undefined, function() {
        var indexList, i, index;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._listIndexes()];
            case 1:
              indexList = _a2.sent();
              if (indexList.indexes && indexList.indexes.length > 0) {
                for (i = 0;i < indexList.indexes.length; i++) {
                  index = indexList.indexes[i];
                  indexHostSingleton_1.IndexHostSingleton._set(this.config, index.name, index.host);
                }
              }
              return [2, Promise.resolve(indexList)];
          }
        });
      });
    };
    Pinecone2.prototype.createIndex = function(options) {
      return this._createIndex(options);
    };
    Pinecone2.prototype.deleteIndex = function(indexName) {
      return __awaiter(this, undefined, undefined, function() {
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, this._deleteIndex(indexName)];
            case 1:
              _a2.sent();
              indexHostSingleton_1.IndexHostSingleton._delete(this.config, indexName);
              return [2, Promise.resolve()];
          }
        });
      });
    };
    Pinecone2.prototype.configureIndex = function(indexName, options) {
      return this._configureIndex(indexName, options);
    };
    Pinecone2.prototype.createCollection = function(options) {
      return this._createCollection(options);
    };
    Pinecone2.prototype.listCollections = function() {
      return this._listCollections();
    };
    Pinecone2.prototype.deleteCollection = function(collectionName) {
      return this._deleteCollection(collectionName);
    };
    Pinecone2.prototype.describeCollection = function(collectionName) {
      return this._describeCollection(collectionName);
    };
    Pinecone2.prototype._checkForBrowser = function() {
      if ((0, environment_1.isBrowser)()) {
        console.warn("The Pinecone SDK is intended for server-side use only. Using the SDK within a browser context can expose your API key(s). If you have deployed the SDK to production in a browser, please rotate your API keys.");
      }
    };
    Pinecone2.prototype.getConfig = function() {
      return this.config;
    };
    Pinecone2.prototype.index = function(indexName, indexHostUrl, additionalHeaders) {
      return new data_1.Index(indexName, this.config, undefined, indexHostUrl, additionalHeaders);
    };
    Pinecone2.prototype.Index = function(indexName, indexHostUrl, additionalHeaders) {
      return this.index(indexName, indexHostUrl, additionalHeaders);
    };
    return Pinecone2;
  }();
  exports.Pinecone = Pinecone;
});

// node_modules/@pinecone-database/pinecone/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EmbeddingsList = exports.Errors = exports.Index = exports.Pinecone = undefined;
  var pinecone_1 = require_pinecone();
  Object.defineProperty(exports, "Pinecone", { enumerable: true, get: function() {
    return pinecone_1.Pinecone;
  } });
  var data_1 = require_data();
  Object.defineProperty(exports, "Index", { enumerable: true, get: function() {
    return data_1.Index;
  } });
  exports.Errors = __importStar(require_errors());
  var embeddingsList_1 = require_embeddingsList();
  Object.defineProperty(exports, "EmbeddingsList", { enumerable: true, get: function() {
    return embeddingsList_1.EmbeddingsList;
  } });
});

// node_modules/lodash/lodash.js
var require_lodash2 = __commonJS((exports, module) => {
  (function() {
    var undefined4;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array3, setter, iteratee, accumulator) {
      var index = -1, length = array3 == null ? 0 : array3.length;
      while (++index < length) {
        var value2 = array3[index];
        setter(accumulator, value2, iteratee(value2), array3);
      }
      return accumulator;
    }
    function arrayEach(array3, iteratee) {
      var index = -1, length = array3 == null ? 0 : array3.length;
      while (++index < length) {
        if (iteratee(array3[index], index, array3) === false) {
          break;
        }
      }
      return array3;
    }
    function arrayEachRight(array3, iteratee) {
      var length = array3 == null ? 0 : array3.length;
      while (length--) {
        if (iteratee(array3[length], length, array3) === false) {
          break;
        }
      }
      return array3;
    }
    function arrayEvery(array3, predicate) {
      var index = -1, length = array3 == null ? 0 : array3.length;
      while (++index < length) {
        if (!predicate(array3[index], index, array3)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array3, predicate) {
      var index = -1, length = array3 == null ? 0 : array3.length, resIndex = 0, result = [];
      while (++index < length) {
        var value2 = array3[index];
        if (predicate(value2, index, array3)) {
          result[resIndex++] = value2;
        }
      }
      return result;
    }
    function arrayIncludes(array3, value2) {
      var length = array3 == null ? 0 : array3.length;
      return !!length && baseIndexOf(array3, value2, 0) > -1;
    }
    function arrayIncludesWith(array3, value2, comparator) {
      var index = -1, length = array3 == null ? 0 : array3.length;
      while (++index < length) {
        if (comparator(value2, array3[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array3, iteratee) {
      var index = -1, length = array3 == null ? 0 : array3.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array3[index], index, array3);
      }
      return result;
    }
    function arrayPush(array3, values) {
      var index = -1, length = values.length, offset = array3.length;
      while (++index < length) {
        array3[offset + index] = values[index];
      }
      return array3;
    }
    function arrayReduce(array3, iteratee, accumulator, initAccum) {
      var index = -1, length = array3 == null ? 0 : array3.length;
      if (initAccum && length) {
        accumulator = array3[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array3[index], index, array3);
      }
      return accumulator;
    }
    function arrayReduceRight(array3, iteratee, accumulator, initAccum) {
      var length = array3 == null ? 0 : array3.length;
      if (initAccum && length) {
        accumulator = array3[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array3[length], length, array3);
      }
      return accumulator;
    }
    function arraySome(array3, predicate) {
      var index = -1, length = array3 == null ? 0 : array3.length;
      while (++index < length) {
        if (predicate(array3[index], index, array3)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string3) {
      return string3.split("");
    }
    function asciiWords(string3) {
      return string3.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value2, key, collection2) {
        if (predicate(value2, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array3, predicate, fromIndex, fromRight) {
      var length = array3.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array3[index], index, array3)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array3, value2, fromIndex) {
      return value2 === value2 ? strictIndexOf(array3, value2, fromIndex) : baseFindIndex(array3, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array3, value2, fromIndex, comparator) {
      var index = fromIndex - 1, length = array3.length;
      while (++index < length) {
        if (comparator(array3[index], value2)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value2) {
      return value2 !== value2;
    }
    function baseMean(array3, iteratee) {
      var length = array3 == null ? 0 : array3.length;
      return length ? baseSum(array3, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object3) {
        return object3 == null ? undefined4 : object3[key];
      };
    }
    function basePropertyOf(object3) {
      return function(key) {
        return object3 == null ? undefined4 : object3[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value2, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value2) : iteratee(accumulator, value2, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array3, comparer) {
      var length = array3.length;
      array3.sort(comparer);
      while (length--) {
        array3[length] = array3[length].value;
      }
      return array3;
    }
    function baseSum(array3, iteratee) {
      var result, index = -1, length = array3.length;
      while (++index < length) {
        var current = iteratee(array3[index]);
        if (current !== undefined4) {
          result = result === undefined4 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object3, props) {
      return arrayMap(props, function(key) {
        return [key, object3[key]];
      });
    }
    function baseTrim(string3) {
      return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
    }
    function baseUnary(func) {
      return function(value2) {
        return func(value2);
      };
    }
    function baseValues(object3, props) {
      return arrayMap(props, function(key) {
        return object3[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array3, placeholder) {
      var length = array3.length, result = 0;
      while (length--) {
        if (array3[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object3, key) {
      return object3 == null ? undefined4 : object3[key];
    }
    function hasUnicode(string3) {
      return reHasUnicode.test(string3);
    }
    function hasUnicodeWord(string3) {
      return reHasUnicodeWord.test(string3);
    }
    function iteratorToArray(iterator3) {
      var data, result = [];
      while (!(data = iterator3.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map3) {
      var index = -1, result = Array(map3.size);
      map3.forEach(function(value2, key) {
        result[++index] = [key, value2];
      });
      return result;
    }
    function overArg(func, transform4) {
      return function(arg) {
        return func(transform4(arg));
      };
    }
    function replaceHolders(array3, placeholder) {
      var index = -1, length = array3.length, resIndex = 0, result = [];
      while (++index < length) {
        var value2 = array3[index];
        if (value2 === placeholder || value2 === PLACEHOLDER) {
          array3[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set3) {
      var index = -1, result = Array(set3.size);
      set3.forEach(function(value2) {
        result[++index] = value2;
      });
      return result;
    }
    function setToPairs(set3) {
      var index = -1, result = Array(set3.size);
      set3.forEach(function(value2) {
        result[++index] = [value2, value2];
      });
      return result;
    }
    function strictIndexOf(array3, value2, fromIndex) {
      var index = fromIndex - 1, length = array3.length;
      while (++index < length) {
        if (array3[index] === value2) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array3, value2, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array3[index] === value2) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string3) {
      return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
    }
    function stringToArray(string3) {
      return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
    }
    function trimmedEndIndex(string3) {
      var index = string3.length;
      while (index-- && reWhitespace.test(string3.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string3) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string3)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string3) {
      return string3.match(reUnicode) || [];
    }
    function unicodeWords(string3) {
      return string3.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var { Array: Array3, Date: Date3, Error: Error2, Function: Function4, Math: Math2, Object: Object3, RegExp: RegExp3, String: String4, TypeError: TypeError2 } = context;
      var arrayProto = Array3.prototype, funcProto = Function4.prototype, objectProto = Object3.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object3);
      var oldDash = root._;
      var reIsNative = RegExp3("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined4, Symbol3 = context.Symbol, Uint8Array3 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined4, getPrototype = overArg(Object3.getPrototypeOf, Object3), objectCreate = Object3.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : undefined4, symIterator = Symbol3 ? Symbol3.iterator : undefined4, symToStringTag = Symbol3 ? Symbol3.toStringTag : undefined4;
      var defineProperty = function() {
        try {
          var func = getNative(Object3, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date3 && Date3.now !== root.Date.now && Date3.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var { ceil: nativeCeil, floor: nativeFloor } = Math2, nativeGetSymbols = Object3.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined4, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object3.keys, Object3), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date3.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise3 = getNative(context, "Promise"), Set5 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object3, "create");
      var metaMap = WeakMap2 && new WeakMap2;
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise3), setCtorString = toSource(Set5), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol3 ? Symbol3.prototype : undefined4, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined4, symbolToString = symbolProto ? symbolProto.toString : undefined4;
      function lodash(value2) {
        if (isObjectLike2(value2) && !isArray(value2) && !(value2 instanceof LazyWrapper)) {
          if (value2 instanceof LodashWrapper) {
            return value2;
          }
          if (hasOwnProperty.call(value2, "__wrapped__")) {
            return wrapperClone(value2);
          }
        }
        return new LodashWrapper(value2);
      }
      var baseCreate = function() {
        function object3() {
        }
        return function(proto) {
          if (!isObject3(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object3.prototype = proto;
          var result2 = new object3;
          object3.prototype = undefined4;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value2, chainAll) {
        this.__wrapped__ = value2;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined4;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value2) {
        this.__wrapped__ = value2;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array3 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array3), isRight = dir < 0, arrLength = isArr ? array3.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array3, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value2 = array3[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type3 = data.type, computed = iteratee2(value2);
              if (type3 == LAZY_MAP_FLAG) {
                value2 = computed;
              } else if (!computed) {
                if (type3 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value2;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash3(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined4 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined4;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined4 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value2) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value2 === undefined4 ? HASH_UNDEFINED : value2;
        return this;
      }
      Hash3.prototype.clear = hashClear;
      Hash3.prototype["delete"] = hashDelete;
      Hash3.prototype.get = hashGet;
      Hash3.prototype.has = hashHas;
      Hash3.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined4 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value2) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value2]);
        } else {
          data[index][1] = value2;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash3,
          map: new (Map2 || ListCache),
          string: new Hash3
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value2) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value2);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value2) {
        this.__data__.set(value2, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value2) {
        return this.__data__.has(value2);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value2) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value2]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value2);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value2, inherited) {
        var isArr = isArray(value2), isArg = !isArr && isArguments(value2), isBuff = !isArr && !isArg && isBuffer(value2), isType = !isArr && !isArg && !isBuff && isTypedArray(value2), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value2.length, String4) : [], length = result2.length;
        for (var key in value2) {
          if ((inherited || hasOwnProperty.call(value2, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array3) {
        var length = array3.length;
        return length ? array3[baseRandom(0, length - 1)] : undefined4;
      }
      function arraySampleSize(array3, n) {
        return shuffleSelf(copyArray(array3), baseClamp(n, 0, array3.length));
      }
      function arrayShuffle(array3) {
        return shuffleSelf(copyArray(array3));
      }
      function assignMergeValue(object3, key, value2) {
        if (value2 !== undefined4 && !eq(object3[key], value2) || value2 === undefined4 && !(key in object3)) {
          baseAssignValue(object3, key, value2);
        }
      }
      function assignValue(object3, key, value2) {
        var objValue = object3[key];
        if (!(hasOwnProperty.call(object3, key) && eq(objValue, value2)) || value2 === undefined4 && !(key in object3)) {
          baseAssignValue(object3, key, value2);
        }
      }
      function assocIndexOf(array3, key) {
        var length = array3.length;
        while (length--) {
          if (eq(array3[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value2, key, collection2) {
          setter(accumulator, value2, iteratee2(value2), collection2);
        });
        return accumulator;
      }
      function baseAssign(object3, source) {
        return object3 && copyObject(source, keys(source), object3);
      }
      function baseAssignIn(object3, source) {
        return object3 && copyObject(source, keysIn(source), object3);
      }
      function baseAssignValue(object3, key, value2) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object3, key, {
            configurable: true,
            enumerable: true,
            value: value2,
            writable: true
          });
        } else {
          object3[key] = value2;
        }
      }
      function baseAt(object3, paths) {
        var index = -1, length = paths.length, result2 = Array3(length), skip = object3 == null;
        while (++index < length) {
          result2[index] = skip ? undefined4 : get(object3, paths[index]);
        }
        return result2;
      }
      function baseClamp(number3, lower, upper) {
        if (number3 === number3) {
          if (upper !== undefined4) {
            number3 = number3 <= upper ? number3 : upper;
          }
          if (lower !== undefined4) {
            number3 = number3 >= lower ? number3 : lower;
          }
        }
        return number3;
      }
      function baseClone(value2, bitmask, customizer, key, object3, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object3 ? customizer(value2, key, object3, stack) : customizer(value2);
        }
        if (result2 !== undefined4) {
          return result2;
        }
        if (!isObject3(value2)) {
          return value2;
        }
        var isArr = isArray(value2);
        if (isArr) {
          result2 = initCloneArray(value2);
          if (!isDeep) {
            return copyArray(value2, result2);
          }
        } else {
          var tag = getTag(value2), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value2)) {
            return cloneBuffer(value2, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object3) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value2);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value2, baseAssignIn(result2, value2)) : copySymbols(value2, baseAssign(result2, value2));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object3 ? value2 : {};
            }
            result2 = initCloneByTag(value2, tag, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value2);
        if (stacked) {
          return stacked;
        }
        stack.set(value2, result2);
        if (isSet(value2)) {
          value2.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value2, stack));
          });
        } else if (isMap(value2)) {
          value2.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined4 : keysFunc(value2);
        arrayEach(props || value2, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value2[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value2, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object3) {
          return baseConformsTo(object3, source, props);
        };
      }
      function baseConformsTo(object3, source, props) {
        var length = props.length;
        if (object3 == null) {
          return !length;
        }
        object3 = Object3(object3);
        while (length--) {
          var key = props[length], predicate = source[key], value2 = object3[key];
          if (value2 === undefined4 && !(key in object3) || !predicate(value2)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined4, args);
        }, wait);
      }
      function baseDifference(array3, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array3.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value2 = array3[index], computed = iteratee2 == null ? value2 : iteratee2(value2);
            value2 = comparator || value2 !== 0 ? value2 : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value2);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value2);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value2, index, collection2) {
          result2 = !!predicate(value2, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array3, iteratee2, comparator) {
        var index = -1, length = array3.length;
        while (++index < length) {
          var value2 = array3[index], current = iteratee2(value2);
          if (current != null && (computed === undefined4 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value2;
          }
        }
        return result2;
      }
      function baseFill(array3, value2, start, end) {
        var length = array3.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined4 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array3[start++] = value2;
        }
        return array3;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value2, index, collection2) {
          if (predicate(value2, index, collection2)) {
            result2.push(value2);
          }
        });
        return result2;
      }
      function baseFlatten(array3, depth, predicate, isStrict, result2) {
        var index = -1, length = array3.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value2 = array3[index];
          if (depth > 0 && predicate(value2)) {
            if (depth > 1) {
              baseFlatten(value2, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value2);
            }
          } else if (!isStrict) {
            result2[result2.length] = value2;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object3, iteratee2) {
        return object3 && baseFor(object3, iteratee2, keys);
      }
      function baseForOwnRight(object3, iteratee2) {
        return object3 && baseForRight(object3, iteratee2, keys);
      }
      function baseFunctions(object3, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object3[key]);
        });
      }
      function baseGet(object3, path) {
        path = castPath(path, object3);
        var index = 0, length = path.length;
        while (object3 != null && index < length) {
          object3 = object3[toKey(path[index++])];
        }
        return index && index == length ? object3 : undefined4;
      }
      function baseGetAllKeys(object3, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object3);
        return isArray(object3) ? result2 : arrayPush(result2, symbolsFunc(object3));
      }
      function baseGetTag(value2) {
        if (value2 == null) {
          return value2 === undefined4 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object3(value2) ? getRawTag(value2) : objectToString(value2);
      }
      function baseGt(value2, other) {
        return value2 > other;
      }
      function baseHas(object3, key) {
        return object3 != null && hasOwnProperty.call(object3, key);
      }
      function baseHasIn(object3, key) {
        return object3 != null && key in Object3(object3);
      }
      function baseInRange(number3, start, end) {
        return number3 >= nativeMin(start, end) && number3 < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array3(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array3 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array3 = arrayMap(array3, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array3.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array3.length >= 120) ? new SetCache(othIndex && array3) : undefined4;
        }
        array3 = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value2 = array3[index], computed = iteratee2 ? iteratee2(value2) : value2;
            value2 = comparator || value2 !== 0 ? value2 : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value2);
            }
          }
        return result2;
      }
      function baseInverter(object3, setter, iteratee2, accumulator) {
        baseForOwn(object3, function(value2, key, object4) {
          setter(accumulator, iteratee2(value2), key, object4);
        });
        return accumulator;
      }
      function baseInvoke(object3, path, args) {
        path = castPath(path, object3);
        object3 = parent(object3, path);
        var func = object3 == null ? object3 : object3[toKey(last(path))];
        return func == null ? undefined4 : apply(func, object3, args);
      }
      function baseIsArguments(value2) {
        return isObjectLike2(value2) && baseGetTag(value2) == argsTag;
      }
      function baseIsArrayBuffer(value2) {
        return isObjectLike2(value2) && baseGetTag(value2) == arrayBufferTag;
      }
      function baseIsDate(value2) {
        return isObjectLike2(value2) && baseGetTag(value2) == dateTag;
      }
      function baseIsEqual(value2, other, bitmask, customizer, stack) {
        if (value2 === other) {
          return true;
        }
        if (value2 == null || other == null || !isObjectLike2(value2) && !isObjectLike2(other)) {
          return value2 !== value2 && other !== other;
        }
        return baseIsEqualDeep(value2, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object3, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object3), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object3), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object3)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return objIsArr || isTypedArray(object3) ? equalArrays(object3, other, bitmask, customizer, equalFunc, stack) : equalByTag(object3, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object3, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object3.value() : object3, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object3, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value2) {
        return isObjectLike2(value2) && getTag(value2) == mapTag;
      }
      function baseIsMatch(object3, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object3 == null) {
          return !length;
        }
        object3 = Object3(object3);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object3[data[0]] : !(data[0] in object3)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object3[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined4 && !(key in object3)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object3, source, stack);
            }
            if (!(result2 === undefined4 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value2) {
        if (!isObject3(value2) || isMasked(value2)) {
          return false;
        }
        var pattern2 = isFunction(value2) ? reIsNative : reIsHostCtor;
        return pattern2.test(toSource(value2));
      }
      function baseIsRegExp(value2) {
        return isObjectLike2(value2) && baseGetTag(value2) == regexpTag;
      }
      function baseIsSet(value2) {
        return isObjectLike2(value2) && getTag(value2) == setTag;
      }
      function baseIsTypedArray(value2) {
        return isObjectLike2(value2) && isLength(value2.length) && !!typedArrayTags[baseGetTag(value2)];
      }
      function baseIteratee(value2) {
        if (typeof value2 == "function") {
          return value2;
        }
        if (value2 == null) {
          return identity;
        }
        if (typeof value2 == "object") {
          return isArray(value2) ? baseMatchesProperty(value2[0], value2[1]) : baseMatches(value2);
        }
        return property(value2);
      }
      function baseKeys(object3) {
        if (!isPrototype(object3)) {
          return nativeKeys(object3);
        }
        var result2 = [];
        for (var key in Object3(object3)) {
          if (hasOwnProperty.call(object3, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object3) {
        if (!isObject3(object3)) {
          return nativeKeysIn(object3);
        }
        var isProto = isPrototype(object3), result2 = [];
        for (var key in object3) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object3, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value2, other) {
        return value2 < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array3(collection.length) : [];
        baseEach(collection, function(value2, key, collection2) {
          result2[++index] = iteratee2(value2, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object3) {
          return object3 === source || baseIsMatch(object3, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object3) {
          var objValue = get(object3, path);
          return objValue === undefined4 && objValue === srcValue ? hasIn(object3, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object3, source, srcIndex, customizer, stack) {
        if (object3 === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack);
          if (isObject3(srcValue)) {
            baseMergeDeep(object3, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object3, key), srcValue, key + "", object3, source, stack) : undefined4;
            if (newValue === undefined4) {
              newValue = srcValue;
            }
            assignMergeValue(object3, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object3, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object3, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object3, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object3, source, stack) : undefined4;
        var isCommon = newValue === undefined4;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject3(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object3, key, newValue);
      }
      function baseNth(array3, n) {
        var length = array3.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array3[n] : undefined4;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value2) {
                return baseGet(value2, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value2, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value2);
          });
          return { criteria, index: ++index, value: value2 };
        });
        return baseSortBy(result2, function(object3, other) {
          return compareMultiple(object3, other, orders);
        });
      }
      function basePick(object3, paths) {
        return basePickBy(object3, paths, function(value2, path) {
          return hasIn(object3, path);
        });
      }
      function basePickBy(object3, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path = paths[index], value2 = baseGet(object3, path);
          if (predicate(value2, path)) {
            baseSet(result2, castPath(path, object3), value2);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object3) {
          return baseGet(object3, path);
        };
      }
      function basePullAll(array3, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array3;
        if (array3 === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array3, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value2 = values2[index], computed = iteratee2 ? iteratee2(value2) : value2;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array3) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array3, fromIndex, 1);
          }
        }
        return array3;
      }
      function basePullAt(array3, indexes) {
        var length = array3 ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array3, index, 1);
            } else {
              baseUnset(array3, index);
            }
          }
        }
        return array3;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array3(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string3, n) {
        var result2 = "";
        if (!string3 || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string3;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string3 += string3;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array3 = values(collection);
        return shuffleSelf(array3, baseClamp(n, 0, array3.length));
      }
      function baseSet(object3, path, value2, customizer) {
        if (!isObject3(object3)) {
          return object3;
        }
        path = castPath(path, object3);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object3;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value2;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object3;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined4;
            if (newValue === undefined4) {
              newValue = isObject3(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object3;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string3) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string3),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array3, start, end) {
        var index = -1, length = array3.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array3(length);
        while (++index < length) {
          result2[index] = array3[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value2, index, collection2) {
          result2 = predicate(value2, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array3, value2, retHighest) {
        var low = 0, high = array3 == null ? low : array3.length;
        if (typeof value2 == "number" && value2 === value2 && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array3[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value2 : computed < value2)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array3, value2, identity, retHighest);
      }
      function baseSortedIndexBy(array3, value2, iteratee2, retHighest) {
        var low = 0, high = array3 == null ? 0 : array3.length;
        if (high === 0) {
          return 0;
        }
        value2 = iteratee2(value2);
        var valIsNaN = value2 !== value2, valIsNull = value2 === null, valIsSymbol = isSymbol(value2), valIsUndefined = value2 === undefined4;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array3[mid]), othIsDefined = computed !== undefined4, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value2 : computed < value2;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array3, iteratee2) {
        var index = -1, length = array3.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value2 = array3[index], computed = iteratee2 ? iteratee2(value2) : value2;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value2 === 0 ? 0 : value2;
          }
        }
        return result2;
      }
      function baseToNumber(value2) {
        if (typeof value2 == "number") {
          return value2;
        }
        if (isSymbol(value2)) {
          return NAN;
        }
        return +value2;
      }
      function baseToString(value2) {
        if (typeof value2 == "string") {
          return value2;
        }
        if (isArray(value2)) {
          return arrayMap(value2, baseToString) + "";
        }
        if (isSymbol(value2)) {
          return symbolToString ? symbolToString.call(value2) : "";
        }
        var result2 = value2 + "";
        return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array3, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array3.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set4 = iteratee2 ? null : createSet(array3);
          if (set4) {
            return setToArray(set4);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache;
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value2 = array3[index], computed = iteratee2 ? iteratee2(value2) : value2;
            value2 = comparator || value2 !== 0 ? value2 : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value2);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value2);
            }
          }
        return result2;
      }
      function baseUnset(object3, path) {
        path = castPath(path, object3);
        object3 = parent(object3, path);
        return object3 == null || delete object3[toKey(last(path))];
      }
      function baseUpdate(object3, path, updater, customizer) {
        return baseSet(object3, path, updater(baseGet(object3, path)), customizer);
      }
      function baseWhile(array3, predicate, isDrop, fromRight) {
        var length = array3.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array3[index], index, array3)) {
        }
        return isDrop ? baseSlice(array3, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array3, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value2, actions) {
        var result2 = value2;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array3(length);
        while (++index < length) {
          var array3 = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array3, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value2 = index < valsLength ? values2[index] : undefined4;
          assignFunc(result2, props[index], value2);
        }
        return result2;
      }
      function castArrayLikeObject(value2) {
        return isArrayLikeObject(value2) ? value2 : [];
      }
      function castFunction(value2) {
        return typeof value2 == "function" ? value2 : identity;
      }
      function castPath(value2, object3) {
        if (isArray(value2)) {
          return value2;
        }
        return isKey(value2, object3) ? [value2] : stringToPath(toString(value2));
      }
      var castRest = baseRest;
      function castSlice(array3, start, end) {
        var length = array3.length;
        end = end === undefined4 ? length : end;
        return !start && end >= length ? array3 : baseSlice(array3, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array3(result2).set(new Uint8Array3(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp3) {
        var result2 = new regexp3.constructor(regexp3.source, reFlags.exec(regexp3));
        result2.lastIndex = regexp3.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol3) {
        return symbolValueOf ? Object3(symbolValueOf.call(symbol3)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value2, other) {
        if (value2 !== other) {
          var valIsDefined = value2 !== undefined4, valIsNull = value2 === null, valIsReflexive = value2 === value2, valIsSymbol = isSymbol(value2);
          var othIsDefined = other !== undefined4, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value2 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value2 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object3, other, orders) {
        var index = -1, objCriteria = object3.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object3.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array3(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array3(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array3) {
        var index = -1, length = source.length;
        array3 || (array3 = Array3(length));
        while (++index < length) {
          array3[index] = source[index];
        }
        return array3;
      }
      function copyObject(source, props, object3, customizer) {
        var isNew = !object3;
        object3 || (object3 = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object3[key], source[key], key, object3, source) : undefined4;
          if (newValue === undefined4) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object3, key, newValue);
          } else {
            assignValue(object3, key, newValue);
          }
        }
        return object3;
      }
      function copySymbols(source, object3) {
        return copyObject(source, getSymbols(source), object3);
      }
      function copySymbolsIn(source, object3) {
        return copyObject(source, getSymbolsIn(source), object3);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object3, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined4, guard4 = length > 2 ? sources[2] : undefined4;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined4;
          if (guard4 && isIterateeCall(sources[0], sources[1], guard4)) {
            customizer = length < 3 ? undefined4 : customizer;
            length = 1;
          }
          object3 = Object3(object3);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object3, source, index, customizer);
            }
          }
          return object3;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object3(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object3, iteratee2, keysFunc) {
          var index = -1, iterable = Object3(object3), props = keysFunc(object3), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object3;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string3) {
          string3 = toString(string3);
          var strSymbols = hasUnicode(string3) ? stringToArray(string3) : undefined4;
          var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string3) {
          return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor;
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject3(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array3(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined4, args, holders, undefined4, undefined4, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object3(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined4;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined4;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value2 = args[0];
            if (wrapper && args.length == 1 && isArray(value2)) {
              return wrapper.plant(value2).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value2;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined4 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array3(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object3, iteratee2) {
          return baseInverter(object3, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value2, other) {
          var result2;
          if (value2 === undefined4 && other === undefined4) {
            return defaultValue;
          }
          if (value2 !== undefined4) {
            result2 = value2;
          }
          if (other !== undefined4) {
            if (result2 === undefined4) {
              return other;
            }
            if (typeof value2 == "string" || typeof other == "string") {
              value2 = baseToString(value2);
              other = baseToString(other);
            } else {
              value2 = baseToNumber(value2);
              other = baseToNumber(other);
            }
            result2 = operator(value2, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined4 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array3(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined4;
          }
          start = toFinite(start);
          if (end === undefined4) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined4 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value2, other) {
          if (!(typeof value2 == "string" && typeof other == "string")) {
            value2 = toNumber(value2);
            other = toNumber(other);
          }
          return operator(value2, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined4, newHoldersRight = isCurry ? undefined4 : holders, newPartials = isCurry ? partials : undefined4, newPartialsRight = isCurry ? undefined4 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined4, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number3, precision) {
          number3 = toNumber(number3);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number3)) {
            var pair = (toString(number3) + "e").split("e"), value2 = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value2) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number3);
        };
      }
      var createSet = !(Set5 && 1 / setToArray(new Set5([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set5(values2);
      };
      function createToPairs(keysFunc) {
        return function(object3) {
          var tag = getTag(object3);
          if (tag == mapTag) {
            return mapToArray(object3);
          }
          if (tag == setTag) {
            return setToPairs(object3);
          }
          return baseToPairs(object3, keysFunc(object3));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined4;
        }
        ary2 = ary2 === undefined4 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined4 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined4;
        }
        var data = isBindKey ? undefined4 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined4 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined4, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object3) {
        if (objValue === undefined4 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object3, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object3, source, stack) {
        if (isObject3(objValue) && isObject3(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined4, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value2) {
        return isPlainObject(value2) ? undefined4 : value2;
      }
      function equalArrays(array3, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array3.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array3);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array3;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined4;
        stack.set(array3, other);
        stack.set(other, array3);
        while (++index < arrLength) {
          var arrValue = array3[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array3, stack) : customizer(arrValue, othValue, index, array3, other, stack);
          }
          if (compared !== undefined4) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array3);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object3, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object3.byteLength != other.byteLength || object3.byteOffset != other.byteOffset) {
              return false;
            }
            object3 = object3.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object3.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object3), new Uint8Array3(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object3, +other);
          case errorTag:
            return object3.name == other.name && object3.message == other.message;
          case regexpTag:
          case stringTag:
            return object3 == other + "";
          case mapTag:
            var convert3 = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert3 || (convert3 = setToArray);
            if (object3.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object3);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object3, other);
            var result2 = equalArrays(convert3(object3), convert3(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object3);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object3) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object3, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object3), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object3);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object3;
        }
        var result2 = true;
        stack.set(object3, other);
        stack.set(other, object3);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object3[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object3, stack) : customizer(objValue, othValue, key, object3, other, stack);
          }
          if (!(compared === undefined4 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object3.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && (("constructor" in object3) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object3);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined4, flatten), func + "");
      }
      function getAllKeys(object3) {
        return baseGetAllKeys(object3, keys, getSymbols);
      }
      function getAllKeysIn(object3) {
        return baseGetAllKeys(object3, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array3 = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array3.length : 0;
        while (length--) {
          var data = array3[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object3 = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object3.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map4, key) {
        var data = map4.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object3) {
        var result2 = keys(object3), length = result2.length;
        while (length--) {
          var key = result2[length], value2 = object3[key];
          result2[length] = [key, value2, isStrictComparable(value2)];
        }
        return result2;
      }
      function getNative(object3, key) {
        var value2 = getValue(object3, key);
        return baseIsNative(value2) ? value2 : undefined4;
      }
      function getRawTag(value2) {
        var isOwn = hasOwnProperty.call(value2, symToStringTag), tag = value2[symToStringTag];
        try {
          value2[symToStringTag] = undefined4;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value2);
        if (unmasked) {
          if (isOwn) {
            value2[symToStringTag] = tag;
          } else {
            delete value2[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object3) {
        if (object3 == null) {
          return [];
        }
        object3 = Object3(object3);
        return arrayFilter(nativeGetSymbols(object3), function(symbol3) {
          return propertyIsEnumerable.call(object3, symbol3);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object3) {
        var result2 = [];
        while (object3) {
          arrayPush(result2, getSymbols(object3));
          object3 = getPrototype(object3);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise3 && getTag(Promise3.resolve()) != promiseTag || Set5 && getTag(new Set5) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
        getTag = function(value2) {
          var result2 = baseGetTag(value2), Ctor = result2 == objectTag ? value2.constructor : undefined4, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { start, end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object3, path, hasFunc) {
        path = castPath(path, object3);
        var index = -1, length = path.length, result2 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result2 = object3 != null && hasFunc(object3, key))) {
            break;
          }
          object3 = object3[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object3 == null ? 0 : object3.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object3) || isArguments(object3));
      }
      function initCloneArray(array3) {
        var length = array3.length, result2 = new array3.constructor(length);
        if (length && typeof array3[0] == "string" && hasOwnProperty.call(array3, "index")) {
          result2.index = array3.index;
          result2.input = array3.input;
        }
        return result2;
      }
      function initCloneObject(object3) {
        return typeof object3.constructor == "function" && !isPrototype(object3) ? baseCreate(getPrototype(object3)) : {};
      }
      function initCloneByTag(object3, tag, isDeep) {
        var Ctor = object3.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object3);
          case boolTag:
          case dateTag:
            return new Ctor(+object3);
          case dataViewTag:
            return cloneDataView(object3, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object3, isDeep);
          case mapTag:
            return new Ctor;
          case numberTag:
          case stringTag:
            return new Ctor(object3);
          case regexpTag:
            return cloneRegExp(object3);
          case setTag:
            return new Ctor;
          case symbolTag:
            return cloneSymbol(object3);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value2) {
        return isArray(value2) || isArguments(value2) || !!(spreadableSymbol && value2 && value2[spreadableSymbol]);
      }
      function isIndex(value2, length) {
        var type3 = typeof value2;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value2)) && (value2 > -1 && value2 % 1 == 0 && value2 < length);
      }
      function isIterateeCall(value2, index, object3) {
        if (!isObject3(object3)) {
          return false;
        }
        var type3 = typeof index;
        if (type3 == "number" ? isArrayLike(object3) && isIndex(index, object3.length) : type3 == "string" && (index in object3)) {
          return eq(object3[index], value2);
        }
        return false;
      }
      function isKey(value2, object3) {
        if (isArray(value2)) {
          return false;
        }
        var type3 = typeof value2;
        if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value2 == null || isSymbol(value2)) {
          return true;
        }
        return reIsPlainProp.test(value2) || !reIsDeepProp.test(value2) || object3 != null && value2 in Object3(object3);
      }
      function isKeyable(value2) {
        var type3 = typeof value2;
        return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value2 !== "__proto__" : value2 === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value2) {
        var Ctor = value2 && value2.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value2 === proto;
      }
      function isStrictComparable(value2) {
        return value2 === value2 && !isObject3(value2);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object3) {
          if (object3 == null) {
            return false;
          }
          return object3[key] === srcValue && (srcValue !== undefined4 || (key in Object3(object3)));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value2 = source[3];
        if (value2) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value2, source[4]) : value2;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value2 = source[5];
        if (value2) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value2, source[6]) : value2;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value2 = source[7];
        if (value2) {
          data[7] = value2;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object3) {
        var result2 = [];
        if (object3 != null) {
          for (var key in Object3(object3)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value2) {
        return nativeObjectToString.call(value2);
      }
      function overRest(func, start, transform5) {
        start = nativeMax(start === undefined4 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array3 = Array3(length);
          while (++index < length) {
            array3[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array3(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform5(array3);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object3, path) {
        return path.length < 2 ? object3 : baseGet(object3, baseSlice(path, 0, -1));
      }
      function reorder(array3, indexes) {
        var arrLength = array3.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array3);
        while (length--) {
          var index = indexes[length];
          array3[length] = isIndex(index, arrLength) ? oldArray[index] : undefined4;
        }
        return array3;
      }
      function safeGet(object3, key) {
        if (key === "constructor" && typeof object3[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object3[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined4, arguments);
        };
      }
      function shuffleSelf(array3, size2) {
        var index = -1, length = array3.length, lastIndex = length - 1;
        size2 = size2 === undefined4 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value2 = array3[rand];
          array3[rand] = array3[index];
          array3[index] = value2;
        }
        array3.length = size2;
        return array3;
      }
      var stringToPath = memoizeCapped(function(string3) {
        var result2 = [];
        if (string3.charCodeAt(0) === 46) {
          result2.push("");
        }
        string3.replace(rePropName, function(match, number3, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
        });
        return result2;
      });
      function toKey(value2) {
        if (typeof value2 == "string" || isSymbol(value2)) {
          return value2;
        }
        var result2 = value2 + "";
        return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value2 = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value2)) {
            details.push(value2);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array3, size2, guard4) {
        if (guard4 ? isIterateeCall(array3, size2, guard4) : size2 === undefined4) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array3 == null ? 0 : array3.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array3(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array3, index, index += size2);
        }
        return result2;
      }
      function compact(array3) {
        var index = -1, length = array3 == null ? 0 : array3.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value2 = array3[index];
          if (value2) {
            result2[resIndex++] = value2;
          }
        }
        return result2;
      }
      function concat2() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array3(length - 1), array3 = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array3) ? copyArray(array3) : [array3], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array3, values2) {
        return isArrayLikeObject(array3) ? baseDifference(array3, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array3, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined4;
        }
        return isArrayLikeObject(array3) ? baseDifference(array3, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array3, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined4;
        }
        return isArrayLikeObject(array3) ? baseDifference(array3, baseFlatten(values2, 1, isArrayLikeObject, true), undefined4, comparator) : [];
      });
      function drop(array3, n, guard4) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        n = guard4 || n === undefined4 ? 1 : toInteger(n);
        return baseSlice(array3, n < 0 ? 0 : n, length);
      }
      function dropRight(array3, n, guard4) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        n = guard4 || n === undefined4 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array3, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array3, predicate) {
        return array3 && array3.length ? baseWhile(array3, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array3, predicate) {
        return array3 && array3.length ? baseWhile(array3, getIteratee(predicate, 3), true) : [];
      }
      function fill(array3, value2, start, end) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array3, value2, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array3, value2, start, end);
      }
      function findIndex(array3, predicate, fromIndex) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array3, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array3, predicate, fromIndex) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined4) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array3, getIteratee(predicate, 3), index, true);
      }
      function flatten(array3) {
        var length = array3 == null ? 0 : array3.length;
        return length ? baseFlatten(array3, 1) : [];
      }
      function flattenDeep(array3) {
        var length = array3 == null ? 0 : array3.length;
        return length ? baseFlatten(array3, INFINITY) : [];
      }
      function flattenDepth(array3, depth) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined4 ? 1 : toInteger(depth);
        return baseFlatten(array3, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array3) {
        return array3 && array3.length ? array3[0] : undefined4;
      }
      function indexOf(array3, value2, fromIndex) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array3, value2, index);
      }
      function initial(array3) {
        var length = array3 == null ? 0 : array3.length;
        return length ? baseSlice(array3, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped3 = arrayMap(arrays, castArrayLikeObject);
        return mapped3.length && mapped3[0] === arrays[0] ? baseIntersection(mapped3) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped3 = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped3)) {
          iteratee2 = undefined4;
        } else {
          mapped3.pop();
        }
        return mapped3.length && mapped3[0] === arrays[0] ? baseIntersection(mapped3, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped3 = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined4;
        if (comparator) {
          mapped3.pop();
        }
        return mapped3.length && mapped3[0] === arrays[0] ? baseIntersection(mapped3, undefined4, comparator) : [];
      });
      function join(array3, separator) {
        return array3 == null ? "" : nativeJoin.call(array3, separator);
      }
      function last(array3) {
        var length = array3 == null ? 0 : array3.length;
        return length ? array3[length - 1] : undefined4;
      }
      function lastIndexOf(array3, value2, fromIndex) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined4) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value2 === value2 ? strictLastIndexOf(array3, value2, index) : baseFindIndex(array3, baseIsNaN, index, true);
      }
      function nth(array3, n) {
        return array3 && array3.length ? baseNth(array3, toInteger(n)) : undefined4;
      }
      var pull = baseRest(pullAll);
      function pullAll(array3, values2) {
        return array3 && array3.length && values2 && values2.length ? basePullAll(array3, values2) : array3;
      }
      function pullAllBy(array3, values2, iteratee2) {
        return array3 && array3.length && values2 && values2.length ? basePullAll(array3, values2, getIteratee(iteratee2, 2)) : array3;
      }
      function pullAllWith(array3, values2, comparator) {
        return array3 && array3.length && values2 && values2.length ? basePullAll(array3, values2, undefined4, comparator) : array3;
      }
      var pullAt = flatRest(function(array3, indexes) {
        var length = array3 == null ? 0 : array3.length, result2 = baseAt(array3, indexes);
        basePullAt(array3, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array3, predicate) {
        var result2 = [];
        if (!(array3 && array3.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array3.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value2 = array3[index];
          if (predicate(value2, index, array3)) {
            result2.push(value2);
            indexes.push(index);
          }
        }
        basePullAt(array3, indexes);
        return result2;
      }
      function reverse(array3) {
        return array3 == null ? array3 : nativeReverse.call(array3);
      }
      function slice(array3, start, end) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array3, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined4 ? length : toInteger(end);
        }
        return baseSlice(array3, start, end);
      }
      function sortedIndex(array3, value2) {
        return baseSortedIndex(array3, value2);
      }
      function sortedIndexBy(array3, value2, iteratee2) {
        return baseSortedIndexBy(array3, value2, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array3, value2) {
        var length = array3 == null ? 0 : array3.length;
        if (length) {
          var index = baseSortedIndex(array3, value2);
          if (index < length && eq(array3[index], value2)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array3, value2) {
        return baseSortedIndex(array3, value2, true);
      }
      function sortedLastIndexBy(array3, value2, iteratee2) {
        return baseSortedIndexBy(array3, value2, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array3, value2) {
        var length = array3 == null ? 0 : array3.length;
        if (length) {
          var index = baseSortedIndex(array3, value2, true) - 1;
          if (eq(array3[index], value2)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array3) {
        return array3 && array3.length ? baseSortedUniq(array3) : [];
      }
      function sortedUniqBy(array3, iteratee2) {
        return array3 && array3.length ? baseSortedUniq(array3, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array3) {
        var length = array3 == null ? 0 : array3.length;
        return length ? baseSlice(array3, 1, length) : [];
      }
      function take(array3, n, guard4) {
        if (!(array3 && array3.length)) {
          return [];
        }
        n = guard4 || n === undefined4 ? 1 : toInteger(n);
        return baseSlice(array3, 0, n < 0 ? 0 : n);
      }
      function takeRight(array3, n, guard4) {
        var length = array3 == null ? 0 : array3.length;
        if (!length) {
          return [];
        }
        n = guard4 || n === undefined4 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array3, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array3, predicate) {
        return array3 && array3.length ? baseWhile(array3, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array3, predicate) {
        return array3 && array3.length ? baseWhile(array3, getIteratee(predicate, 3)) : [];
      }
      var union4 = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined4;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined4;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined4, comparator);
      });
      function uniq(array3) {
        return array3 && array3.length ? baseUniq(array3) : [];
      }
      function uniqBy(array3, iteratee2) {
        return array3 && array3.length ? baseUniq(array3, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array3, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined4;
        return array3 && array3.length ? baseUniq(array3, undefined4, comparator) : [];
      }
      function unzip(array3) {
        if (!(array3 && array3.length)) {
          return [];
        }
        var length = 0;
        array3 = arrayFilter(array3, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array3, baseProperty(index));
        });
      }
      function unzipWith(array3, iteratee2) {
        if (!(array3 && array3.length)) {
          return [];
        }
        var result2 = unzip(array3);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined4, group);
        });
      }
      var without = baseRest(function(array3, values2) {
        return isArrayLikeObject(array3) ? baseDifference(array3, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined4;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined4;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined4, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined4;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined4;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value2) {
        var result2 = lodash(value2);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value2, interceptor) {
        interceptor(value2);
        return value2;
      }
      function thru(value2, interceptor) {
        return interceptor(value2);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value2 = this.__wrapped__, interceptor = function(object3) {
          return baseAt(object3, paths);
        };
        if (length > 1 || this.__actions__.length || !(value2 instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value2 = value2.slice(start, +start + (length ? 1 : 0));
        value2.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined4
        });
        return new LodashWrapper(value2, this.__chain__).thru(function(array3) {
          if (length && !array3.length) {
            array3.push(undefined4);
          }
          return array3;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined4) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value2 = done ? undefined4 : this.__values__[this.__index__++];
        return { done, value: value2 };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value2) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone5 = wrapperClone(parent2);
          clone5.__index__ = 0;
          clone5.__values__ = undefined4;
          if (result2) {
            previous.__wrapped__ = clone5;
          } else {
            result2 = clone5;
          }
          var previous = clone5;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value2;
        return result2;
      }
      function wrapperReverse() {
        var value2 = this.__wrapped__;
        if (value2 instanceof LazyWrapper) {
          var wrapped = value2;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined4
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value2, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard4) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard4 && isIterateeCall(collection, predicate, guard4)) {
          predicate = undefined4;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map3(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map3(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined4 ? 1 : toInteger(depth);
        return baseFlatten(map3(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value2, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value2);
        } else {
          baseAssignValue(result2, key, [value2]);
        }
      });
      function includes(collection, value2, fromIndex, guard4) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard4 ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value2, fromIndex) > -1 : !!length && baseIndexOf(collection, value2, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array3(collection.length) : [];
        baseEach(collection, function(value2) {
          result2[++index] = isFunc ? apply(path, value2, args) : baseInvoke(value2, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value2, key) {
        baseAssignValue(result2, key, value2);
      });
      function map3(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard4) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard4 ? undefined4 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition2 = createAggregator(function(result2, value2, key) {
        result2[key ? 0 : 1].push(value2);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard4) {
        if (guard4 ? isIterateeCall(collection, n, guard4) : n === undefined4) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard4) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard4 && isIterateeCall(collection, predicate, guard4)) {
          predicate = undefined4;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard4) {
        n = guard4 ? undefined4 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined4, undefined4, undefined4, undefined4, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined4;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object3, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object3, partials, holders);
      });
      function curry(func, arity, guard4) {
        arity = guard4 ? undefined4 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined4, undefined4, undefined4, undefined4, undefined4, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard4) {
        arity = guard4 ? undefined4 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined4, undefined4, undefined4, undefined4, undefined4, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject3(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined4;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined4 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined4;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined4;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined4) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined4;
        }
        function flush() {
          return timerId === undefined4 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined4) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined4) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial3 = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial3));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined4, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined4, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined4, undefined4, undefined4, indexes);
      });
      function rest3(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined4 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array3 = args[start], otherArgs = castSlice(args, 0, start);
          if (array3) {
            arrayPush(otherArgs, array3);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject3(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value2, wrapper) {
        return partial3(castFunction(wrapper), value2);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value2 = arguments[0];
        return isArray(value2) ? value2 : [value2];
      }
      function clone4(value2) {
        return baseClone(value2, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined4;
        return baseClone(value2, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value2) {
        return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined4;
        return baseClone(value2, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object3, source) {
        return source == null || baseConformsTo(object3, source, keys(source));
      }
      function eq(value2, other) {
        return value2 === other || value2 !== value2 && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value2, other) {
        return value2 >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value2) {
        return isObjectLike2(value2) && hasOwnProperty.call(value2, "callee") && !propertyIsEnumerable.call(value2, "callee");
      };
      var isArray = Array3.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value2) {
        return value2 != null && isLength(value2.length) && !isFunction(value2);
      }
      function isArrayLikeObject(value2) {
        return isObjectLike2(value2) && isArrayLike(value2);
      }
      function isBoolean(value2) {
        return value2 === true || value2 === false || isObjectLike2(value2) && baseGetTag(value2) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value2) {
        return isObjectLike2(value2) && value2.nodeType === 1 && !isPlainObject(value2);
      }
      function isEmpty(value2) {
        if (value2 == null) {
          return true;
        }
        if (isArrayLike(value2) && (isArray(value2) || typeof value2 == "string" || typeof value2.splice == "function" || isBuffer(value2) || isTypedArray(value2) || isArguments(value2))) {
          return !value2.length;
        }
        var tag = getTag(value2);
        if (tag == mapTag || tag == setTag) {
          return !value2.size;
        }
        if (isPrototype(value2)) {
          return !baseKeys(value2).length;
        }
        for (var key in value2) {
          if (hasOwnProperty.call(value2, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value2, other) {
        return baseIsEqual(value2, other);
      }
      function isEqualWith(value2, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined4;
        var result2 = customizer ? customizer(value2, other) : undefined4;
        return result2 === undefined4 ? baseIsEqual(value2, other, undefined4, customizer) : !!result2;
      }
      function isError(value2) {
        if (!isObjectLike2(value2)) {
          return false;
        }
        var tag = baseGetTag(value2);
        return tag == errorTag || tag == domExcTag || typeof value2.message == "string" && typeof value2.name == "string" && !isPlainObject(value2);
      }
      function isFinite(value2) {
        return typeof value2 == "number" && nativeIsFinite(value2);
      }
      function isFunction(value2) {
        if (!isObject3(value2)) {
          return false;
        }
        var tag = baseGetTag(value2);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value2) {
        return typeof value2 == "number" && value2 == toInteger(value2);
      }
      function isLength(value2) {
        return typeof value2 == "number" && value2 > -1 && value2 % 1 == 0 && value2 <= MAX_SAFE_INTEGER;
      }
      function isObject3(value2) {
        var type3 = typeof value2;
        return value2 != null && (type3 == "object" || type3 == "function");
      }
      function isObjectLike2(value2) {
        return value2 != null && typeof value2 == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object3, source) {
        return object3 === source || baseIsMatch(object3, source, getMatchData(source));
      }
      function isMatchWith(object3, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined4;
        return baseIsMatch(object3, source, getMatchData(source), customizer);
      }
      function isNaN2(value2) {
        return isNumber(value2) && value2 != +value2;
      }
      function isNative(value2) {
        if (isMaskable(value2)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value2);
      }
      function isNull(value2) {
        return value2 === null;
      }
      function isNil(value2) {
        return value2 == null;
      }
      function isNumber(value2) {
        return typeof value2 == "number" || isObjectLike2(value2) && baseGetTag(value2) == numberTag;
      }
      function isPlainObject(value2) {
        if (!isObjectLike2(value2) || baseGetTag(value2) != objectTag) {
          return false;
        }
        var proto = getPrototype(value2);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value2) {
        return isInteger(value2) && value2 >= -MAX_SAFE_INTEGER && value2 <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value2) {
        return typeof value2 == "string" || !isArray(value2) && isObjectLike2(value2) && baseGetTag(value2) == stringTag;
      }
      function isSymbol(value2) {
        return typeof value2 == "symbol" || isObjectLike2(value2) && baseGetTag(value2) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value2) {
        return value2 === undefined4;
      }
      function isWeakMap(value2) {
        return isObjectLike2(value2) && getTag(value2) == weakMapTag;
      }
      function isWeakSet(value2) {
        return isObjectLike2(value2) && baseGetTag(value2) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value2, other) {
        return value2 <= other;
      });
      function toArray(value2) {
        if (!value2) {
          return [];
        }
        if (isArrayLike(value2)) {
          return isString(value2) ? stringToArray(value2) : copyArray(value2);
        }
        if (symIterator && value2[symIterator]) {
          return iteratorToArray(value2[symIterator]());
        }
        var tag = getTag(value2), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value2);
      }
      function toFinite(value2) {
        if (!value2) {
          return value2 === 0 ? value2 : 0;
        }
        value2 = toNumber(value2);
        if (value2 === INFINITY || value2 === -INFINITY) {
          var sign2 = value2 < 0 ? -1 : 1;
          return sign2 * MAX_INTEGER;
        }
        return value2 === value2 ? value2 : 0;
      }
      function toInteger(value2) {
        var result2 = toFinite(value2), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value2) {
        return value2 ? baseClamp(toInteger(value2), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value2) {
        if (typeof value2 == "number") {
          return value2;
        }
        if (isSymbol(value2)) {
          return NAN;
        }
        if (isObject3(value2)) {
          var other = typeof value2.valueOf == "function" ? value2.valueOf() : value2;
          value2 = isObject3(other) ? other + "" : other;
        }
        if (typeof value2 != "string") {
          return value2 === 0 ? value2 : +value2;
        }
        value2 = baseTrim(value2);
        var isBinary = reIsBinary.test(value2);
        return isBinary || reIsOctal.test(value2) ? freeParseInt(value2.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value2) ? NAN : +value2;
      }
      function toPlainObject(value2) {
        return copyObject(value2, keysIn(value2));
      }
      function toSafeInteger(value2) {
        return value2 ? baseClamp(toInteger(value2), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value2 === 0 ? value2 : 0;
      }
      function toString(value2) {
        return value2 == null ? "" : baseToString(value2);
      }
      var assign = createAssigner(function(object3, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object3);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object3, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object3, source) {
        copyObject(source, keysIn(source), object3);
      });
      var assignInWith = createAssigner(function(object3, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object3, customizer);
      });
      var assignWith = createAssigner(function(object3, source, srcIndex, customizer) {
        copyObject(source, keys(source), object3, customizer);
      });
      var at = flatRest(baseAt);
      function create3(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object3, sources) {
        object3 = Object3(object3);
        var index = -1;
        var length = sources.length;
        var guard4 = length > 2 ? sources[2] : undefined4;
        if (guard4 && isIterateeCall(sources[0], sources[1], guard4)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value2 = object3[key];
            if (value2 === undefined4 || eq(value2, objectProto[key]) && !hasOwnProperty.call(object3, key)) {
              object3[key] = source[key];
            }
          }
        }
        return object3;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined4, customDefaultsMerge);
        return apply(mergeWith, undefined4, args);
      });
      function findKey(object3, predicate) {
        return baseFindKey(object3, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object3, predicate) {
        return baseFindKey(object3, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object3, iteratee2) {
        return object3 == null ? object3 : baseFor(object3, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object3, iteratee2) {
        return object3 == null ? object3 : baseForRight(object3, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object3, iteratee2) {
        return object3 && baseForOwn(object3, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object3, iteratee2) {
        return object3 && baseForOwnRight(object3, getIteratee(iteratee2, 3));
      }
      function functions(object3) {
        return object3 == null ? [] : baseFunctions(object3, keys(object3));
      }
      function functionsIn(object3) {
        return object3 == null ? [] : baseFunctions(object3, keysIn(object3));
      }
      function get(object3, path, defaultValue) {
        var result2 = object3 == null ? undefined4 : baseGet(object3, path);
        return result2 === undefined4 ? defaultValue : result2;
      }
      function has2(object3, path) {
        return object3 != null && hasPath(object3, path, baseHas);
      }
      function hasIn(object3, path) {
        return object3 != null && hasPath(object3, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value2, key) {
        if (value2 != null && typeof value2.toString != "function") {
          value2 = nativeObjectToString.call(value2);
        }
        result2[value2] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value2, key) {
        if (value2 != null && typeof value2.toString != "function") {
          value2 = nativeObjectToString.call(value2);
        }
        if (hasOwnProperty.call(result2, value2)) {
          result2[value2].push(key);
        } else {
          result2[value2] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object3) {
        return isArrayLike(object3) ? arrayLikeKeys(object3) : baseKeys(object3);
      }
      function keysIn(object3) {
        return isArrayLike(object3) ? arrayLikeKeys(object3, true) : baseKeysIn(object3);
      }
      function mapKeys(object3, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object3, function(value2, key, object4) {
          baseAssignValue(result2, iteratee2(value2, key, object4), value2);
        });
        return result2;
      }
      function mapValues(object3, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object3, function(value2, key, object4) {
          baseAssignValue(result2, key, iteratee2(value2, key, object4));
        });
        return result2;
      }
      var merge = createAssigner(function(object3, source, srcIndex) {
        baseMerge(object3, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object3, source, srcIndex, customizer) {
        baseMerge(object3, source, srcIndex, customizer);
      });
      var omit3 = flatRest(function(object3, paths) {
        var result2 = {};
        if (object3 == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object3);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object3, getAllKeysIn(object3), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object3, predicate) {
        return pickBy(object3, negate(getIteratee(predicate)));
      }
      var pick3 = flatRest(function(object3, paths) {
        return object3 == null ? {} : basePick(object3, paths);
      });
      function pickBy(object3, predicate) {
        if (object3 == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object3), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object3, props, function(value2, path) {
          return predicate(value2, path[0]);
        });
      }
      function result(object3, path, defaultValue) {
        path = castPath(path, object3);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object3 = undefined4;
        }
        while (++index < length) {
          var value2 = object3 == null ? undefined4 : object3[toKey(path[index])];
          if (value2 === undefined4) {
            index = length;
            value2 = defaultValue;
          }
          object3 = isFunction(value2) ? value2.call(object3) : value2;
        }
        return object3;
      }
      function set3(object3, path, value2) {
        return object3 == null ? object3 : baseSet(object3, path, value2);
      }
      function setWith(object3, path, value2, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined4;
        return object3 == null ? object3 : baseSet(object3, path, value2, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform4(object3, iteratee2, accumulator) {
        var isArr = isArray(object3), isArrLike = isArr || isBuffer(object3) || isTypedArray(object3);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object3 && object3.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
          } else if (isObject3(object3)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object3)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object3, function(value2, index, object4) {
          return iteratee2(accumulator, value2, index, object4);
        });
        return accumulator;
      }
      function unset(object3, path) {
        return object3 == null ? true : baseUnset(object3, path);
      }
      function update(object3, path, updater) {
        return object3 == null ? object3 : baseUpdate(object3, path, castFunction(updater));
      }
      function updateWith(object3, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined4;
        return object3 == null ? object3 : baseUpdate(object3, path, castFunction(updater), customizer);
      }
      function values(object3) {
        return object3 == null ? [] : baseValues(object3, keys(object3));
      }
      function valuesIn(object3) {
        return object3 == null ? [] : baseValues(object3, keysIn(object3));
      }
      function clamp(number3, lower, upper) {
        if (upper === undefined4) {
          upper = lower;
          lower = undefined4;
        }
        if (upper !== undefined4) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined4) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number3), lower, upper);
      }
      function inRange(number3, start, end) {
        start = toFinite(start);
        if (end === undefined4) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number3 = toNumber(number3);
        return baseInRange(number3, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined4;
        }
        if (floating === undefined4) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined4;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined4;
          }
        }
        if (lower === undefined4 && upper === undefined4) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined4) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize3(word) : word);
      });
      function capitalize3(string3) {
        return upperFirst(toString(string3).toLowerCase());
      }
      function deburr(string3) {
        string3 = toString(string3);
        return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string3, target, position) {
        string3 = toString(string3);
        target = baseToString(target);
        var length = string3.length;
        position = position === undefined4 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string3.slice(position, end) == target;
      }
      function escape(string3) {
        string3 = toString(string3);
        return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
      }
      function escapeRegExp(string3) {
        string3 = toString(string3);
        return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar, "\\$&") : string3;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string3, length, chars) {
        string3 = toString(string3);
        length = toInteger(length);
        var strLength = length ? stringSize(string3) : 0;
        if (!length || strLength >= length) {
          return string3;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string3 + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string3, length, chars) {
        string3 = toString(string3);
        length = toInteger(length);
        var strLength = length ? stringSize(string3) : 0;
        return length && strLength < length ? string3 + createPadding(length - strLength, chars) : string3;
      }
      function padStart(string3, length, chars) {
        string3 = toString(string3);
        length = toInteger(length);
        var strLength = length ? stringSize(string3) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string3 : string3;
      }
      function parseInt2(string3, radix, guard4) {
        if (guard4 || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string3).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string3, n, guard4) {
        if (guard4 ? isIterateeCall(string3, n, guard4) : n === undefined4) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string3), n);
      }
      function replace() {
        var args = arguments, string3 = toString(args[0]);
        return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string3, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string3, separator, limit)) {
          separator = limit = undefined4;
        }
        limit = limit === undefined4 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string3 = toString(string3);
        if (string3 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string3)) {
            return castSlice(stringToArray(string3), 0, limit);
          }
        }
        return string3.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string3, target, position) {
        string3 = toString(string3);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string3.length);
        target = baseToString(target);
        return string3.slice(position, position + target.length) == target;
      }
      function template(string3, options, guard4) {
        var settings = lodash.templateSettings;
        if (guard4 && isIterateeCall(string3, options, guard4)) {
          options = undefined4;
        }
        string3 = toString(string3);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp3((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string3.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string3.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\n" + "function print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function4(importsKeys, sourceURL + "return " + source).apply(undefined4, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value2) {
        return toString(value2).toLowerCase();
      }
      function toUpper(value2) {
        return toString(value2).toUpperCase();
      }
      function trim(string3, chars, guard4) {
        string3 = toString(string3);
        if (string3 && (guard4 || chars === undefined4)) {
          return baseTrim(string3);
        }
        if (!string3 || !(chars = baseToString(chars))) {
          return string3;
        }
        var strSymbols = stringToArray(string3), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string3, chars, guard4) {
        string3 = toString(string3);
        if (string3 && (guard4 || chars === undefined4)) {
          return string3.slice(0, trimmedEndIndex(string3) + 1);
        }
        if (!string3 || !(chars = baseToString(chars))) {
          return string3;
        }
        var strSymbols = stringToArray(string3), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string3, chars, guard4) {
        string3 = toString(string3);
        if (string3 && (guard4 || chars === undefined4)) {
          return string3.replace(reTrimStart, "");
        }
        if (!string3 || !(chars = baseToString(chars))) {
          return string3;
        }
        var strSymbols = stringToArray(string3), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string3, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject3(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string3 = toString(string3);
        var strLength = string3.length;
        if (hasUnicode(string3)) {
          var strSymbols = stringToArray(string3);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string3;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string3.slice(0, end);
        if (separator === undefined4) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string3.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp3(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined4 ? end : newEnd);
          }
        } else if (string3.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape2(string3) {
        string3 = toString(string3);
        return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string3, pattern2, guard4) {
        string3 = toString(string3);
        pattern2 = guard4 ? undefined4 : pattern2;
        if (pattern2 === undefined4) {
          return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
        }
        return string3.match(pattern2) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined4, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object3, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object3, key, bind(object3[key], object3));
        });
        return object3;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value2) {
        return function() {
          return value2;
        };
      }
      function defaultTo(value2, defaultValue) {
        return value2 == null || value2 !== value2 ? defaultValue : value2;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value2) {
        return value2;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object3) {
          return baseInvoke(object3, path, args);
        };
      });
      var methodOf = baseRest(function(object3, args) {
        return function(path) {
          return baseInvoke(object3, path, args);
        };
      });
      function mixin(object3, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject3(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object3;
          object3 = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject3(options) && ("chain" in options)) || !!options.chain, isFunc = isFunction(object3);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object3[methodName] = func;
          if (isFunc) {
            object3.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object3(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ func, args: arguments, thisArg: object3 });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object3, arrayPush([this.value()], arguments));
            };
          }
        });
        return object3;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object3) {
        return function(path) {
          return object3 == null ? undefined4 : baseGet(object3, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value2) {
        if (isArray(value2)) {
          return arrayMap(value2, toKey);
        }
        return isSymbol(value2) ? [value2] : copyArray(stringToPath(toString(value2)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array3) {
        return array3 && array3.length ? baseExtremum(array3, identity, baseGt) : undefined4;
      }
      function maxBy(array3, iteratee2) {
        return array3 && array3.length ? baseExtremum(array3, getIteratee(iteratee2, 2), baseGt) : undefined4;
      }
      function mean(array3) {
        return baseMean(array3, identity);
      }
      function meanBy(array3, iteratee2) {
        return baseMean(array3, getIteratee(iteratee2, 2));
      }
      function min(array3) {
        return array3 && array3.length ? baseExtremum(array3, identity, baseLt) : undefined4;
      }
      function minBy(array3, iteratee2) {
        return array3 && array3.length ? baseExtremum(array3, getIteratee(iteratee2, 2), baseLt) : undefined4;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array3) {
        return array3 && array3.length ? baseSum(array3, identity) : 0;
      }
      function sumBy(array3, iteratee2) {
        return array3 && array3.length ? baseSum(array3, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat2;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create3;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map3;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit3;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial3;
      lodash.partialRight = partialRight;
      lodash.partition = partition2;
      lodash.pick = pick3;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest3;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set3;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform4;
      lodash.unary = unary;
      lodash.union = union4;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize3;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone4;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has2;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject3;
      lodash.isObjectLike = isObjectLike2;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape2;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { chain: false });
      lodash.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined4 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type3 = index + 1, isFilter = type3 == LAZY_FILTER_FLAG || type3 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type: type3
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value2) {
          return baseInvoke(value2, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined4) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value2 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value2 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value2);
          var interceptor = function(value3) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value3], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value2 = onlyLazy ? value2 : new LazyWrapper(this);
            var result2 = func.apply(value2, args);
            result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined4 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value2 = this.value();
            return func.apply(isArray(value2) ? value2 : [], args);
          }
          return this[chainName](function(value3) {
            return func.apply(isArray(value3) ? value3 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ name: methodName, func: lodashFunc });
        }
      });
      realNames[createHybrid(undefined4, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined4
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _2 = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _2;
      define(function() {
        return _2;
      });
    } else if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(exports);
});

// node_modules/uuid/dist/max.js
var require_max = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = "00000000-0000-0000-0000-000000000000";
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = exports.default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function validate(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  var _default = exports.default = validate;
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function parse2(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var _default = exports.default = parse2;
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  exports.unsafeStringify = unsafeStringify;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }
  function stringify(arr, offset = 0) {
    const uuid = unsafeStringify(arr, offset);
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var _default = exports.default = stringify;
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _nodeCrypto = _interopRequireDefault(import.meta.require("crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      _nodeCrypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node;
    let clockseq = options.clockseq;
    if (!options._v6) {
      if (!node) {
        node = _nodeId;
      }
      if (clockseq == null) {
        clockseq = _clockseq;
      }
    }
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = [seedBytes[0], seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        if (!_nodeId && !options._v6) {
          node[0] |= 1;
          _nodeId = node;
        }
      }
      if (clockseq == null) {
        clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        if (_clockseq === undefined && !options._v6) {
          _clockseq = clockseq;
        }
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0;n < 6; ++n) {
      b[i + n] = node[n];
    }
    return buf || (0, _stringify.unsafeStringify)(b);
  }
  var _default = exports.default = v1;
});

// node_modules/uuid/dist/v1ToV6.js
var require_v1ToV6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v1ToV6;
  var _parse = _interopRequireDefault(require_parse());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v1ToV6(uuid) {
    const v1Bytes = typeof uuid === "string" ? (0, _parse.default)(uuid) : uuid;
    const v6Bytes = _v1ToV6(v1Bytes);
    return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v6Bytes) : v6Bytes;
  }
  function _v1ToV6(v1Bytes, randomize = false) {
    return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
  }
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.URL = exports.DNS = undefined;
  exports.default = v35;
  var _stringify = require_stringify();
  var _parse = _interopRequireDefault(require_parse());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function stringToBytes(str2) {
    str2 = unescape(encodeURIComponent(str2));
    const bytes = [];
    for (let i = 0;i < str2.length; ++i) {
      bytes.push(str2.charCodeAt(i));
    }
    return bytes;
  }
  var DNS = exports.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  var URL2 = exports.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  function v35(name, version2, hashfunc) {
    function generateUUID(value2, namespace, buf, offset) {
      var _namespace;
      if (typeof value2 === "string") {
        value2 = stringToBytes(value2);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (((_namespace = namespace) === null || _namespace === undefined ? undefined : _namespace.length) !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value2.length);
      bytes.set(namespace);
      bytes.set(value2, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(import.meta.require("crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function md5(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = exports.default = md5;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = exports.default = v3;
});

// node_modules/uuid/dist/native.js
var require_native = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(import.meta.require("crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var _default = exports.default = {
    randomUUID: _nodeCrypto.default.randomUUID
  };
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _native = _interopRequireDefault(require_native());
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v4(options, buf, offset) {
    if (_native.default.randomUUID && !buf && !options) {
      return _native.default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(rnds);
  }
  var _default = exports.default = v4;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _nodeCrypto = _interopRequireDefault(import.meta.require("crypto"));
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function sha1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _nodeCrypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = exports.default = sha1;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = exports.default = v5;
});

// node_modules/uuid/dist/v6.js
var require_v6 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v6;
  var _stringify = require_stringify();
  var _v = _interopRequireDefault(require_v1());
  var _v1ToV = _interopRequireDefault(require_v1ToV6());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v6(options = {}, buf, offset = 0) {
    let bytes = (0, _v.default)({
      ...options,
      _v6: true
    }, new Uint8Array(16));
    bytes = (0, _v1ToV.default)(bytes);
    if (buf) {
      for (let i = 0;i < 16; i++) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return (0, _stringify.unsafeStringify)(bytes);
  }
});

// node_modules/uuid/dist/v6ToV1.js
var require_v6ToV1 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = v6ToV1;
  var _parse = _interopRequireDefault(require_parse());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function v6ToV1(uuid) {
    const v6Bytes = typeof uuid === "string" ? (0, _parse.default)(uuid) : uuid;
    const v1Bytes = _v6ToV1(v6Bytes);
    return typeof uuid === "string" ? (0, _stringify.unsafeStringify)(v1Bytes) : v1Bytes;
  }
  function _v6ToV1(v6Bytes) {
    return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
  }
});

// node_modules/uuid/dist/v7.js
var require_v7 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = require_stringify();
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  var _seqLow = null;
  var _seqHigh = null;
  var _msecs = 0;
  function v7(options, buf, offset) {
    options = options || {};
    let i = buf && offset || 0;
    const b = buf || new Uint8Array(16);
    const rnds = options.random || (options.rng || _rng.default)();
    const msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let seq = options.seq !== undefined ? options.seq : null;
    let seqHigh = _seqHigh;
    let seqLow = _seqLow;
    if (msecs > _msecs && options.msecs === undefined) {
      _msecs = msecs;
      if (seq !== null) {
        seqHigh = null;
        seqLow = null;
      }
    }
    if (seq !== null) {
      if (seq > 2147483647) {
        seq = 2147483647;
      }
      seqHigh = seq >>> 19 & 4095;
      seqLow = seq & 524287;
    }
    if (seqHigh === null || seqLow === null) {
      seqHigh = rnds[6] & 127;
      seqHigh = seqHigh << 8 | rnds[7];
      seqLow = rnds[8] & 63;
      seqLow = seqLow << 8 | rnds[9];
      seqLow = seqLow << 5 | rnds[10] >>> 3;
    }
    if (msecs + 1e4 > _msecs && seq === null) {
      if (++seqLow > 524287) {
        seqLow = 0;
        if (++seqHigh > 4095) {
          seqHigh = 0;
          _msecs++;
        }
      }
    } else {
      _msecs = msecs;
    }
    _seqHigh = seqHigh;
    _seqLow = seqLow;
    b[i++] = _msecs / 1099511627776 & 255;
    b[i++] = _msecs / 4294967296 & 255;
    b[i++] = _msecs / 16777216 & 255;
    b[i++] = _msecs / 65536 & 255;
    b[i++] = _msecs / 256 & 255;
    b[i++] = _msecs & 255;
    b[i++] = seqHigh >>> 4 & 15 | 112;
    b[i++] = seqHigh & 255;
    b[i++] = seqLow >>> 13 & 63 | 128;
    b[i++] = seqLow >>> 5 & 255;
    b[i++] = seqLow << 3 & 255 | rnds[10] & 7;
    b[i++] = rnds[11];
    b[i++] = rnds[12];
    b[i++] = rnds[13];
    b[i++] = rnds[14];
    b[i++] = rnds[15];
    return buf || (0, _stringify.unsafeStringify)(b);
  }
  var _default = exports.default = v7;
});

// node_modules/uuid/dist/version.js
var require_version2 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
  function version2(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.slice(14, 15), 16);
  }
  var _default = exports.default = version2;
});

// node_modules/uuid/dist/index.js
var require_dist3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "MAX", {
    enumerable: true,
    get: function() {
      return _max.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v1ToV6", {
    enumerable: true,
    get: function() {
      return _v1ToV.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "v6", {
    enumerable: true,
    get: function() {
      return _v5.default;
    }
  });
  Object.defineProperty(exports, "v6ToV1", {
    enumerable: true,
    get: function() {
      return _v6ToV.default;
    }
  });
  Object.defineProperty(exports, "v7", {
    enumerable: true,
    get: function() {
      return _v6.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  var _max = _interopRequireDefault(require_max());
  var _nil = _interopRequireDefault(require_nil());
  var _parse = _interopRequireDefault(require_parse());
  var _stringify = _interopRequireDefault(require_stringify());
  var _v = _interopRequireDefault(require_v1());
  var _v1ToV = _interopRequireDefault(require_v1ToV6());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _v5 = _interopRequireDefault(require_v6());
  var _v6ToV = _interopRequireDefault(require_v6ToV1());
  var _v6 = _interopRequireDefault(require_v7());
  var _validate = _interopRequireDefault(require_validate());
  var _version = _interopRequireDefault(require_version2());
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : { default: e };
  }
});

// node_modules/@sinclair/typebox/build/esm/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && (Object.getPrototypeOf(value) === Object.prototype || Object.getPrototypeOf(value) === null);
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/esm/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    return TypeSystemPolicy2.AllowNaN ? IsNumber(value) : Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/esm/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => Set2,
  Has: () => Has,
  Get: () => Get,
  Entries: () => Entries,
  Delete: () => Delete,
  Clear: () => Clear
});
var map = new Map;
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
// node_modules/@sinclair/typebox/build/esm/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => Set3,
  Has: () => Has2,
  Get: () => Get2,
  Entries: () => Entries2,
  Delete: () => Delete2,
  Clear: () => Clear2
});
var map2 = new Map;
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
// node_modules/@sinclair/typebox/build/esm/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/esm/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/esm/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => IsUndefined2,
  IsUint8Array: () => IsUint8Array2,
  IsSymbol: () => IsSymbol2,
  IsString: () => IsString2,
  IsRegExp: () => IsRegExp,
  IsObject: () => IsObject2,
  IsNumber: () => IsNumber2,
  IsNull: () => IsNull2,
  IsIterator: () => IsIterator2,
  IsFunction: () => IsFunction2,
  IsDate: () => IsDate2,
  IsBoolean: () => IsBoolean2,
  IsBigInt: () => IsBigInt2,
  IsAsyncIterator: () => IsAsyncIterator2,
  IsArray: () => IsArray2
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/esm/type/clone/value.mjs
function ArrayType(value) {
  return value.map((value2) => Visit(value2));
}
function DateType(value) {
  return new Date(value.getTime());
}
function Uint8ArrayType(value) {
  return new Uint8Array(value);
}
function RegExpType(value) {
  return new RegExp(value.source, value.flags);
}
function ObjectType(value) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    result[key] = Visit(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    result[key] = Visit(value[key]);
  }
  return result;
}
function Visit(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
}
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/esm/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/esm/type/discard/discard.mjs
function DiscardKey(value, key) {
  const { [key]: _, ...rest } = value;
  return rest;
}
function Discard(value, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value);
}
// node_modules/@sinclair/typebox/build/esm/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/kind.mjs
function IsReadonly(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny(value) {
  return IsKindOf(value, "Any");
}
function IsArray3(value) {
  return IsKindOf(value, "Array");
}
function IsAsyncIterator3(value) {
  return IsKindOf(value, "AsyncIterator");
}
function IsBigInt3(value) {
  return IsKindOf(value, "BigInt");
}
function IsBoolean3(value) {
  return IsKindOf(value, "Boolean");
}
function IsConstructor(value) {
  return IsKindOf(value, "Constructor");
}
function IsDate3(value) {
  return IsKindOf(value, "Date");
}
function IsFunction3(value) {
  return IsKindOf(value, "Function");
}
function IsInteger2(value) {
  return IsKindOf(value, "Integer");
}
function IsIntersect(value) {
  return IsKindOf(value, "Intersect");
}
function IsIterator3(value) {
  return IsKindOf(value, "Iterator");
}
function IsKindOf(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteral(value) {
  return IsKindOf(value, "Literal");
}
function IsMappedKey(value) {
  return IsKindOf(value, "MappedKey");
}
function IsMappedResult(value) {
  return IsKindOf(value, "MappedResult");
}
function IsNever(value) {
  return IsKindOf(value, "Never");
}
function IsNot(value) {
  return IsKindOf(value, "Not");
}
function IsNull3(value) {
  return IsKindOf(value, "Null");
}
function IsNumber3(value) {
  return IsKindOf(value, "Number");
}
function IsObject3(value) {
  return IsKindOf(value, "Object");
}
function IsPromise2(value) {
  return IsKindOf(value, "Promise");
}
function IsRecord(value) {
  return IsKindOf(value, "Record");
}
function IsRef(value) {
  return IsKindOf(value, "Ref");
}
function IsRegExp2(value) {
  return IsKindOf(value, "RegExp");
}
function IsString3(value) {
  return IsKindOf(value, "String");
}
function IsSymbol3(value) {
  return IsKindOf(value, "Symbol");
}
function IsTemplateLiteral(value) {
  return IsKindOf(value, "TemplateLiteral");
}
function IsThis(value) {
  return IsKindOf(value, "This");
}
function IsTransform(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple(value) {
  return IsKindOf(value, "Tuple");
}
function IsUndefined3(value) {
  return IsKindOf(value, "Undefined");
}
function IsUnion(value) {
  return IsKindOf(value, "Union");
}
function IsUint8Array3(value) {
  return IsKindOf(value, "Uint8Array");
}
function IsUnknown(value) {
  return IsKindOf(value, "Unknown");
}
function IsUnsafe(value) {
  return IsKindOf(value, "Unsafe");
}
function IsVoid(value) {
  return IsKindOf(value, "Void");
}
function IsKind(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]);
}
function IsSchema(value) {
  return IsAny(value) || IsArray3(value) || IsBoolean3(value) || IsBigInt3(value) || IsAsyncIterator3(value) || IsConstructor(value) || IsDate3(value) || IsFunction3(value) || IsInteger2(value) || IsIntersect(value) || IsIterator3(value) || IsLiteral(value) || IsMappedKey(value) || IsMappedResult(value) || IsNever(value) || IsNot(value) || IsNull3(value) || IsNumber3(value) || IsObject3(value) || IsPromise2(value) || IsRecord(value) || IsRef(value) || IsRegExp2(value) || IsString3(value) || IsSymbol3(value) || IsTemplateLiteral(value) || IsThis(value) || IsTuple(value) || IsUndefined3(value) || IsUnion(value) || IsUint8Array3(value) || IsUnknown(value) || IsUnsafe(value) || IsVoid(value) || IsKind(value);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional.mjs
function RemoveOptional(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
}
function AddOptional(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
}
function OptionalWithFlag(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
}
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/optional/optional-from-mapped-result.mjs
function FromProperties(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional(P[K2], F);
  return Acc;
}
function FromMappedResult(R, F) {
  return FromProperties(R.properties, F);
}
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect-evaluated.mjs
function IsIntersectOptional(T) {
  return T.every((L) => IsOptional(L));
}
function RemoveOptionalFromType(T) {
  return Discard(T, [OptionalKind]);
}
function RemoveOptionalFromRest(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
}
function ResolveIntersect(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
}
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/esm/type/union/union-evaluated.mjs
function IsUnionOptional(T) {
  return T.some((L) => IsOptional(L));
}
function RemoveOptionalFromRest2(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
}
function RemoveOptionalFromType2(T) {
  return Discard(T, [OptionalKind]);
}
function ResolveUnion(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
}
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/parse.mjs
class TemplateLiteralParserError extends TypeBoxError {
}
function Unescape(pattern) {
  return pattern.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
}
function IsOpenParen(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
}
function IsCloseParen(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
}
function IsSeparator(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
}
function IsGroup(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
}
function InGroup(pattern) {
  return pattern.slice(1, pattern.length - 1);
}
function IsPrecedenceOr(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
}
function Or(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And(pattern) {
  function Group(value, index) {
    if (!IsOpenParen(value, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value.length; scan++) {
      if (IsOpenParen(value, scan))
        count += 1;
      if (IsCloseParen(value, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: Unescape(pattern) };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

// node_modules/@sinclair/typebox/build/esm/type/template-literal/finite.mjs
class TemplateLiteralFiniteError extends TypeBoxError {
}
function IsNumberExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/generate.mjs
class TemplateLiteralGenerateError extends TypeBoxError {
}
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}
// node_modules/@sinclair/typebox/build/esm/type/literal/literal.mjs
function Literal(value, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value,
    type: typeof value
  };
}
// node_modules/@sinclair/typebox/build/esm/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal2) => Literal(literal2.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/esm/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
// node_modules/@sinclair/typebox/build/esm/type/template-literal/pattern.mjs
class TemplateLiteralPatternError extends TypeBoxError {
}
function Escape(value) {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit2(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
}
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/esm/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern };
}
// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-property-keys.mjs
function FromTemplateLiteral(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
}
function FromUnion2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexPropertyKeys(L));
  return Acc;
}
function FromLiteral(T) {
  return [T.toString()];
}
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-result.mjs
function FromProperties2(T, P, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P)) {
    Acc[K2] = Index(T, IndexPropertyKeys(P[K2]), options);
  }
  return Acc;
}
function FromMappedResult2(T, R, options) {
  return FromProperties2(T, R.properties, options);
}
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed.mjs
function FromRest(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
}
function FromIntersectRest(T) {
  return T.filter((L) => !IsNever(L));
}
function FromIntersect(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
}
function FromUnionRest(T) {
  return T.some((L) => IsNever(L)) ? [] : T;
}
function FromUnion3(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
}
function FromTuple(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
}
function FromArray(T, K) {
  return K === "[number]" ? T : Never();
}
function FromProperty(T, K) {
  return K in T ? T[K] : Never();
}
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
function FromSchema(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
}
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/esm/type/indexed/indexed-from-mapped-key.mjs
function MappedIndexPropertyKey(T, K, options) {
  return { [K]: Index(T, [K], options) };
}
function MappedIndexPropertyKeys(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
}
function MappedIndexProperties(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
}
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/object/object.mjs
function _Object(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key of propertyKeys)
    clonedProperties[key] = CloneType(properties[key]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
}
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/esm/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly.mjs
function RemoveReadonly(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
}
function AddReadonly(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
}
function ReadonlyWithFlag(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
}
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/esm/type/readonly/readonly-from-mapped-result.mjs
function FromProperties3(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly(K[K2], F);
  return Acc;
}
function FromMappedResult3(R, F) {
  return FromProperties3(R.properties, F);
}
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/esm/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
}
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}
// node_modules/@sinclair/typebox/build/esm/type/mapped/mapped.mjs
function FromMappedResult4(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
}
function MappedKeyToKnownMappedResultProperties(K) {
  return { [K]: Literal(K) };
}
function MappedKeyToUnknownMappedResultProperties(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal(L);
  return Acc;
}
function MappedKeyToMappedResultProperties(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
}
function FromMappedKey(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
}
function FromRest2(K, T) {
  return T.map((L) => FromSchemaType(K, L));
}
function FromProperties4(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType(K, T[K2]);
  return Acc;
}
function FromSchemaType(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
}
function MappedFunctionReturnType(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType(L, T);
  return Acc;
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-keys.mjs
function FromRest3(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(KeyOfPropertyKeys(L));
  return Acc;
}
function FromIntersect2(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
}
function FromUnion4(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
}
function FromTuple2(T) {
  return T.map((_, I) => I.toString());
}
function FromArray2(_) {
  return ["[number]"];
}
function FromProperties5(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
var includePatternProperties = false;
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern2 = keys.map((key) => `(${key})`);
  return `^(${pattern2.join("|")})\$`;
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-from-mapped-result.mjs
function FromProperties6(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = KeyOf(K[K2], options);
  return Acc;
}
function FromMappedResult5(R, options) {
  return FromProperties6(R.properties, options);
}
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/keyof/keyof-property-entries.mjs
function KeyOfPropertyEntries(schema) {
  const keys = KeyOfPropertyKeys(schema);
  const schemas = IndexFromPropertyKeys(schema, keys);
  return keys.map((_, index) => [keys[index], schemas[index]]);
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-undefined.mjs
function Intersect2(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
}
function Union2(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
}
function Not(schema) {
  return !ExtendsUndefinedCheck(schema.not);
}
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/esm/errors/function.mjs
function DefaultErrorFunction(error2) {
  switch (error2.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error2.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error2.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error2.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error2.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error2.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error2.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error2.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error2.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error2.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error2.schema.const === "string" ? `'${error2.schema.const}'` : error2.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error2.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error2.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error2.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error2.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error2.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error2.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error2.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error2.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error2.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error2.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error2.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error2.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error2.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error2.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error2.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error2.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
var errorFunction = DefaultErrorFunction;
function GetErrorFunction() {
  return errorFunction;
}

// node_modules/@sinclair/typebox/build/esm/value/deref/deref.mjs
class TypeDereferenceError extends TypeBoxError {
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
function Resolve(schema, references) {
  const target = references.find((target2) => target2.$id === schema.$ref);
  if (target === undefined)
    throw new TypeDereferenceError(schema);
  return Deref(target, references);
}
function Deref(schema, references) {
  return schema[Kind] === "This" || schema[Kind] === "Ref" ? Resolve(schema, references) : schema;
}
// node_modules/@sinclair/typebox/build/esm/value/hash/hash.mjs
class ValueHashError extends TypeBoxError {
  constructor(value) {
    super(`Unable to hash value`);
    this.value = value;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
function* NumberToBytes(value) {
  const byteCount = value === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value >> 8 * (byteCount - 1 - i) & 255;
  }
}
function ArrayType2(value) {
  FNV1A64(ByteMarker.Array);
  for (const item of value) {
    Visit3(item);
  }
}
function BooleanType(value) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value ? 1 : 0);
}
function BigIntType(value) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function DateType2(value) {
  FNV1A64(ByteMarker.Date);
  Visit3(value.getTime());
}
function NullType(value) {
  FNV1A64(ByteMarker.Null);
}
function NumberType(value) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
}
function ObjectType2(value) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.getOwnPropertyNames(value).sort()) {
    Visit3(key);
    Visit3(value[key]);
  }
}
function StringType(value) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value.length; i++) {
    for (const byte of NumberToBytes(value.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
}
function SymbolType(value) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value.description);
}
function Uint8ArrayType2(value) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value.length; i++) {
    FNV1A64(value[i]);
  }
}
function UndefinedType(value) {
  return FNV1A64(ByteMarker.Undefined);
}
function Visit3(value) {
  if (IsArray(value))
    return ArrayType2(value);
  if (IsBoolean(value))
    return BooleanType(value);
  if (IsBigInt(value))
    return BigIntType(value);
  if (IsDate(value))
    return DateType2(value);
  if (IsNull(value))
    return NullType(value);
  if (IsNumber(value))
    return NumberType(value);
  if (IsStandardObject(value))
    return ObjectType2(value);
  if (IsString(value))
    return StringType(value);
  if (IsSymbol(value))
    return SymbolType(value);
  if (IsUint8Array(value))
    return Uint8ArrayType2(value);
  if (IsUndefined(value))
    return UndefinedType(value);
  throw new ValueHashError(value);
}
function FNV1A64(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
}
function Hash(value) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value);
  return Accumulator;
}
// node_modules/@sinclair/typebox/build/esm/errors/errors.mjs
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}
function EscapeKey(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined(value) {
  return value !== undefined;
}

class ValueErrorIterator {
  constructor(iterator2) {
    this.iterator = iterator2;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
function Create(errorType, schema, path, value) {
  return { type: errorType, schema, path, value, message: GetErrorFunction()({ errorType, path, schema, value }) };
}
function* FromAny(schema, references, path, value) {
}
function* FromArray3(schema, references, path, value) {
  if (!IsArray(value)) {
    return yield Create(ValueErrorType.Array, schema, path, value);
  }
  if (IsDefined(schema.minItems) && !(value.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value);
  }
  if (IsDefined(schema.maxItems) && !(value.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value);
  }
  for (let i = 0;i < value.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set3 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set3.has(hashed)) {
        return false;
      } else {
        set3.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2, index) => Visit4(containsSchema, references, `${path}${index}`, value2).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value);
  }
}
function* FromAsyncIterator(schema, references, path, value) {
  if (!IsAsyncIterator(value))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value);
}
function* FromBigInt(schema, references, path, value) {
  if (!IsBigInt(value))
    return yield Create(ValueErrorType.BigInt, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value);
  }
}
function* FromBoolean(schema, references, path, value) {
  if (!IsBoolean(value))
    yield Create(ValueErrorType.Boolean, schema, path, value);
}
function* FromConstructor(schema, references, path, value) {
  yield* Visit4(schema.returns, references, path, value.prototype);
}
function* FromDate(schema, references, path, value) {
  if (!IsDate(value))
    return yield Create(ValueErrorType.Date, schema, path, value);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value);
  }
}
function* FromFunction(schema, references, path, value) {
  if (!IsFunction(value))
    yield Create(ValueErrorType.Function, schema, path, value);
}
function* FromInteger(schema, references, path, value) {
  if (!IsInteger(value))
    return yield Create(ValueErrorType.Integer, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value);
  }
}
function* FromIntersect3(schema, references, path, value) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value) {
  if (!IsIterator(value))
    yield Create(ValueErrorType.Iterator, schema, path, value);
}
function* FromLiteral2(schema, references, path, value) {
  if (!(value === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value);
}
function* FromNever(schema, references, path, value) {
  yield Create(ValueErrorType.Never, schema, path, value);
}
function* FromNot(schema, references, path, value) {
  if (Visit4(schema.not, references, path, value).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value);
}
function* FromNull(schema, references, path, value) {
  if (!IsNull(value))
    yield Create(ValueErrorType.Null, schema, path, value);
}
function* FromNumber(schema, references, path, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return yield Create(ValueErrorType.Number, schema, path, value);
  if (IsDefined(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value);
  }
  if (IsDefined(schema.maximum) && !(value <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value);
  }
  if (IsDefined(schema.minimum) && !(value >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value);
  }
  if (IsDefined(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value);
  }
}
function* FromObject(schema, references, path, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value) {
  if (!IsPromise(value))
    yield Create(ValueErrorType.Promise, schema, path, value);
}
function* FromRecord(schema, references, path, value) {
  if (!TypeSystemPolicy.IsRecordLike(value))
    return yield Create(ValueErrorType.Object, schema, path, value);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value) {
  yield* Visit4(Deref(schema, references), references, path, value);
}
function* FromRegExp(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value);
  }
}
function* FromString(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  if (IsDefined(schema.minLength) && !(value.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value);
  }
  if (IsDefined(schema.maxLength) && !(value.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value) {
  if (!IsSymbol(value))
    yield Create(ValueErrorType.Symbol, schema, path, value);
}
function* FromTemplateLiteral2(schema, references, path, value) {
  if (!IsString(value))
    return yield Create(ValueErrorType.String, schema, path, value);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value);
  }
}
function* FromThis(schema, references, path, value) {
  yield* Visit4(Deref(schema, references), references, path, value);
}
function* FromTuple3(schema, references, path, value) {
  if (!IsArray(value))
    return yield Create(ValueErrorType.Tuple, schema, path, value);
  if (schema.items === undefined && !(value.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!(value.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value[i]);
  }
}
function* FromUndefined(schema, references, path, value) {
  if (!IsUndefined(value))
    yield Create(ValueErrorType.Undefined, schema, path, value);
}
function* FromUnion5(schema, references, path, value) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors = [...Visit4(subschema, references, path, value)];
    if (errors.length === 0)
      return;
    count += errors.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value);
  }
}
function* FromUint8Array(schema, references, path, value) {
  if (!IsUint8Array(value))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value);
  if (IsDefined(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value);
  }
  if (IsDefined(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value);
  }
}
function* FromUnknown(schema, references, path, value) {
}
function* FromVoid(schema, references, path, value) {
  if (!TypeSystemPolicy.IsVoidLike(value))
    yield Create(ValueErrorType.Void, schema, path, value);
}
function* FromKind(schema, references, path, value) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value))
    yield Create(ValueErrorType.Kind, schema, path, value);
}
function* Visit4(schema, references, path, value) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value);
    case "Date":
      return yield* FromDate(schema_, references_, path, value);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value);
    case "Never":
      return yield* FromNever(schema_, references_, path, value);
    case "Not":
      return yield* FromNot(schema_, references_, path, value);
    case "Null":
      return yield* FromNull(schema_, references_, path, value);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value);
    case "Object":
      return yield* FromObject(schema_, references_, path, value);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value);
    case "String":
      return yield* FromString(schema_, references_, path, value);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value);
    case "This":
      return yield* FromThis(schema_, references_, path, value);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value);
  }
}
function Errors(...args) {
  const iterator2 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator2);
}
// node_modules/@sinclair/typebox/build/esm/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/esm/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/guard/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError,
  IsVoid: () => IsVoid2,
  IsUnsafe: () => IsUnsafe2,
  IsUnknown: () => IsUnknown2,
  IsUnionLiteral: () => IsUnionLiteral,
  IsUnion: () => IsUnion2,
  IsUndefined: () => IsUndefined4,
  IsUint8Array: () => IsUint8Array4,
  IsTuple: () => IsTuple2,
  IsTransform: () => IsTransform2,
  IsThis: () => IsThis2,
  IsTemplateLiteral: () => IsTemplateLiteral2,
  IsSymbol: () => IsSymbol4,
  IsString: () => IsString4,
  IsSchema: () => IsSchema2,
  IsRegExp: () => IsRegExp3,
  IsRef: () => IsRef2,
  IsRecursive: () => IsRecursive,
  IsRecord: () => IsRecord2,
  IsReadonly: () => IsReadonly2,
  IsProperties: () => IsProperties,
  IsPromise: () => IsPromise3,
  IsOptional: () => IsOptional2,
  IsObject: () => IsObject4,
  IsNumber: () => IsNumber4,
  IsNull: () => IsNull4,
  IsNot: () => IsNot2,
  IsNever: () => IsNever2,
  IsMappedResult: () => IsMappedResult2,
  IsMappedKey: () => IsMappedKey2,
  IsLiteralValue: () => IsLiteralValue,
  IsLiteralString: () => IsLiteralString,
  IsLiteralNumber: () => IsLiteralNumber,
  IsLiteralBoolean: () => IsLiteralBoolean,
  IsLiteral: () => IsLiteral2,
  IsKindOf: () => IsKindOf2,
  IsKind: () => IsKind2,
  IsIterator: () => IsIterator4,
  IsIntersect: () => IsIntersect2,
  IsInteger: () => IsInteger3,
  IsFunction: () => IsFunction4,
  IsDate: () => IsDate4,
  IsConstructor: () => IsConstructor2,
  IsBoolean: () => IsBoolean4,
  IsBigInt: () => IsBigInt4,
  IsAsyncIterator: () => IsAsyncIterator4,
  IsArray: () => IsArray4,
  IsAny: () => IsAny2
});
class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern(value) {
  try {
    new RegExp(value);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(value) {
  if (!IsString2(value))
    return false;
  for (let i = 0;i < value.length; i++) {
    const code = value.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(value) {
  return IsOptionalBoolean(value) || IsSchema2(value);
}
function IsOptionalBigInt(value) {
  return IsUndefined2(value) || IsBigInt2(value);
}
function IsOptionalNumber(value) {
  return IsUndefined2(value) || IsNumber2(value);
}
function IsOptionalBoolean(value) {
  return IsUndefined2(value) || IsBoolean2(value);
}
function IsOptionalString(value) {
  return IsUndefined2(value) || IsString2(value);
}
function IsOptionalPattern(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value) && IsPattern(value);
}
function IsOptionalFormat(value) {
  return IsUndefined2(value) || IsString2(value) && IsControlCharacterFree(value);
}
function IsOptionalSchema(value) {
  return IsUndefined2(value) || IsSchema2(value);
}
function IsReadonly2(value) {
  return IsObject2(value) && value[ReadonlyKind] === "Readonly";
}
function IsOptional2(value) {
  return IsObject2(value) && value[OptionalKind] === "Optional";
}
function IsAny2(value) {
  return IsKindOf2(value, "Any") && IsOptionalString(value.$id);
}
function IsArray4(value) {
  return IsKindOf2(value, "Array") && value.type === "array" && IsOptionalString(value.$id) && IsSchema2(value.items) && IsOptionalNumber(value.minItems) && IsOptionalNumber(value.maxItems) && IsOptionalBoolean(value.uniqueItems) && IsOptionalSchema(value.contains) && IsOptionalNumber(value.minContains) && IsOptionalNumber(value.maxContains);
}
function IsAsyncIterator4(value) {
  return IsKindOf2(value, "AsyncIterator") && value.type === "AsyncIterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsBigInt4(value) {
  return IsKindOf2(value, "BigInt") && value.type === "bigint" && IsOptionalString(value.$id) && IsOptionalBigInt(value.exclusiveMaximum) && IsOptionalBigInt(value.exclusiveMinimum) && IsOptionalBigInt(value.maximum) && IsOptionalBigInt(value.minimum) && IsOptionalBigInt(value.multipleOf);
}
function IsBoolean4(value) {
  return IsKindOf2(value, "Boolean") && value.type === "boolean" && IsOptionalString(value.$id);
}
function IsConstructor2(value) {
  return IsKindOf2(value, "Constructor") && value.type === "Constructor" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsDate4(value) {
  return IsKindOf2(value, "Date") && value.type === "Date" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximumTimestamp) && IsOptionalNumber(value.exclusiveMinimumTimestamp) && IsOptionalNumber(value.maximumTimestamp) && IsOptionalNumber(value.minimumTimestamp) && IsOptionalNumber(value.multipleOfTimestamp);
}
function IsFunction4(value) {
  return IsKindOf2(value, "Function") && value.type === "Function" && IsOptionalString(value.$id) && IsArray2(value.parameters) && value.parameters.every((schema) => IsSchema2(schema)) && IsSchema2(value.returns);
}
function IsInteger3(value) {
  return IsKindOf2(value, "Integer") && value.type === "integer" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsProperties(value) {
  return IsObject2(value) && Object.entries(value).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema2(schema));
}
function IsIntersect2(value) {
  return IsKindOf2(value, "Intersect") && (IsString2(value.type) && value.type !== "object" ? false : true) && IsArray2(value.allOf) && value.allOf.every((schema) => IsSchema2(schema) && !IsTransform2(schema)) && IsOptionalString(value.type) && (IsOptionalBoolean(value.unevaluatedProperties) || IsOptionalSchema(value.unevaluatedProperties)) && IsOptionalString(value.$id);
}
function IsIterator4(value) {
  return IsKindOf2(value, "Iterator") && value.type === "Iterator" && IsOptionalString(value.$id) && IsSchema2(value.items);
}
function IsKindOf2(value, kind) {
  return IsObject2(value) && Kind in value && value[Kind] === kind;
}
function IsLiteralString(value) {
  return IsLiteral2(value) && IsString2(value.const);
}
function IsLiteralNumber(value) {
  return IsLiteral2(value) && IsNumber2(value.const);
}
function IsLiteralBoolean(value) {
  return IsLiteral2(value) && IsBoolean2(value.const);
}
function IsLiteral2(value) {
  return IsKindOf2(value, "Literal") && IsOptionalString(value.$id) && IsLiteralValue(value.const);
}
function IsLiteralValue(value) {
  return IsBoolean2(value) || IsNumber2(value) || IsString2(value);
}
function IsMappedKey2(value) {
  return IsKindOf2(value, "MappedKey") && IsArray2(value.keys) && value.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult2(value) {
  return IsKindOf2(value, "MappedResult") && IsProperties(value.properties);
}
function IsNever2(value) {
  return IsKindOf2(value, "Never") && IsObject2(value.not) && Object.getOwnPropertyNames(value.not).length === 0;
}
function IsNot2(value) {
  return IsKindOf2(value, "Not") && IsSchema2(value.not);
}
function IsNull4(value) {
  return IsKindOf2(value, "Null") && value.type === "null" && IsOptionalString(value.$id);
}
function IsNumber4(value) {
  return IsKindOf2(value, "Number") && value.type === "number" && IsOptionalString(value.$id) && IsOptionalNumber(value.exclusiveMaximum) && IsOptionalNumber(value.exclusiveMinimum) && IsOptionalNumber(value.maximum) && IsOptionalNumber(value.minimum) && IsOptionalNumber(value.multipleOf);
}
function IsObject4(value) {
  return IsKindOf2(value, "Object") && value.type === "object" && IsOptionalString(value.$id) && IsProperties(value.properties) && IsAdditionalProperties(value.additionalProperties) && IsOptionalNumber(value.minProperties) && IsOptionalNumber(value.maxProperties);
}
function IsPromise3(value) {
  return IsKindOf2(value, "Promise") && value.type === "Promise" && IsOptionalString(value.$id) && IsSchema2(value.item);
}
function IsRecord2(value) {
  return IsKindOf2(value, "Record") && value.type === "object" && IsOptionalString(value.$id) && IsAdditionalProperties(value.additionalProperties) && IsObject2(value.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema2(schema.patternProperties[keys[0]]);
  })(value);
}
function IsRecursive(value) {
  return IsObject2(value) && Hint in value && value[Hint] === "Recursive";
}
function IsRef2(value) {
  return IsKindOf2(value, "Ref") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsRegExp3(value) {
  return IsKindOf2(value, "RegExp") && IsOptionalString(value.$id) && IsString2(value.source) && IsString2(value.flags) && IsOptionalNumber(value.maxLength) && IsOptionalNumber(value.minLength);
}
function IsString4(value) {
  return IsKindOf2(value, "String") && value.type === "string" && IsOptionalString(value.$id) && IsOptionalNumber(value.minLength) && IsOptionalNumber(value.maxLength) && IsOptionalPattern(value.pattern) && IsOptionalFormat(value.format);
}
function IsSymbol4(value) {
  return IsKindOf2(value, "Symbol") && value.type === "symbol" && IsOptionalString(value.$id);
}
function IsTemplateLiteral2(value) {
  return IsKindOf2(value, "TemplateLiteral") && value.type === "string" && IsString2(value.pattern) && value.pattern[0] === "^" && value.pattern[value.pattern.length - 1] === "$";
}
function IsThis2(value) {
  return IsKindOf2(value, "This") && IsOptionalString(value.$id) && IsString2(value.$ref);
}
function IsTransform2(value) {
  return IsObject2(value) && TransformKind in value;
}
function IsTuple2(value) {
  return IsKindOf2(value, "Tuple") && value.type === "array" && IsOptionalString(value.$id) && IsNumber2(value.minItems) && IsNumber2(value.maxItems) && value.minItems === value.maxItems && (IsUndefined2(value.items) && IsUndefined2(value.additionalItems) && value.minItems === 0 || IsArray2(value.items) && value.items.every((schema) => IsSchema2(schema)));
}
function IsUndefined4(value) {
  return IsKindOf2(value, "Undefined") && value.type === "undefined" && IsOptionalString(value.$id);
}
function IsUnionLiteral(value) {
  return IsUnion2(value) && value.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion2(value) {
  return IsKindOf2(value, "Union") && IsOptionalString(value.$id) && IsObject2(value) && IsArray2(value.anyOf) && value.anyOf.every((schema) => IsSchema2(schema));
}
function IsUint8Array4(value) {
  return IsKindOf2(value, "Uint8Array") && value.type === "Uint8Array" && IsOptionalString(value.$id) && IsOptionalNumber(value.minByteLength) && IsOptionalNumber(value.maxByteLength);
}
function IsUnknown2(value) {
  return IsKindOf2(value, "Unknown") && IsOptionalString(value.$id);
}
function IsUnsafe2(value) {
  return IsKindOf2(value, "Unsafe");
}
function IsVoid2(value) {
  return IsKindOf2(value, "Void") && value.type === "void" && IsOptionalString(value.$id);
}
function IsKind2(value) {
  return IsObject2(value) && Kind in value && IsString2(value[Kind]) && !KnownTypes.includes(value[Kind]);
}
function IsSchema2(value) {
  return IsObject2(value) && (IsAny2(value) || IsArray4(value) || IsBoolean4(value) || IsBigInt4(value) || IsAsyncIterator4(value) || IsConstructor2(value) || IsDate4(value) || IsFunction4(value) || IsInteger3(value) || IsIntersect2(value) || IsIterator4(value) || IsLiteral2(value) || IsMappedKey2(value) || IsMappedResult2(value) || IsNever2(value) || IsNot2(value) || IsNull4(value) || IsNumber4(value) || IsObject4(value) || IsPromise3(value) || IsRecord2(value) || IsRef2(value) || IsRegExp3(value) || IsString4(value) || IsSymbol4(value) || IsTemplateLiteral2(value) || IsThis2(value) || IsTuple2(value) || IsUndefined4(value) || IsUnion2(value) || IsUint8Array4(value) || IsUnknown2(value) || IsUnsafe2(value) || IsVoid2(value) || IsKind2(value));
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-check.mjs
class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
function IntoBooleanResult(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
}
function Throw(message) {
  throw new ExtendsResolverError(message);
}
function IsStructuralRight(right) {
  return exports_type2.IsNever(right) || exports_type2.IsIntersect(right) || exports_type2.IsUnion(right) || exports_type2.IsUnknown(right) || exports_type2.IsAny(right);
}
function StructuralRight(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
}
function FromAnyRight(left, right) {
  return ExtendsResult.True;
}
function FromAny2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) && right.anyOf.some((schema) => exports_type2.IsAny(schema) || exports_type2.IsUnknown(schema)) ? ExtendsResult.True : exports_type2.IsUnion(right) ? ExtendsResult.Union : exports_type2.IsUnknown(right) ? ExtendsResult.True : exports_type2.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
}
function FromArrayRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromArray4(left, right) {
  return exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromAsyncIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromBigInt2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBooleanRight(left, right) {
  return exports_type2.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type2.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromBoolean2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromConstructor2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromDate2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromFunction2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
}
function FromIntegerRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromInteger2(left, right) {
  return exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
}
function FromIntersectRight(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIntersect4(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromIterator2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
}
function FromLiteral3(left, right) {
  return exports_type2.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
}
function FromNeverRight(left, right) {
  return ExtendsResult.False;
}
function FromNever2(left, right) {
  return ExtendsResult.True;
}
function UnwrapTNot(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
}
function FromNot2(left, right) {
  return exports_type2.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type2.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
}
function FromNull2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumberRight(left, right) {
  return exports_type2.IsLiteralNumber(left) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromNumber2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
}
function IsObjectPropertyCount(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
}
function IsObjectStringLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectSymbolLike(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type2.IsString(schema.properties.description.anyOf[0]) && exports_type2.IsUndefined(schema.properties.description.anyOf[1]) || exports_type2.IsString(schema.properties.description.anyOf[1]) && exports_type2.IsUndefined(schema.properties.description.anyOf[0]));
}
function IsObjectNumberLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBooleanLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectBigIntLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectDateLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectUint8ArrayLike(schema) {
  return IsObjectArrayLike(schema);
}
function IsObjectFunctionLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectConstructorLike(schema) {
  return IsObjectPropertyCount(schema, 0);
}
function IsObjectArrayLike(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
}
function IsObjectPromiseLike(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
}
function Property(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type2.IsOptional(left) && !exports_type2.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
}
function FromObjectRight(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) || exports_type2.IsLiteralString(left) && IsObjectStringLike(right) || exports_type2.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type2.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type2.IsString(left) && IsObjectStringLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsNumber(left) && IsObjectNumberLike(right) || exports_type2.IsInteger(left) && IsObjectNumberLike(right) || exports_type2.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type2.IsDate(left) && IsObjectDateLike(right) || exports_type2.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type2.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type2.IsRecord(left) && exports_type2.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type2.IsRecord(left) && exports_type2.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
}
function FromObject2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : !exports_type2.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
}
function FromPromise2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type2.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
}
function RecordKey(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
}
function RecordValue(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
}
function FromRecordRight(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type2.IsLiteralString(left) && exports_type2.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type2.IsUint8Array(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsString(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsArray(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
}
function FromRecord2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
}
function FromRegExp2(left, right) {
  const L = exports_type2.IsRegExp(left) ? String2() : left;
  const R = exports_type2.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
}
function FromStringRight(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type2.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromString2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromSymbol2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromTemplateLiteral3(left, right) {
  return exports_type2.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type2.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(left, right) {
  return exports_type2.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
}
function FromTupleRight(left, right) {
  return exports_type2.IsNever(left) ? ExtendsResult.True : exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
}
function FromTuple4(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type2.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type2.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUint8Array2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUndefined2(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsVoid(right) ? FromVoidRight(left, right) : exports_type2.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnionRight(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnion6(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
}
function FromUnknownRight(left, right) {
  return ExtendsResult.True;
}
function FromUnknown2(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type2.IsArray(right) ? FromArrayRight(left, right) : exports_type2.IsTuple(right) ? FromTupleRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoidRight(left, right) {
  return exports_type2.IsUndefined(left) ? ExtendsResult.True : exports_type2.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
}
function FromVoid2(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
}
function Visit5(left, right) {
  return exports_type2.IsTemplateLiteral(left) || exports_type2.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type2.IsRegExp(left) || exports_type2.IsRegExp(right) ? FromRegExp2(left, right) : exports_type2.IsNot(left) || exports_type2.IsNot(right) ? FromNot2(left, right) : exports_type2.IsAny(left) ? FromAny2(left, right) : exports_type2.IsArray(left) ? FromArray4(left, right) : exports_type2.IsBigInt(left) ? FromBigInt2(left, right) : exports_type2.IsBoolean(left) ? FromBoolean2(left, right) : exports_type2.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type2.IsConstructor(left) ? FromConstructor2(left, right) : exports_type2.IsDate(left) ? FromDate2(left, right) : exports_type2.IsFunction(left) ? FromFunction2(left, right) : exports_type2.IsInteger(left) ? FromInteger2(left, right) : exports_type2.IsIntersect(left) ? FromIntersect4(left, right) : exports_type2.IsIterator(left) ? FromIterator2(left, right) : exports_type2.IsLiteral(left) ? FromLiteral3(left, right) : exports_type2.IsNever(left) ? FromNever2(left, right) : exports_type2.IsNull(left) ? FromNull2(left, right) : exports_type2.IsNumber(left) ? FromNumber2(left, right) : exports_type2.IsObject(left) ? FromObject2(left, right) : exports_type2.IsRecord(left) ? FromRecord2(left, right) : exports_type2.IsString(left) ? FromString2(left, right) : exports_type2.IsSymbol(left) ? FromSymbol2(left, right) : exports_type2.IsTuple(left) ? FromTuple4(left, right) : exports_type2.IsPromise(left) ? FromPromise2(left, right) : exports_type2.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type2.IsUndefined(left) ? FromUndefined2(left, right) : exports_type2.IsUnion(left) ? FromUnion6(left, right) : exports_type2.IsUnknown(left) ? FromUnknown2(left, right) : exports_type2.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
}
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}
// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-result.mjs
function FromProperties7(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends(P[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult6(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends.mjs
function ExtendsResolve(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
}
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extends/extends-from-mapped-key.mjs
function FromPropertyKey(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
}
function FromPropertyKeys(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
}
function FromMappedKey2(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
}
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/value/check/check.mjs
class ValueCheckUnknownTypeError extends TypeBoxError {
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
function IsAnyOrUnknown(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
}
function IsDefined2(value) {
  return value !== undefined;
}
function FromAny3(schema, references, value) {
  return true;
}
function FromArray5(schema, references, value) {
  if (!IsArray(value))
    return false;
  if (IsDefined2(schema.minItems) && !(value.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value.length <= schema.maxItems)) {
    return false;
  }
  if (!value.every((value2) => Visit6(schema.items, references, value2))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set3 = new Set;
    for (const element of value) {
      const hashed = Hash(element);
      if (set3.has(hashed)) {
        return false;
      } else {
        set3.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value.reduce((acc, value2) => Visit6(containsSchema, references, value2) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
}
function FromAsyncIterator3(schema, references, value) {
  return IsAsyncIterator(value);
}
function FromBigInt3(schema, references, value) {
  if (!IsBigInt(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function FromBoolean3(schema, references, value) {
  return IsBoolean(value);
}
function FromConstructor3(schema, references, value) {
  return Visit6(schema.returns, references, value.prototype);
}
function FromDate3(schema, references, value) {
  if (!IsDate(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function FromFunction3(schema, references, value) {
  return IsFunction(value);
}
function FromInteger3(schema, references, value) {
  if (!IsInteger(value)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromIntersect5(schema, references, value) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema2(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value[key]));
    return check1 && check2;
  } else {
    return check1;
  }
}
function FromIterator3(schema, references, value) {
  return IsIterator(value);
}
function FromLiteral4(schema, references, value) {
  return value === schema.const;
}
function FromNever3(schema, references, value) {
  return false;
}
function FromNot3(schema, references, value) {
  return !Visit6(schema.not, references, value);
}
function FromNull3(schema, references, value) {
  return IsNull(value);
}
function FromNumber3(schema, references, value) {
  if (!TypeSystemPolicy.IsNumberLike(value))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value % schema.multipleOf === 0)) {
    return false;
  }
  return true;
}
function FromObject3(schema, references, value) {
  if (!TypeSystemPolicy.IsObjectLike(value))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value, knownKey) && !Visit6(property, references, value[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value[key]));
  } else {
    return true;
  }
}
function FromPromise3(schema, references, value) {
  return IsPromise(value);
}
function FromRecord3(schema, references, value) {
  if (!TypeSystemPolicy.IsRecordLike(value)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value).every(([key, value2]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value2) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value).every(([key, value2]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value2) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
}
function FromRef2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromRegExp3(schema, references, value) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  return regex.test(value);
}
function FromString3(schema, references, value) {
  if (!IsString(value)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value);
  }
  return true;
}
function FromSymbol3(schema, references, value) {
  return IsSymbol(value);
}
function FromTemplateLiteral4(schema, references, value) {
  return IsString(value) && new RegExp(schema.pattern).test(value);
}
function FromThis2(schema, references, value) {
  return Visit6(Deref(schema, references), references, value);
}
function FromTuple5(schema, references, value) {
  if (!IsArray(value)) {
    return false;
  }
  if (schema.items === undefined && !(value.length === 0)) {
    return false;
  }
  if (!(value.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value[i]))
      return false;
  }
  return true;
}
function FromUndefined3(schema, references, value) {
  return IsUndefined(value);
}
function FromUnion7(schema, references, value) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value));
}
function FromUint8Array3(schema, references, value) {
  if (!IsUint8Array(value)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value.length >= schema.minByteLength)) {
    return false;
  }
  return true;
}
function FromUnknown3(schema, references, value) {
  return true;
}
function FromVoid3(schema, references, value) {
  return TypeSystemPolicy.IsVoidLike(value);
}
function FromKind2(schema, references, value) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value);
}
function Visit6(schema, references, value) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value);
    case "Array":
      return FromArray5(schema_, references_, value);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value);
    case "BigInt":
      return FromBigInt3(schema_, references_, value);
    case "Boolean":
      return FromBoolean3(schema_, references_, value);
    case "Constructor":
      return FromConstructor3(schema_, references_, value);
    case "Date":
      return FromDate3(schema_, references_, value);
    case "Function":
      return FromFunction3(schema_, references_, value);
    case "Integer":
      return FromInteger3(schema_, references_, value);
    case "Intersect":
      return FromIntersect5(schema_, references_, value);
    case "Iterator":
      return FromIterator3(schema_, references_, value);
    case "Literal":
      return FromLiteral4(schema_, references_, value);
    case "Never":
      return FromNever3(schema_, references_, value);
    case "Not":
      return FromNot3(schema_, references_, value);
    case "Null":
      return FromNull3(schema_, references_, value);
    case "Number":
      return FromNumber3(schema_, references_, value);
    case "Object":
      return FromObject3(schema_, references_, value);
    case "Promise":
      return FromPromise3(schema_, references_, value);
    case "Record":
      return FromRecord3(schema_, references_, value);
    case "Ref":
      return FromRef2(schema_, references_, value);
    case "RegExp":
      return FromRegExp3(schema_, references_, value);
    case "String":
      return FromString3(schema_, references_, value);
    case "Symbol":
      return FromSymbol3(schema_, references_, value);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value);
    case "This":
      return FromThis2(schema_, references_, value);
    case "Tuple":
      return FromTuple5(schema_, references_, value);
    case "Undefined":
      return FromUndefined3(schema_, references_, value);
    case "Union":
      return FromUnion7(schema_, references_, value);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value);
    case "Unknown":
      return FromUnknown3(schema_, references_, value);
    case "Void":
      return FromVoid3(schema_, references_, value);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value);
  }
}
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clone/clone.mjs
function ObjectType3(value) {
  const Acc = {};
  for (const key of Object.getOwnPropertyNames(value)) {
    Acc[key] = Clone2(value[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value)) {
    Acc[key] = Clone2(value[key]);
  }
  return Acc;
}
function ArrayType3(value) {
  return value.map((element) => Clone2(element));
}
function TypedArrayType(value) {
  return value.slice();
}
function DateType3(value) {
  return new Date(value.toISOString());
}
function ValueType(value) {
  return value;
}
function Clone2(value) {
  if (IsArray(value))
    return ArrayType3(value);
  if (IsDate(value))
    return DateType3(value);
  if (IsStandardObject(value))
    return ObjectType3(value);
  if (IsTypedArray(value))
    return TypedArrayType(value);
  if (IsValueType(value))
    return ValueType(value);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/esm/value/create/create.mjs
class ValueCreateError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function FromDefault(value) {
  return typeof value === "function" ? value : Clone2(value);
}
function FromAny4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromArray6(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
}
function FromAsyncIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
}
function FromBigInt4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
}
function FromBoolean4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
}
function FromConstructor4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = Visit7(schema.returns, references);
    if (typeof value === "object" && !Array.isArray(value)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
}
function FromDate4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
}
function FromFunction4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
}
function FromInteger4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromIntersect6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value;
  }
}
function FromIterator4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
}
function FromLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
}
function FromNever4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
}
function FromNot4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
}
function FromNull4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
}
function FromNumber4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
}
function FromObject4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    const Acc = {};
    for (const [key, subschema] of Object.entries(schema.properties)) {
      if (!required.has(key))
        continue;
      Acc[key] = Visit7(subschema, references);
    }
    return Acc;
  }
}
function FromPromise4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
}
function FromRecord4(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    const Acc = {};
    for (const key of propertyKeys)
      Acc[key] = Visit7(valueSchema, references);
    return Acc;
  } else {
    return {};
  }
}
function FromRef3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromRegExp4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
}
function FromString4(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
}
function FromSymbol4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
}
function FromTemplateLiteral5(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
}
function FromThis3(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
}
function FromTuple6(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
}
function FromUndefined4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromUnion8(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
}
function FromUint8Array4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function FromUnknown4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
}
function FromVoid4(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
}
function FromKind3(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function Visit7(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}
// node_modules/@sinclair/typebox/build/esm/value/cast/cast.mjs
class ValueCastError extends TypeBoxError {
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
function ScoreUnion(schema, references, value) {
  if (schema[Kind] === "Object" && typeof value === "object" && !IsNull(value)) {
    const object2 = schema;
    const keys = Object.getOwnPropertyNames(value);
    const entries = Object.entries(object2.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal2 = schema2[Kind] === "Literal" && schema2.const === value[key] ? max : 0;
      const checks = Check(schema2, references, value[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal2 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value) ? 1 : 0;
  }
}
function SelectUnion(union3, references, value) {
  const schemas = union3.anyOf.map((schema) => Deref(schema, references));
  let [select, best] = [schemas[0], 0];
  for (const schema of schemas) {
    const score = ScoreUnion(schema, references, value);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
}
function CastUnion(union3, references, value) {
  if ("default" in union3) {
    return typeof value === "function" ? union3.default : Clone2(union3.default);
  } else {
    const schema = SelectUnion(union3, references, value);
    return Cast(schema, references, value);
  }
}
function DefaultClone(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : Create2(schema, references);
}
function Default(schema, references, value) {
  return Check(schema, references, value) ? value : Create2(schema, references);
}
function FromArray7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  const created = IsArray(value) ? Clone2(value) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value2) => Visit8(schema.items, references, value2));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
}
function FromConstructor5(schema, references, value) {
  if (Check(schema, references, value))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value.prototype[key]);
  }
  return result;
}
function FromIntersect7(schema, references, value) {
  const created = Create2(schema, references);
  const mapped2 = IsStandardObject(created) && IsStandardObject(value) ? { ...created, ...value } : value;
  return Check(schema, references, mapped2) ? mapped2 : Create2(schema, references);
}
function FromNever5(schema, references, value) {
  throw new ValueCastError(schema, "Never types cannot be cast");
}
function FromObject5(schema, references, value) {
  if (Check(schema, references, value))
    return value;
  if (value === null || typeof value !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value[propertyName]);
    }
  }
  return result;
}
function FromRecord5(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (value === null || typeof value !== "object" || Array.isArray(value) || value instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
}
function FromRef4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromThis4(schema, references, value) {
  return Visit8(Deref(schema, references), references, value);
}
function FromTuple7(schema, references, value) {
  if (Check(schema, references, value))
    return Clone2(value);
  if (!IsArray(value))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value[index]));
}
function FromUnion9(schema, references, value) {
  return Check(schema, references, value) ? Clone2(value) : CastUnion(schema, references, value);
}
function Visit8(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value);
    case "Constructor":
      return FromConstructor5(schema_, references_, value);
    case "Intersect":
      return FromIntersect7(schema_, references_, value);
    case "Never":
      return FromNever5(schema_, references_, value);
    case "Object":
      return FromObject5(schema_, references_, value);
    case "Record":
      return FromRecord5(schema_, references_, value);
    case "Ref":
      return FromRef4(schema_, references_, value);
    case "This":
      return FromThis4(schema_, references_, value);
    case "Tuple":
      return FromTuple7(schema_, references_, value);
    case "Union":
      return FromUnion9(schema_, references_, value);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value);
    default:
      return Default(schema_, references_, value);
  }
}
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/clean/clean.mjs
function IsCheckable(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function FromArray8(schema, references, value) {
  if (!IsArray(value))
    return value;
  return value.map((value2) => Visit9(schema.items, references, value2));
}
function FromIntersect8(schema, references, value) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value)));
  const composite = intersections.reduce((acc, value2) => IsObject(value2) ? { ...acc, ...value2 } : value2, {});
  if (!IsObject(value) || !IsObject(composite) || !IsSchema2(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value[key]);
    }
  }
  return composite;
}
function FromObject6(schema, references, value) {
  if (!IsObject(value) || IsArray(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value)) {
    if (key in schema.properties) {
      value[key] = Visit9(schema.properties[key], references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRecord6(schema, references, value) {
  if (!IsObject(value))
    return value;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.getOwnPropertyNames(value);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value[key] = Visit9(propertySchema, references, value[key]);
      continue;
    }
    if (IsSchema2(additionalProperties) && Check(additionalProperties, references, value[key])) {
      value[key] = Visit9(additionalProperties, references, value[key]);
      continue;
    }
    delete value[key];
  }
  return value;
}
function FromRef5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromThis5(schema, references, value) {
  return Visit9(Deref(schema, references), references, value);
}
function FromTuple8(schema, references, value) {
  if (!IsArray(value))
    return value;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value[i] = Visit9(schema.items[i], references, value[i]);
  }
  return value.length > length ? value.slice(0, length) : value;
}
function FromUnion10(schema, references, value) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, references, value)) {
      return Visit9(inner, references, value);
    }
  }
  return value;
}
function Visit9(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value);
    case "Intersect":
      return FromIntersect8(schema_, references_, value);
    case "Object":
      return FromObject6(schema_, references_, value);
    case "Record":
      return FromRecord6(schema_, references_, value);
    case "Ref":
      return FromRef5(schema_, references_, value);
    case "This":
      return FromThis5(schema_, references_, value);
    case "Tuple":
      return FromTuple8(schema_, references_, value);
    case "Union":
      return FromUnion10(schema_, references_, value);
    default:
      return value;
  }
}
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/convert/convert.mjs
function IsStringNumeric(value) {
  return IsString(value) && !isNaN(value) && !isNaN(parseFloat(value));
}
function IsValueToString(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNumber(value);
}
function IsValueTrue(value) {
  return value === true || IsNumber(value) && value === 1 || IsBigInt(value) && value === BigInt("1") || IsString(value) && (value.toLowerCase() === "true" || value === "1");
}
function IsValueFalse(value) {
  return value === false || IsNumber(value) && (value === 0 || Object.is(value, -0)) || IsBigInt(value) && value === BigInt("0") || IsString(value) && (value.toLowerCase() === "false" || value === "0" || value === "-0");
}
function IsTimeStringWithTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateTimeStringWithTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value);
}
function IsDateTimeStringWithoutTimeZone(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value);
}
function IsDateString(value) {
  return IsString(value) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value);
}
function TryConvertLiteralString(value, target) {
  const conversion = TryConvertString(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralNumber(value, target) {
  const conversion = TryConvertNumber(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteralBoolean(value, target) {
  const conversion = TryConvertBoolean(value);
  return conversion === target ? conversion : value;
}
function TryConvertLiteral(schema, value) {
  return IsString(schema.const) ? TryConvertLiteralString(value, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value, schema.const) : Clone2(value);
}
function TryConvertBoolean(value) {
  return IsValueTrue(value) ? true : IsValueFalse(value) ? false : value;
}
function TryConvertBigInt(value) {
  return IsStringNumeric(value) ? BigInt(parseInt(value)) : IsNumber(value) ? BigInt(value | 0) : IsValueFalse(value) ? BigInt(0) : IsValueTrue(value) ? BigInt(1) : value;
}
function TryConvertString(value) {
  return IsValueToString(value) ? value.toString() : IsSymbol(value) && value.description !== undefined ? value.description.toString() : value;
}
function TryConvertNumber(value) {
  return IsStringNumeric(value) ? parseFloat(value) : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertInteger(value) {
  return IsStringNumeric(value) ? parseInt(value) : IsNumber(value) ? value | 0 : IsValueTrue(value) ? 1 : IsValueFalse(value) ? 0 : value;
}
function TryConvertNull(value) {
  return IsString(value) && value.toLowerCase() === "null" ? null : value;
}
function TryConvertUndefined(value) {
  return IsString(value) && value === "undefined" ? undefined : value;
}
function TryConvertDate(value) {
  return IsDate(value) ? value : IsNumber(value) ? new Date(value) : IsValueTrue(value) ? new Date(1) : IsValueFalse(value) ? new Date(0) : IsStringNumeric(value) ? new Date(parseInt(value)) : IsTimeStringWithoutTimeZone(value) ? new Date(`1970-01-01T${value}.000Z`) : IsTimeStringWithTimeZone(value) ? new Date(`1970-01-01T${value}`) : IsDateTimeStringWithoutTimeZone(value) ? new Date(`${value}.000Z`) : IsDateTimeStringWithTimeZone(value) ? new Date(value) : IsDateString(value) ? new Date(`${value}T00:00:00.000Z`) : value;
}
function Default2(value) {
  return value;
}
function FromArray9(schema, references, value) {
  const elements = IsArray(value) ? value : [value];
  return elements.map((element) => Visit10(schema.items, references, element));
}
function FromBigInt5(schema, references, value) {
  return TryConvertBigInt(value);
}
function FromBoolean5(schema, references, value) {
  return TryConvertBoolean(value);
}
function FromDate5(schema, references, value) {
  return TryConvertDate(value);
}
function FromInteger5(schema, references, value) {
  return TryConvertInteger(value);
}
function FromIntersect9(schema, references, value) {
  return schema.allOf.reduce((value2, schema2) => Visit10(schema2, references, value2), value);
}
function FromLiteral6(schema, references, value) {
  return TryConvertLiteral(schema, value);
}
function FromNull5(schema, references, value) {
  return TryConvertNull(value);
}
function FromNumber5(schema, references, value) {
  return TryConvertNumber(value);
}
function FromObject7(schema, references, value) {
  const isConvertable = IsObject(value);
  if (!isConvertable)
    return value;
  const result = {};
  for (const key of Object.keys(value)) {
    result[key] = HasPropertyKey(schema.properties, key) ? Visit10(schema.properties[key], references, value[key]) : value[key];
  }
  return result;
}
function FromRecord7(schema, references, value) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
}
function FromRef6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromString5(schema, references, value) {
  return TryConvertString(value);
}
function FromSymbol5(schema, references, value) {
  return IsString(value) || IsNumber(value) ? Symbol(value) : value;
}
function FromThis6(schema, references, value) {
  return Visit10(Deref(schema, references), references, value);
}
function FromTuple9(schema, references, value) {
  const isConvertable = IsArray(value) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value;
  return value.map((value2, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value2) : value2;
  });
}
function FromUndefined5(schema, references, value) {
  return TryConvertUndefined(value);
}
function FromUnion11(schema, references, value) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value);
    if (!Check(subschema, references, converted))
      continue;
    return converted;
  }
  return value;
}
function Visit10(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value);
    case "BigInt":
      return FromBigInt5(schema_, references_, value);
    case "Boolean":
      return FromBoolean5(schema_, references_, value);
    case "Date":
      return FromDate5(schema_, references_, value);
    case "Integer":
      return FromInteger5(schema_, references_, value);
    case "Intersect":
      return FromIntersect9(schema_, references_, value);
    case "Literal":
      return FromLiteral6(schema_, references_, value);
    case "Null":
      return FromNull5(schema_, references_, value);
    case "Number":
      return FromNumber5(schema_, references_, value);
    case "Object":
      return FromObject7(schema_, references_, value);
    case "Record":
      return FromRecord7(schema_, references_, value);
    case "Ref":
      return FromRef6(schema_, references_, value);
    case "String":
      return FromString5(schema_, references_, value);
    case "Symbol":
      return FromSymbol5(schema_, references_, value);
    case "This":
      return FromThis6(schema_, references_, value);
    case "Tuple":
      return FromTuple9(schema_, references_, value);
    case "Undefined":
      return FromUndefined5(schema_, references_, value);
    case "Union":
      return FromUnion11(schema_, references_, value);
    default:
      return Default2(value);
  }
}
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/default/default.mjs
function ValueOrDefault(schema, value) {
  return value === undefined && "default" in schema ? Clone2(schema.default) : value;
}
function IsCheckable2(schema) {
  return IsSchema2(schema) && schema[Kind] !== "Unsafe";
}
function IsDefaultSchema(value) {
  return IsSchema2(value) && "default" in value;
}
function FromArray10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
}
function FromIntersect10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
}
function FromObject8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRecord8(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
}
function FromRef7(schema, references, value) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value));
}
function FromThis7(schema, references, value) {
  return Visit11(Deref(schema, references), references, value);
}
function FromTuple10(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
}
function FromUnion12(schema, references, value) {
  const defaulted = ValueOrDefault(schema, value);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
}
function Visit11(schema, references, value) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value);
    case "Intersect":
      return FromIntersect10(schema_, references_, value);
    case "Object":
      return FromObject8(schema_, references_, value);
    case "Record":
      return FromRecord8(schema_, references_, value);
    case "Ref":
      return FromRef7(schema_, references_, value);
    case "This":
      return FromThis7(schema_, references_, value);
    case "Tuple":
      return FromTuple10(schema_, references_, value);
    case "Union":
      return FromUnion12(schema_, references_, value);
    default:
      return ValueOrDefault(schema_, value);
  }
}
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/esm/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => ValuePointerRootSetError,
  ValuePointerRootDeleteError: () => ValuePointerRootDeleteError,
  Set: () => Set4,
  Has: () => Has3,
  Get: () => Get3,
  Format: () => Format,
  Delete: () => Delete3
});
class ValuePointerRootSetError extends TypeBoxError {
  constructor(value, path, update) {
    super("Cannot set root value");
    this.value = value;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  constructor(value, path) {
    super("Cannot delete root value");
    this.value = value;
    this.path = path;
  }
}
function Escape2(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value, pointer, update);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value, pointer);
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value, pointer) {
  if (pointer === "")
    return value;
  let current = value;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}
// node_modules/@sinclair/typebox/build/esm/value/delta/delta.mjs
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  constructor(value, message) {
    super(message);
    this.value = value;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  constructor(value) {
    super(value, "Cannot diff objects with symbol keys");
    this.value = value;
  }
}
function CreateUpdate(path, value) {
  return { type: "update", path, value };
}
function CreateInsert(path, value) {
  return { type: "insert", path, value };
}
function CreateDelete(path) {
  return { type: "delete", path };
}
function* ObjectType4(path, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
function IsRootUpdate(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
}
function IsIdentity(edits) {
  return edits.length === 0;
}
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone2 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone2, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone2, edit.path);
        break;
      }
    }
  }
  return clone2;
}
// node_modules/@sinclair/typebox/build/esm/value/equal/equal.mjs
function ObjectType5(left, right) {
  if (!IsStandardObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
}
function DateType4(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
}
function ArrayType5(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function TypedArrayType3(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value, index) => Equal(value, right[index]));
}
function ValueType3(left, right) {
  return left === right;
}
function Equal(left, right) {
  if (IsStandardObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/esm/value/mutate/mutate.mjs
class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
function ObjectType6(root, path, current, next) {
  if (!IsStandardObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.getOwnPropertyNames(current);
    const nextKeys = Object.getOwnPropertyNames(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
}
function ArrayType6(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
}
function TypedArrayType4(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
}
function ValueType4(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
}
function Visit13(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
}
function IsNonMutableValue(value) {
  return IsTypedArray(value) || IsValueType(value);
}
function IsMismatchedValue(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
}
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/decode.mjs
class TransformDecodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformDecodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(error2 instanceof Error ? error2.message : "Unknown error");
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default4(schema, path, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Decode(value) : value;
  } catch (error2) {
    throw new TransformDecodeError(schema, path, value, error2);
  }
}
function FromArray11(schema, references, path, value) {
  return IsArray(value) ? Default4(schema, path, value.map((value2, index) => Visit14(schema.items, references, `${path}/${index}`, value2))) : Default4(schema, path, value);
}
function FromIntersect11(schema, references, path, value) {
  if (!IsStandardObject(value) || IsValueType(value))
    return Default4(schema, path, value);
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...value };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit14(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(unevaluatedProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromNot5(schema, references, path, value) {
  return Default4(schema, path, Visit14(schema.not, references, path, value));
}
function FromObject9(schema, references, path, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path, value);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...value };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit14(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRecord9(schema, references, path, value) {
  if (!IsStandardObject(value))
    return Default4(schema, path, value);
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...value };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit14(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default4(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      unknownProperties[key] = Default4(additionalProperties, `${path}/${key}`, unknownProperties[key]);
    }
  return Default4(schema, path, unknownProperties);
}
function FromRef8(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value));
}
function FromThis8(schema, references, path, value) {
  const target = Deref(schema, references);
  return Default4(schema, path, Visit14(target, references, path, value));
}
function FromTuple11(schema, references, path, value) {
  return IsArray(value) && IsArray(schema.items) ? Default4(schema, path, schema.items.map((schema2, index) => Visit14(schema2, references, `${path}/${index}`, value[index]))) : Default4(schema, path, value);
}
function FromUnion13(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const decoded = Visit14(subschema, references, path, value);
    return Default4(schema, path, decoded);
  }
  return Default4(schema, path, value);
}
function Visit14(schema, references, path, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect11(schema_, references_, path, value);
    case "Not":
      return FromNot5(schema_, references_, path, value);
    case "Object":
      return FromObject9(schema_, references_, path, value);
    case "Record":
      return FromRecord9(schema_, references_, path, value);
    case "Ref":
      return FromRef8(schema_, references_, path, value);
    case "Symbol":
      return Default4(schema_, path, value);
    case "This":
      return FromThis8(schema_, references_, path, value);
    case "Tuple":
      return FromTuple11(schema_, references_, path, value);
    case "Union":
      return FromUnion13(schema_, references_, path, value);
    default:
      return Default4(schema_, path, value);
  }
}
function TransformDecode(schema, references, value) {
  return Visit14(schema, references, "", value);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/encode.mjs
class TransformEncodeCheckError extends TypeBoxError {
  constructor(schema, value, error2) {
    super(`The encoded value does not match the expected schema`);
    this.schema = schema;
    this.value = value;
    this.error = error2;
  }
}

class TransformEncodeError extends TypeBoxError {
  constructor(schema, path, value, error2) {
    super(`${error2 instanceof Error ? error2.message : "Unknown error"}`);
    this.schema = schema;
    this.path = path;
    this.value = value;
    this.error = error2;
  }
}
function Default5(schema, path, value) {
  try {
    return IsTransform2(schema) ? schema[TransformKind].Encode(value) : value;
  } catch (error2) {
    throw new TransformEncodeError(schema, path, value, error2);
  }
}
function FromArray12(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  return IsArray(defaulted) ? defaulted.map((value2, index) => Visit15(schema.items, references, `${path}/${index}`, value2)) : defaulted;
}
function FromIntersect12(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(value) || IsValueType(value))
    return defaulted;
  const knownEntries = KeyOfPropertyEntries(schema);
  const knownKeys = knownEntries.map((entry) => entry[0]);
  const knownProperties = { ...defaulted };
  for (const [knownKey, knownSchema] of knownEntries)
    if (knownKey in knownProperties) {
      knownProperties[knownKey] = Visit15(knownSchema, references, `${path}/${knownKey}`, knownProperties[knownKey]);
    }
  if (!IsTransform2(schema.unevaluatedProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(unevaluatedProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromNot6(schema, references, path, value) {
  return Default5(schema.not, path, Default5(schema, path, value));
}
function FromObject10(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(defaulted))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = { ...defaulted };
  for (const key of knownKeys)
    if (key in knownProperties) {
      knownProperties[key] = Visit15(schema.properties[key], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.includes(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRecord10(schema, references, path, value) {
  const defaulted = Default5(schema, path, value);
  if (!IsStandardObject(value))
    return defaulted;
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern2);
  const knownProperties = { ...defaulted };
  for (const key of Object.getOwnPropertyNames(value))
    if (knownKeys.test(key)) {
      knownProperties[key] = Visit15(schema.patternProperties[pattern2], references, `${path}/${key}`, knownProperties[key]);
    }
  if (!IsSchema2(schema.additionalProperties)) {
    return Default5(schema, path, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const properties = { ...knownProperties };
  for (const key of unknownKeys)
    if (!knownKeys.test(key)) {
      properties[key] = Default5(additionalProperties, `${path}/${key}`, properties[key]);
    }
  return properties;
}
function FromRef9(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value);
  return Default5(schema, path, resolved);
}
function FromThis9(schema, references, path, value) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, path, value);
  return Default5(schema, path, resolved);
}
function FromTuple12(schema, references, path, value) {
  const value1 = Default5(schema, path, value);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, `${path}/${index}`, value1[index])) : [];
}
function FromUnion14(schema, references, path, value) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value))
      continue;
    const value1 = Visit15(subschema, references, path, value);
    return Default5(schema, path, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, path, value);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, path, value1);
  }
  return Default5(schema, path, value);
}
function Visit15(schema, references, path, value) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, path, value);
    case "Intersect":
      return FromIntersect12(schema_, references_, path, value);
    case "Not":
      return FromNot6(schema_, references_, path, value);
    case "Object":
      return FromObject10(schema_, references_, path, value);
    case "Record":
      return FromRecord10(schema_, references_, path, value);
    case "Ref":
      return FromRef9(schema_, references_, path, value);
    case "This":
      return FromThis9(schema_, references_, path, value);
    case "Tuple":
      return FromTuple12(schema_, references_, path, value);
    case "Union":
      return FromUnion14(schema_, references_, path, value);
    default:
      return Default5(schema_, path, value);
  }
}
function TransformEncode(schema, references, value) {
  return Visit15(schema, references, "", value);
}
// node_modules/@sinclair/typebox/build/esm/value/transform/has.mjs
function FromArray13(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromAsyncIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromConstructor6(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromFunction5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
}
function FromIntersect13(schema, references) {
  return IsTransform2(schema) || IsTransform2(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
}
function FromIterator5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.items, references);
}
function FromNot7(schema, references) {
  return IsTransform2(schema) || Visit16(schema.not, references);
}
function FromObject11(schema, references) {
  return IsTransform2(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema2(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
}
function FromPromise5(schema, references) {
  return IsTransform2(schema) || Visit16(schema.item, references);
}
function FromRecord11(schema, references) {
  const pattern2 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern2];
  return IsTransform2(schema) || Visit16(property, references) || IsSchema2(schema.additionalProperties) && IsTransform2(schema.additionalProperties);
}
function FromRef10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromThis10(schema, references) {
  if (IsTransform2(schema))
    return true;
  return Visit16(Deref(schema, references), references);
}
function FromTuple13(schema, references) {
  return IsTransform2(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
}
function FromUnion15(schema, references) {
  return IsTransform2(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
}
function Visit16(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform2(schema);
  }
}
var visited = new Set;
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
// node_modules/@sinclair/typebox/build/esm/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => Patch2,
  Mutate: () => Mutate2,
  Hash: () => Hash2,
  Errors: () => Errors2,
  Equal: () => Equal2,
  Encode: () => Encode,
  Diff: () => Diff2,
  Default: () => Default6,
  Decode: () => Decode,
  Create: () => Create3,
  Convert: () => Convert2,
  Clone: () => Clone3,
  Clean: () => Clean2,
  Check: () => Check2,
  Cast: () => Cast2
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value) {
  return Clone2(value);
}
function Decode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value))
    throw new TransformDecodeCheckError(schema, value, Errors2(schema, references, value).First());
  return HasTransform(schema, references) ? TransformDecode(schema, references, value) : value;
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = HasTransform(schema, references) ? TransformEncode(schema, references, value) : value;
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, encoded, Errors2(schema, references, encoded).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value) {
  return Hash(value);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/esm/type/awaited/awaited.mjs
function FromRest4(T) {
  return T.map((L) => AwaitedResolve(L));
}
function FromIntersect14(T) {
  return Intersect(FromRest4(T));
}
function FromUnion16(T) {
  return Union(FromRest4(T));
}
function FromPromise6(T) {
  return AwaitedResolve(T);
}
function AwaitedResolve(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
}
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/esm/type/composite/composite.mjs
function CompositeKeys(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys(L));
  return SetDistinct(Acc);
}
function FilterNever(T) {
  return T.filter((L) => !IsNever(L));
}
function CompositeProperty(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys(L, [K]));
  return FilterNever(Acc);
}
function CompositeProperties(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated(CompositeProperty(T, L));
  }
  return Acc;
}
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/esm/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/esm/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/esm/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/esm/type/const/const.mjs
function FromArray14(T) {
  return T.map((L) => FromValue(L, false));
}
function FromProperties8(value2) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value2))
    Acc[K] = Readonly(FromValue(value2[K], false));
  return Acc;
}
function ConditionalReadonly(T, root) {
  return root === true ? T : Readonly(T);
}
function FromValue(value2, root) {
  return IsAsyncIterator2(value2) ? ConditionalReadonly(Any(), root) : IsIterator2(value2) ? ConditionalReadonly(Any(), root) : IsArray2(value2) ? Readonly(Tuple(FromArray14(value2))) : IsUint8Array2(value2) ? Uint8Array2() : IsDate2(value2) ? Date2() : IsObject2(value2) ? ConditionalReadonly(Object2(FromProperties8(value2)), root) : IsFunction2(value2) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value2) ? Undefined() : IsNull2(value2) ? Null() : IsSymbol2(value2) ? Symbol2() : IsBigInt2(value2) ? BigInt2() : IsNumber2(value2) ? Literal(value2) : IsBoolean2(value2) ? Literal(value2) : IsString2(value2) ? Literal(value2) : Object2({});
}
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/esm/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/deref/deref.mjs
function FromRest5(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
}
function FromProperties9(properties, references) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K] = Deref2(properties[K], references);
  }
  return Acc;
}
function FromConstructor7(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromFunction6(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
}
function FromIntersect15(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
}
function FromUnion17(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
}
function FromTuple14(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
}
function FromArray15(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromObject12(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
}
function FromPromise7(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
}
function FromAsyncIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromIterator6(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
}
function FromRef11(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard2 = Discard(target, ["$id"]);
  return Deref2(discard2, references);
}
function DerefResolve(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
}
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/esm/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value2) => Literal(value2));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude.mjs
function ExcludeRest(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
}
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/esm/type/exclude/exclude-from-mapped-result.mjs
function FromProperties10(P, U) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude(P[K2], U);
  return Acc;
}
function FromMappedResult7(R, T) {
  return FromProperties10(R.properties, T);
}
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract.mjs
function ExtractRest(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
}
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/esm/type/extract/extract-from-mapped-result.mjs
function FromProperties11(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract(P[K2], T);
  return Acc;
}
function FromMappedResult8(R, T) {
  return FromProperties11(R.properties, T);
}
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic-from-mapped-key.mjs
function MappedIntrinsicPropertyKey(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
}
function MappedIntrinsicPropertyKeys(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
}
function MappedIntrinsicProperties(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
}
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/intrinsic.mjs
function ApplyUncapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toLowerCase(), rest].join("");
}
function ApplyCapitalize(value2) {
  const [first, rest] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toUpperCase(), rest].join("");
}
function ApplyUppercase(value2) {
  return value2.toUpperCase();
}
function ApplyLowercase(value2) {
  return value2.toLowerCase();
}
function FromTemplateLiteral6(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite2 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite2)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value2) => Literal(value2));
  const mapped2 = FromRest6(literals, mode);
  const union3 = Union(mapped2);
  return TemplateLiteral([union3], options);
}
function FromLiteralValue(value2, mode) {
  return typeof value2 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value2) : mode === "Capitalize" ? ApplyCapitalize(value2) : mode === "Uppercase" ? ApplyUppercase(value2) : mode === "Lowercase" ? ApplyLowercase(value2) : value2 : value2.toString();
}
function FromRest6(T, M) {
  return T.map((L) => Intrinsic(L, M));
}
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/esm/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/esm/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/esm/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-result.mjs
function FromProperties12(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Omit(P[K2], K, options);
  return Acc;
}
function FromMappedResult9(R, K, options) {
  return FromProperties12(R.properties, K, options);
}
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit.mjs
function FromIntersect16(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromUnion18(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
}
function FromProperty2(T, K) {
  const { [K]: _, ...R } = T;
  return R;
}
function FromProperties13(T, K) {
  return K.reduce((T2, K2) => FromProperty2(T2, K2), T);
}
function OmitResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
}
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/omit/omit-from-mapped-key.mjs
function FromPropertyKey2(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
}
function FromPropertyKeys2(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
}
function FromMappedKey3(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
}
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/esm/type/partial/partial.mjs
function FromRest7(T) {
  return T.map((L) => PartialResolve(L));
}
function FromProperties14(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Optional(T[K]);
  return Acc;
}
function PartialResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
}
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/partial/partial-from-mapped-result.mjs
function FromProperties15(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial(K[K2], options);
  return Acc;
}
function FromMappedResult10(R, options) {
  return FromProperties15(R.properties, options);
}
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-result.mjs
function FromProperties16(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Pick(P[K2], K, options);
  return Acc;
}
function FromMappedResult11(R, K, options) {
  return FromProperties16(R.properties, K, options);
}
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick.mjs
function FromIntersect17(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromUnion19(T, K) {
  return T.map((T2) => PickResolve(T2, K));
}
function FromProperties17(T, K) {
  const Acc = {};
  for (const K2 of K)
    if (K2 in T)
      Acc[K2] = T[K2];
  return Acc;
}
function PickResolve(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
}
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/esm/type/pick/pick-from-mapped-key.mjs
function FromPropertyKey3(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
}
function FromPropertyKeys3(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
}
function FromMappedKey4(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
}
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/esm/type/record/record.mjs
function RecordCreateFromPattern(pattern2, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern2]: CloneType(T) }
  };
}
function RecordCreateFromKeys(K, T, options) {
  const Acc = {};
  for (const K2 of K)
    Acc[K2] = CloneType(T);
  return Object2(Acc, { ...options, [Hint]: "Record" });
}
function FromTemplateLiteralKey(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
}
function FromUnionKey(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
}
function FromLiteralKey(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
}
function FromRegExpKey(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
}
function FromStringKey(K, T, options) {
  const pattern2 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern2, T, options);
}
function FromIntegerKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function FromNumberKey(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
}
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/esm/type/recursive/recursive.mjs
var Ordinal = 0;
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
// node_modules/@sinclair/typebox/build/esm/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/esm/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/esm/type/required/required.mjs
function FromRest8(T) {
  return T.map((L) => RequiredResolve(L));
}
function FromProperties18(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Discard(T[K], [OptionalKind]);
  return Acc;
}
function RequiredResolve(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
}
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/esm/type/required/required-from-mapped-result.mjs
function FromProperties19(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required(P[K2], options);
  return Acc;
}
function FromMappedResult12(R, options) {
  return FromProperties19(R.properties, options);
}
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/esm/type/rest/rest.mjs
function RestResolve(T) {
  return IsIntersect(T) ? CloneRest(T.allOf) : IsUnion(T) ? CloneRest(T.anyOf) : IsTuple(T) ? CloneRest(T.items ?? []) : [];
}
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/esm/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/esm/type/strict/strict.mjs
function Strict(schema2) {
  return JSON.parse(JSON.stringify(schema2));
}
// node_modules/@sinclair/typebox/build/esm/type/transform/transform.mjs
class TransformDecodeBuilder {
  constructor(schema2) {
    this.schema = schema2;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  constructor(schema2, decode2) {
    this.schema = schema2;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema2) {
    const Encode2 = (value2) => schema2[TransformKind].Encode(encode2(value2));
    const Decode2 = (value2) => this.decode(schema2[TransformKind].Decode(value2));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema2) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema2 = CloneType(this.schema);
    return IsTransform(schema2) ? this.EncodeTransform(encode2, schema2) : this.EncodeSchema(encode2, schema2);
  }
}
function Transform(schema2) {
  return new TransformDecodeBuilder(schema2);
}
// node_modules/@sinclair/typebox/build/esm/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/esm/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => Void,
  Uppercase: () => Uppercase,
  Unsafe: () => Unsafe,
  Unknown: () => Unknown,
  Union: () => Union,
  Undefined: () => Undefined,
  Uncapitalize: () => Uncapitalize,
  Uint8Array: () => Uint8Array2,
  Tuple: () => Tuple,
  Transform: () => Transform,
  TemplateLiteral: () => TemplateLiteral,
  Symbol: () => Symbol2,
  String: () => String2,
  Strict: () => Strict,
  ReturnType: () => ReturnType,
  Rest: () => Rest,
  Required: () => Required,
  RegExp: () => RegExp2,
  Ref: () => Ref,
  Recursive: () => Recursive,
  Record: () => Record,
  ReadonlyOptional: () => ReadonlyOptional,
  Readonly: () => Readonly,
  Promise: () => Promise2,
  Pick: () => Pick,
  Partial: () => Partial,
  Parameters: () => Parameters,
  Optional: () => Optional,
  Omit: () => Omit,
  Object: () => Object2,
  Number: () => Number2,
  Null: () => Null,
  Not: () => Not2,
  Never: () => Never,
  Mapped: () => Mapped,
  Lowercase: () => Lowercase,
  Literal: () => Literal,
  KeyOf: () => KeyOf,
  Iterator: () => Iterator,
  Intersect: () => Intersect,
  Integer: () => Integer,
  InstanceType: () => InstanceType,
  Index: () => Index,
  Function: () => Function2,
  Extract: () => Extract,
  Extends: () => Extends,
  Exclude: () => Exclude,
  Enum: () => Enum,
  Deref: () => Deref2,
  Date: () => Date2,
  ConstructorParameters: () => ConstructorParameters,
  Constructor: () => Constructor,
  Const: () => Const,
  Composite: () => Composite,
  Capitalize: () => Capitalize,
  Boolean: () => Boolean2,
  BigInt: () => BigInt2,
  Awaited: () => Awaited,
  AsyncIterator: () => AsyncIterator,
  Array: () => Array2,
  Any: () => Any
});

// node_modules/@sinclair/typebox/build/esm/type/type/index.mjs
var Type = exports_type3;
// node_modules/@sinclair/typebox/build/esm/compiler/compiler.mjs
class TypeCheck {
  constructor(schema3, references, checkFunc, code) {
    this.schema = schema3;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema3, references);
  }
  Code() {
    return this.code;
  }
  Errors(value2) {
    return Errors(this.schema, this.references, value2);
  }
  Check(value2) {
    return this.checkFunc(value2);
  }
  Decode(value2) {
    if (!this.checkFunc(value2))
      throw new TransformDecodeCheckError(this.schema, value2, this.Errors(value2).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value2) : value2;
  }
  Encode(value2) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value2) : value2;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value2, this.Errors(value2).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value2) {
    if (value2.length === 0)
      return false;
    return Character.IsNumeric(value2.charCodeAt(0));
  }
  function IsAccessor(value2) {
    if (IsFirstCharacterNumeric(value2))
      return false;
    for (let i = 0;i < value2.length; i++) {
      const code = value2.charCodeAt(i);
      const check3 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check3)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object3, key) {
    return IsAccessor(key) ? `${object3}.${key}` : `${object3}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  constructor(schema3) {
    super("Unknown type");
    this.schema = schema3;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  constructor(schema3) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema3;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value2, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value2} ? ${expression} : true)` : `(${MemberExpression.Encode(value2, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}))` : `(typeof ${value2} === 'object' && ${value2} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value2) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value2} === 'object' && ${value2} !== null && !Array.isArray(${value2}) && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))` : `(typeof ${value2} === 'object' && ${value2} !== null && !(${value2} instanceof Date) && !(${value2} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value2) {
    return TypeSystemPolicy.AllowNaN ? `typeof ${value2} === 'number'` : `Number.isFinite(${value2})`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value2) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value2} === undefined || ${value2} === null)` : `${value2} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema3) {
    return schema3[Kind] === "Any" || schema3[Kind] === "Unknown";
  }
  function* FromAny5(schema3, references, value2) {
    yield "true";
  }
  function* FromArray16(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema3.maxItems))
      yield `${value2}.length <= ${schema3.maxItems}`;
    if (IsNumber(schema3.minItems))
      yield `${value2}.length >= ${schema3.minItems}`;
    const elementExpression = CreateExpression(schema3.items, references, "value");
    yield `${value2}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema2(schema3.contains) || IsNumber(schema3.minContains) || IsNumber(schema3.maxContains)) {
      const containsSchema = IsSchema2(schema3.contains) ? schema3.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
      const checkMaxContains = IsNumber(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check3 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check3}})(${value2})`;
    }
    if (schema3.uniqueItems === true) {
      const check3 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check3} }`;
      yield `((${parameter}) => { ${block} )(${value2})`;
    }
  }
  function* FromAsyncIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value2})`;
  }
  function* FromBigInt6(schema3, references, value2) {
    yield `(typeof ${value2} === 'bigint')`;
    if (IsBigInt(schema3.exclusiveMaximum))
      yield `${value2} < BigInt(${schema3.exclusiveMaximum})`;
    if (IsBigInt(schema3.exclusiveMinimum))
      yield `${value2} > BigInt(${schema3.exclusiveMinimum})`;
    if (IsBigInt(schema3.maximum))
      yield `${value2} <= BigInt(${schema3.maximum})`;
    if (IsBigInt(schema3.minimum))
      yield `${value2} >= BigInt(${schema3.minimum})`;
    if (IsBigInt(schema3.multipleOf))
      yield `(${value2} % BigInt(${schema3.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema3, references, value2) {
    yield `(typeof ${value2} === 'boolean')`;
  }
  function* FromConstructor8(schema3, references, value2) {
    yield* Visit17(schema3.returns, references, `${value2}.prototype`);
  }
  function* FromDate6(schema3, references, value2) {
    yield `(${value2} instanceof Date) && Number.isFinite(${value2}.getTime())`;
    if (IsNumber(schema3.exclusiveMaximumTimestamp))
      yield `${value2}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema3.exclusiveMinimumTimestamp))
      yield `${value2}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema3.maximumTimestamp))
      yield `${value2}.getTime() <= ${schema3.maximumTimestamp}`;
    if (IsNumber(schema3.minimumTimestamp))
      yield `${value2}.getTime() >= ${schema3.minimumTimestamp}`;
    if (IsNumber(schema3.multipleOfTimestamp))
      yield `(${value2}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema3, references, value2) {
    yield `(typeof ${value2} === 'function')`;
  }
  function* FromInteger6(schema3, references, value2) {
    yield `Number.isInteger(${value2})`;
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema3, references, value2) {
    const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value2)).join(" && ");
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema2(schema3.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value2}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value2}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema3, references, value2) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value2})`;
  }
  function* FromLiteral7(schema3, references, value2) {
    if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
      yield `(${value2} === ${schema3.const})`;
    } else {
      yield `(${value2} === '${LiteralString.Escape(schema3.const)}')`;
    }
  }
  function* FromNever6(schema3, references, value2) {
    yield `false`;
  }
  function* FromNot8(schema3, references, value2) {
    const expression = CreateExpression(schema3.not, references, value2);
    yield `(!${expression})`;
  }
  function* FromNull6(schema3, references, value2) {
    yield `(${value2} === null)`;
  }
  function* FromNumber6(schema3, references, value2) {
    yield Policy.IsNumberLike(value2);
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value2} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value2} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value2} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value2} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value2} % ${schema3.multipleOf}) === 0`;
  }
  function* FromObject13(schema3, references, value2) {
    yield Policy.IsObjectLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value2, knownKey);
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value2})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value2, knownKey, expression);
      }
    }
    if (schema3.additionalProperties === false) {
      if (schema3.required && schema3.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value2}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      const expression = CreateExpression(schema3.additionalProperties, references, `${value2}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value2}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema3, references, value2) {
    yield `(typeof value === 'object' && typeof ${value2}.then === 'function')`;
  }
  function* FromRecord12(schema3, references, value2) {
    yield Policy.IsRecordLike(value2);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value2}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value2}).length <= ${schema3.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema2(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value2) : schema3.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value2}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema3, references, value2) {
    const target = Deref(schema3, references);
    if (state.functions.has(schema3.$ref))
      return yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
    yield* Visit17(target, references, value2);
  }
  function* FromRegExp5(schema3, references, value2) {
    const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    yield `${variable}.test(${value2})`;
  }
  function* FromString6(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value2}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value2}.length >= ${schema3.minLength}`;
    if (schema3.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value2})`;
    }
    if (schema3.format !== undefined) {
      yield `format('${schema3.format}', ${value2})`;
    }
  }
  function* FromSymbol6(schema3, references, value2) {
    yield `(typeof ${value2} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema3, references, value2) {
    yield `(typeof ${value2} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
    yield `${variable}.test(${value2})`;
  }
  function* FromThis11(schema3, references, value2) {
    yield `${CreateFunctionName(schema3.$ref)}(${value2})`;
  }
  function* FromTuple15(schema3, references, value2) {
    yield `Array.isArray(${value2})`;
    if (schema3.items === undefined)
      return yield `${value2}.length === 0`;
    yield `(${value2}.length === ${schema3.maxItems})`;
    for (let i = 0;i < schema3.items.length; i++) {
      const expression = CreateExpression(schema3.items[i], references, `${value2}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema3, references, value2) {
    yield `${value2} === undefined`;
  }
  function* FromUnion20(schema3, references, value2) {
    const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value2));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema3, references, value2) {
    yield `${value2} instanceof Uint8Array`;
    if (IsNumber(schema3.maxByteLength))
      yield `(${value2}.length <= ${schema3.maxByteLength})`;
    if (IsNumber(schema3.minByteLength))
      yield `(${value2}.length >= ${schema3.minByteLength})`;
  }
  function* FromUnknown5(schema3, references, value2) {
    yield "true";
  }
  function* FromVoid5(schema3, references, value2) {
    yield Policy.IsVoidLike(value2);
  }
  function* FromKind4(schema3, references, value2) {
    const instance = state.instances.size;
    state.instances.set(instance, schema3);
    yield `kind('${schema3[Kind]}', ${instance}, ${value2})`;
  }
  function* Visit17(schema3, references, value2, useHoisting = true) {
    const references_ = IsString(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (useHoisting && IsString(schema3.$id)) {
      const functionName = CreateFunctionName(schema3.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value2})`;
      } else {
        const functionCode = CreateFunction(functionName, schema3, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value2})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value2);
      case "Array":
        return yield* FromArray16(schema_, references_, value2);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value2);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value2);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value2);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value2);
      case "Date":
        return yield* FromDate6(schema_, references_, value2);
      case "Function":
        return yield* FromFunction7(schema_, references_, value2);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value2);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value2);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value2);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value2);
      case "Never":
        return yield* FromNever6(schema_, references_, value2);
      case "Not":
        return yield* FromNot8(schema_, references_, value2);
      case "Null":
        return yield* FromNull6(schema_, references_, value2);
      case "Number":
        return yield* FromNumber6(schema_, references_, value2);
      case "Object":
        return yield* FromObject13(schema_, references_, value2);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value2);
      case "Record":
        return yield* FromRecord12(schema_, references_, value2);
      case "Ref":
        return yield* FromRef12(schema_, references_, value2);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value2);
      case "String":
        return yield* FromString6(schema_, references_, value2);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value2);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value2);
      case "This":
        return yield* FromThis11(schema_, references_, value2);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value2);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value2);
      case "Union":
        return yield* FromUnion20(schema_, references_, value2);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value2);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value2);
      case "Void":
        return yield* FromVoid5(schema_, references_, value2);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema3);
        return yield* FromKind4(schema_, references_, value2);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema3, references, value2, useHoisting = true) {
    return `(${[...Visit17(schema3, references, value2, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema3, references, value2, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema3, references, value2, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type3) {
    const annotation = state.language === "typescript" ? `: ${type3}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type3) {
    return state.language === "typescript" ? `: ${type3}` : "";
  }
  function Build(schema3, references, options) {
    const functionCode = CreateFunction("check", schema3, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema3.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema3.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema3, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema2(schema3))
      throw new TypeCompilerTypeGuardError(schema3);
    for (const schema4 of references)
      if (!IsSchema2(schema4))
        throw new TypeCompilerTypeGuardError(schema4);
    return Build(schema3, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema3, references = []) {
    const generatedCode = Code(schema3, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value2) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema4 = instances.get(instance);
      return checkFunc(schema4, value2);
    }
    function formatRegistryFunction(format, value2) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value2);
    }
    function hashFunction(value2) {
      return Hash(value2);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema3, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/elysia/dist/bun/index.js
var __create2 = Object.create;
var { getPrototypeOf: __getProtoOf2, defineProperty: __defProp2, getOwnPropertyNames: __getOwnPropNames2 } = Object;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __toESM2 = (mod, isNodeMode, target) => {
  target = mod != null ? __create2(__getProtoOf2(mod)) : {};
  let to = isNodeMode || !mod || !mod.__esModule ? __defProp2(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames2(mod))
    if (!__hasOwnProp2.call(to, key))
      __defProp2(to, key, { get: () => mod[key], enumerable: true });
  return to;
};
var __commonJS2 = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var require_dist = __commonJS2((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = parse2;
  exports.serialize = serialize;
  var cookieNameRegExp = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/, cookieValueRegExp = /^("?)[\u0021\u0023-\u002B\u002D-\u003A\u003C-\u005B\u005D-\u007E]*\1$/, domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i, pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/, __toString = Object.prototype.toString, NullObject = (() => {
    let C = function() {
    };
    return C.prototype = Object.create(null), C;
  })();
  function parse2(str, options) {
    let obj = new NullObject, len = str.length;
    if (len < 2)
      return obj;
    let dec = options?.decode || decode2, index = 0;
    do {
      let eqIdx = str.indexOf("=", index);
      if (eqIdx === -1)
        break;
      let colonIdx = str.indexOf(";", index), endIdx = colonIdx === -1 ? len : colonIdx;
      if (eqIdx > endIdx) {
        index = str.lastIndexOf(";", eqIdx - 1) + 1;
        continue;
      }
      let keyStartIdx = startIndex(str, index, eqIdx), keyEndIdx = endIndex(str, eqIdx, keyStartIdx), key = str.slice(keyStartIdx, keyEndIdx);
      if (obj[key] === undefined) {
        let valStartIdx = startIndex(str, eqIdx + 1, endIdx), valEndIdx = endIndex(str, endIdx, valStartIdx), value2 = dec(str.slice(valStartIdx, valEndIdx));
        obj[key] = value2;
      }
      index = endIdx + 1;
    } while (index < len);
    return obj;
  }
  function startIndex(str, index, max) {
    do {
      let code = str.charCodeAt(index);
      if (code !== 32 && code !== 9)
        return index;
    } while (++index < max);
    return max;
  }
  function endIndex(str, index, min) {
    while (index > min) {
      let code = str.charCodeAt(--index);
      if (code !== 32 && code !== 9)
        return index + 1;
    }
    return min;
  }
  function serialize(name, val, options) {
    let enc = options?.encode || encodeURIComponent;
    if (!cookieNameRegExp.test(name))
      throw new TypeError(`argument name is invalid: ${name}`);
    let value2 = enc(val);
    if (!cookieValueRegExp.test(value2))
      throw new TypeError(`argument val is invalid: ${val}`);
    let str = name + "=" + value2;
    if (!options)
      return str;
    if (options.maxAge !== undefined) {
      if (!Number.isInteger(options.maxAge))
        throw new TypeError(`option maxAge is invalid: ${options.maxAge}`);
      str += "; Max-Age=" + options.maxAge;
    }
    if (options.domain) {
      if (!domainValueRegExp.test(options.domain))
        throw new TypeError(`option domain is invalid: ${options.domain}`);
      str += "; Domain=" + options.domain;
    }
    if (options.path) {
      if (!pathValueRegExp.test(options.path))
        throw new TypeError(`option path is invalid: ${options.path}`);
      str += "; Path=" + options.path;
    }
    if (options.expires) {
      if (!isDate(options.expires) || !Number.isFinite(options.expires.valueOf()))
        throw new TypeError(`option expires is invalid: ${options.expires}`);
      str += "; Expires=" + options.expires.toUTCString();
    }
    if (options.httpOnly)
      str += "; HttpOnly";
    if (options.secure)
      str += "; Secure";
    if (options.partitioned)
      str += "; Partitioned";
    if (options.priority)
      switch (typeof options.priority === "string" ? options.priority.toLowerCase() : options.sameSite) {
        case "low":
          str += "; Priority=Low";
          break;
        case "medium":
          str += "; Priority=Medium";
          break;
        case "high":
          str += "; Priority=High";
          break;
        default:
          throw new TypeError(`option priority is invalid: ${options.priority}`);
      }
    if (options.sameSite)
      switch (typeof options.sameSite === "string" ? options.sameSite.toLowerCase() : options.sameSite) {
        case true:
        case "strict":
          str += "; SameSite=Strict";
          break;
        case "lax":
          str += "; SameSite=Lax";
          break;
        case "none":
          str += "; SameSite=None";
          break;
        default:
          throw new TypeError(`option sameSite is invalid: ${options.sameSite}`);
      }
    return str;
  }
  function decode2(str) {
    if (str.indexOf("%") === -1)
      return str;
    try {
      return decodeURIComponent(str);
    } catch (e) {
      return str;
    }
  }
  function isDate(val) {
    return __toString.call(val) === "[object Date]";
  }
});
var require_fast_decode_uri_component = __commonJS2((exports, module) => {
  var UTF8_ACCEPT = 12, UTF8_REJECT = 0, UTF8_DATA = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7];
  function decodeURIComponent2(uri2) {
    var percentPosition = uri2.indexOf("%");
    if (percentPosition === -1)
      return uri2;
    var length = uri2.length, decoded = "", last = 0, codepoint = 0, startOfOctets = percentPosition, state = UTF8_ACCEPT;
    while (percentPosition > -1 && percentPosition < length) {
      var high = hexCodeToInt(uri2[percentPosition + 1], 4), low = hexCodeToInt(uri2[percentPosition + 2], 0), byte2 = high | low, type3 = UTF8_DATA[byte2];
      if (state = UTF8_DATA[256 + state + type3], codepoint = codepoint << 6 | byte2 & UTF8_DATA[364 + type3], state === UTF8_ACCEPT)
        decoded += uri2.slice(last, startOfOctets), decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(55232 + (codepoint >> 10), 56320 + (codepoint & 1023)), codepoint = 0, last = percentPosition + 3, percentPosition = startOfOctets = uri2.indexOf("%", last);
      else if (state === UTF8_REJECT)
        return null;
      else {
        if (percentPosition += 3, percentPosition < length && uri2.charCodeAt(percentPosition) === 37)
          continue;
        return null;
      }
    }
    return decoded + uri2.slice(last);
  }
  var HEX = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  function hexCodeToInt(c, shift) {
    var i = HEX[c];
    return i === undefined ? 255 : i << shift;
  }
  module.exports = decodeURIComponent2;
});
var U = (z, q) => {
  let v = q?.length ? {} : null;
  if (v)
    for (let K of q)
      v[K.part.charCodeAt(0)] = K;
  return { part: z, store: null, inert: v, params: null, wildcardStore: null };
};
var _ = (z, q) => ({ ...z, part: q });
var $ = (z) => ({ name: z, store: null, inert: null });

class Y {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g, optionalParams: /:.+?\?(?=\/|$)/g };
  add(z, q, v, { ignoreError: K = false, ignoreHistory: V = false } = {}) {
    if (typeof q !== "string")
      throw new TypeError("Route path must be a string");
    if (q === "")
      q = "/";
    else if (q[0] !== "/")
      q = `/${q}`;
    let S = q[q.length - 1] === "*", D = q.match(Y.regex.optionalParams);
    if (D) {
      let F = q.replaceAll("?", "");
      this.add(z, F, v, { ignoreError: K });
      for (let B = 0;B < D.length; B++) {
        let A = q.replace("/" + D[B], "");
        this.add(z, A, v, { ignoreError: true });
      }
      return v;
    }
    if (D)
      q = q.replaceAll("?", "");
    if (this.history.find(([F, B, A]) => F === z && B === q))
      return v;
    if (S || D && q.charCodeAt(q.length - 1) === 63)
      q = q.slice(0, -1);
    if (!V)
      this.history.push([z, q, v]);
    let G = q.split(Y.regex.static), J = q.match(Y.regex.params) || [];
    if (G[G.length - 1] === "")
      G.pop();
    let b;
    if (!this.root[z])
      b = this.root[z] = U("/");
    else
      b = this.root[z];
    let Q = 0;
    for (let F = 0;F < G.length; ++F) {
      let B = G[F];
      if (F > 0) {
        let A = J[Q++].slice(1);
        if (b.params === null)
          b.params = $(A);
        else if (b.params.name !== A)
          if (K)
            return v;
          else
            throw new Error(`Cannot create route "${q}" with parameter "${A}" because a route already exists with a different parameter name ("${b.params.name}") in the same location`);
        let O = b.params;
        if (O.inert === null) {
          b = O.inert = U(B);
          continue;
        }
        b = O.inert;
      }
      for (let A = 0;; ) {
        if (A === B.length) {
          if (A < b.part.length) {
            let O = _(b, b.part.slice(A));
            Object.assign(b, U(B, [O]));
          }
          break;
        }
        if (A === b.part.length) {
          if (b.inert === null)
            b.inert = {};
          let O = b.inert[B.charCodeAt(A)];
          if (O) {
            b = O, B = B.slice(A), A = 0;
            continue;
          }
          let X = U(B.slice(A));
          b.inert[B.charCodeAt(A)] = X, b = X;
          break;
        }
        if (B[A] !== b.part[A]) {
          let O = _(b, b.part.slice(A)), X = U(B.slice(A));
          Object.assign(b, U(b.part.slice(0, A), [O, X])), b = X;
          break;
        }
        ++A;
      }
    }
    if (Q < J.length) {
      let B = J[Q].slice(1);
      if (b.params === null)
        b.params = $(B);
      else if (b.params.name !== B)
        if (K)
          return v;
        else
          throw new Error(`Cannot create route "${q}" with parameter "${B}" because a route already exists with a different parameter name ("${b.params.name}") in the same location`);
      if (b.params.store === null)
        b.params.store = v;
      return b.params.store;
    }
    if (S) {
      if (b.wildcardStore === null)
        b.wildcardStore = v;
      return b.wildcardStore;
    }
    if (b.store === null)
      b.store = v;
    return b.store;
  }
  find(z, q) {
    let v = this.root[z];
    if (!v)
      return null;
    return Z(q, q.length, v, 0);
  }
}
var Z = (z, q, v, K) => {
  let V = v.part, S = V.length, D = K + S;
  if (S > 1) {
    if (D > q)
      return null;
    if (S < 15) {
      for (let G = 1, J = K + 1;G < S; ++G, ++J)
        if (V.charCodeAt(G) !== z.charCodeAt(J))
          return null;
    } else if (z.slice(K, D) !== V)
      return null;
  }
  if (D === q) {
    if (v.store !== null)
      return { store: v.store, params: {} };
    if (v.wildcardStore !== null)
      return { store: v.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (v.inert !== null) {
    let G = v.inert[z.charCodeAt(D)];
    if (G !== undefined) {
      let J = Z(z, q, G, D);
      if (J !== null)
        return J;
    }
  }
  if (v.params !== null) {
    let { store: G, name: J, inert: b } = v.params, Q = z.indexOf("/", D);
    if (Q !== D) {
      if (Q === -1 || Q >= q) {
        if (G !== null) {
          let F = {};
          return F[J] = z.substring(D, q), { store: G, params: F };
        }
      } else if (b !== null) {
        let F = Z(z, q, b, Q);
        if (F !== null)
          return F.params[J] = z.substring(D, Q), F;
      }
    }
  }
  if (v.wildcardStore !== null)
    return { store: v.wildcardStore, params: { "*": z.substring(D, q) } };
  return null;
};
var hasReturn = (fn) => {
  let fnLiteral = typeof fn === "object" ? fn.fn.toString() : typeof fn === "string" ? fn.toString() : fn, parenthesisEnd = fnLiteral.indexOf(")");
  if (fnLiteral.charCodeAt(parenthesisEnd + 2) === 61 && fnLiteral.charCodeAt(parenthesisEnd + 5) !== 123)
    return true;
  return fnLiteral.includes("return");
};
var separateFunction = (code) => {
  if (code.startsWith("async"))
    code = code.slice(5);
  code = code.trimStart();
  let index = -1;
  if (code.charCodeAt(0) === 40) {
    if (index = code.indexOf("=>", code.indexOf(")")), index !== -1) {
      let bracketEndIndex = index;
      while (bracketEndIndex > 0)
        if (code.charCodeAt(--bracketEndIndex) === 41)
          break;
      let body = code.slice(index + 2);
      if (body.charCodeAt(0) === 32)
        body = body.trimStart();
      return [code.slice(1, bracketEndIndex), body, { isArrowReturn: body.charCodeAt(0) !== 123 }];
    }
  }
  if (code.startsWith("function")) {
    index = code.indexOf("(");
    let end = code.indexOf(")");
    return [code.slice(index + 1, end), code.slice(end + 2), { isArrowReturn: false }];
  }
  let start = code.indexOf("(");
  if (start !== -1) {
    let sep = code.indexOf(`
`, 2), parameter = code.slice(0, sep), end = parameter.lastIndexOf(")") + 1, body = code.slice(sep + 1);
    return [parameter.slice(start, end), "{" + body, { isArrowReturn: false }];
  }
  let x = code.split(`
`, 2);
  return [x[0], x[1], { isArrowReturn: false }];
};
var bracketPairRange = (parameter) => {
  let start = parameter.indexOf("{");
  if (start === -1)
    return [-1, 0];
  let end = start + 1, deep = 1;
  for (;end < parameter.length; end++) {
    let char = parameter.charCodeAt(end);
    if (char === 123)
      deep++;
    else if (char === 125)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [0, parameter.length];
  return [start, end + 1];
};
var bracketPairRangeReverse = (parameter) => {
  let end = parameter.lastIndexOf("}");
  if (end === -1)
    return [-1, 0];
  let start = end - 1, deep = 1;
  for (;start >= 0; start--) {
    let char = parameter.charCodeAt(start);
    if (char === 125)
      deep++;
    else if (char === 123)
      deep--;
    if (deep === 0)
      break;
  }
  if (deep !== 0)
    return [-1, 0];
  return [start, end + 1];
};
var removeColonAlias = (parameter) => {
  while (true) {
    let start = parameter.indexOf(":");
    if (start === -1)
      break;
    let end = parameter.indexOf(",", start);
    if (end === -1)
      end = parameter.indexOf("}", start) - 1;
    if (end === -2)
      end = parameter.length;
    parameter = parameter.slice(0, start) + parameter.slice(end);
  }
  return parameter;
};
var retrieveRootParamters = (parameter) => {
  let hasParenthesis = false;
  if (parameter.charCodeAt(0) === 40)
    parameter = parameter.slice(1, -1);
  if (parameter.charCodeAt(0) === 123)
    hasParenthesis = true, parameter = parameter.slice(1, -1);
  parameter = parameter.replace(/( |\t|\n)/g, "").trim();
  let parameters3 = [];
  while (true) {
    let [start, end] = bracketPairRange(parameter);
    if (start === -1)
      break;
    if (parameters3.push(parameter.slice(0, start - 1)), parameter.charCodeAt(end) === 44)
      end++;
    parameter = parameter.slice(end);
  }
  if (parameter = removeColonAlias(parameter), parameter)
    parameters3 = parameters3.concat(parameter.split(","));
  let newParameters = [];
  for (let p of parameters3) {
    if (p.indexOf(",") === -1) {
      newParameters.push(p);
      continue;
    }
    for (let q of p.split(","))
      newParameters.push(q.trim());
  }
  return parameters3 = newParameters, { hasParenthesis, parameters: parameters3 };
};
var findParameterReference = (parameter, inference) => {
  let { parameters: parameters3, hasParenthesis } = retrieveRootParamters(parameter);
  if (!inference.query && parameters3.includes("query"))
    inference.query = true;
  if (!inference.headers && parameters3.includes("headers"))
    inference.headers = true;
  if (!inference.body && parameters3.includes("body"))
    inference.body = true;
  if (!inference.cookie && parameters3.includes("cookie"))
    inference.cookie = true;
  if (!inference.set && parameters3.includes("set"))
    inference.set = true;
  if (!inference.server && parameters3.includes("server"))
    inference.server = true;
  if (hasParenthesis)
    return `{ ${parameters3.join(", ")} }`;
  return parameters3.join(", ");
};
var findEndIndex = (type3, content, index) => {
  let newLineIndex = content.indexOf(type3 + `
`, index), newTabIndex = content.indexOf(type3 + "\t", index), commaIndex = content.indexOf(type3 + ",", index), semicolonIndex = content.indexOf(type3 + ";", index), emptyIndex = content.indexOf(type3 + " ", index);
  return [newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex].filter((i) => i > 0).sort((a, b) => a - b)[0] || -1;
};
var findAlias = (type3, body, depth = 0) => {
  if (depth > 5)
    return [];
  let aliases = [], content = body;
  while (true) {
    let index = findEndIndex(" = " + type3, content);
    if (index === -1) {
      let lastIndex = content.indexOf(" = " + type3);
      if (lastIndex + 3 + type3.length !== content.length)
        break;
      index = lastIndex;
    }
    let part = content.slice(0, index), variable = part.slice(part.lastIndexOf(" ") + 1);
    if (variable === "}") {
      let [start, end] = bracketPairRangeReverse(part);
      aliases.push(removeColonAlias(content.slice(start, end))), content = content.slice(index + 3 + type3.length);
      continue;
    }
    while (variable.charCodeAt(0) === 44)
      variable = variable.slice(1);
    while (variable.charCodeAt(0) === 9)
      variable = variable.slice(1);
    if (!variable.includes("("))
      aliases.push(variable);
    content = content.slice(index + 3 + type3.length);
  }
  for (let alias of aliases) {
    if (alias.charCodeAt(0) === 123)
      continue;
    let deepAlias = findAlias(alias, body);
    if (deepAlias.length > 0)
      aliases.push(...deepAlias);
  }
  return aliases;
};
var extractMainParameter = (parameter) => {
  if (!parameter)
    return;
  if (parameter.charCodeAt(0) !== 123)
    return parameter;
  if (parameter = parameter.slice(2, -2), !parameter.includes(",")) {
    if (parameter.includes("..."))
      return parameter.slice(parameter.indexOf("...") + 3);
    return;
  }
  let spreadIndex = parameter.indexOf("...");
  if (spreadIndex === -1)
    return;
  return parameter.slice(spreadIndex + 3).trimEnd();
};
var inferBodyReference = (code, aliases, inference) => {
  let access = (type3, alias) => code.includes(alias + "." + type3) || code.includes(alias + '["' + type3 + '"]') || code.includes(alias + "['" + type3 + "']");
  for (let alias of aliases) {
    if (!alias)
      continue;
    if (alias.charCodeAt(0) === 123) {
      let parameters3 = retrieveRootParamters(alias).parameters;
      if (!inference.query && parameters3.includes("query"))
        inference.query = true;
      if (!inference.headers && parameters3.includes("headers"))
        inference.headers = true;
      if (!inference.body && parameters3.includes("body"))
        inference.body = true;
      if (!inference.cookie && parameters3.includes("cookie"))
        inference.cookie = true;
      if (!inference.set && parameters3.includes("set"))
        inference.set = true;
      if (!inference.query && parameters3.includes("server"))
        inference.server = true;
      continue;
    }
    if (!inference.query && access("query", alias))
      inference.query = true;
    if (code.includes("return " + alias) || code.includes("return " + alias + ".query"))
      inference.query = true;
    if (!inference.headers && access("headers", alias))
      inference.headers = true;
    if (!inference.body && access("body", alias))
      inference.body = true;
    if (!inference.cookie && access("cookie", alias))
      inference.cookie = true;
    if (!inference.set && access("set", alias))
      inference.set = true;
    if (!inference.server && access("server", alias))
      inference.server = true;
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server)
      break;
  }
  return aliases;
};
var isContextPassToFunction = (context, body, inference) => {
  try {
    let captureFunction = new RegExp(`(?:\\w)\\((?:.*)?${context}`, "gs");
    captureFunction.test(body);
    let nextChar = body.charCodeAt(captureFunction.lastIndex);
    if (nextChar === 41 || nextChar === 44)
      return inference.query = true, inference.headers = true, inference.body = true, inference.cookie = true, inference.set = true, inference.server = true, true;
    return false;
  } catch (error3) {
    return console.log("[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:"), console.log("--- body ---"), console.log(body), console.log("--- context ---"), console.log(context), true;
  }
};
var sucrose = (lifeCycle, inference = { query: false, headers: false, body: false, cookie: false, set: false, server: false }) => {
  let events = [];
  if (lifeCycle.handler && typeof lifeCycle.handler === "function")
    events.push(lifeCycle.handler);
  if (lifeCycle.request?.length)
    events.push(...lifeCycle.request);
  if (lifeCycle.beforeHandle?.length)
    events.push(...lifeCycle.beforeHandle);
  if (lifeCycle.parse?.length)
    events.push(...lifeCycle.parse);
  if (lifeCycle.error?.length)
    events.push(...lifeCycle.error);
  if (lifeCycle.transform?.length)
    events.push(...lifeCycle.transform);
  if (lifeCycle.afterHandle?.length)
    events.push(...lifeCycle.afterHandle);
  if (lifeCycle.mapResponse?.length)
    events.push(...lifeCycle.mapResponse);
  if (lifeCycle.afterResponse?.length)
    events.push(...lifeCycle.afterResponse);
  for (let e of events) {
    if (!e)
      continue;
    let event = "fn" in e ? e.fn : e, [parameter, body, { isArrowReturn }] = separateFunction(event.toString()), rootParameters = findParameterReference(parameter, inference), mainParameter = extractMainParameter(rootParameters);
    if (mainParameter) {
      let aliases = findAlias(mainParameter, body);
      if (aliases.splice(0, -1, mainParameter), !isContextPassToFunction(mainParameter, body, inference))
        inferBodyReference(body, aliases, inference);
      if (!inference.query && body.includes("return " + mainParameter + ".query"))
        inference.query = true;
    }
    if (inference.query && inference.headers && inference.body && inference.cookie && inference.set && inference.server)
      break;
  }
  return inference;
};
var fullFormats = { date: date3, time: getTime(true), "date-time": getDateTime(true), "iso-time": getTime(false), "iso-date-time": getDateTime(false), duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/, uri, "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i, "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i, url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu, email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i, hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i, ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/, ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i, regex, uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i, "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/, "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i, "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/, byte, int32: { type: "number", validate: validateInt32 }, int64: { type: "number", validate: validateInt64 }, float: { type: "number", validate: validateNumber }, double: { type: "number", validate: validateNumber }, password: true, binary: true };
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function date3(str) {
  let matches = DATE.exec(str);
  if (!matches)
    return false;
  let year = +matches[1], month = +matches[2], day = +matches[3];
  return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
function getTime(strictTimeZone) {
  return function time(str) {
    let matches = TIME.exec(str);
    if (!matches)
      return false;
    let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
    if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
      return false;
    if (hr <= 23 && min <= 59 && sec < 60)
      return true;
    let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
    return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
  };
}
var DATE_TIME_SEPARATOR = /t|\s/i;
function getDateTime(strictTimeZone) {
  let time = getTime(strictTimeZone);
  return function date_time(str) {
    let dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date3(dateTime[0]) && time(dateTime[1]);
  };
}
var NOT_URI_FRAGMENT = /\/|:/;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
  return BYTE.lastIndex = 0, BYTE.test(str);
}
var MIN_INT32 = -2147483648;
var MAX_INT32 = 2147483647;
function validateInt32(value2) {
  return Number.isInteger(value2) && value2 <= MAX_INT32 && value2 >= MIN_INT32;
}
function validateInt64(value2) {
  return Number.isInteger(value2);
}
function validateNumber() {
  return true;
}
var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str))
    return false;
  try {
    return new RegExp(str), true;
  } catch (e) {
    return false;
  }
}
var isISO8601 = /(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))/;
var isFormalDate = /(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s\d{2}\s\d{4}\s\d{2}:\d{2}:\d{2}\sGMT(?:\+|-)\d{4}\s\([^)]+\)/;
var isShortenDate = /^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:19|20)\d{2})|(?:(?:19|20)\d{2}[/\s-](?:0?[1-9]|1[0-2])[/\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\s[AP]M)?)?$/;
var _validateDate = fullFormats.date;
var _validateDateTime = fullFormats["date-time"];
if (!exports_format.Has("date"))
  TypeSystem.Format("date", (value2) => {
    let temp = value2.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDate(temp)) {
      let date22 = new Date(temp);
      if (!Number.isNaN(date22.getTime()))
        return true;
    }
    return false;
  });
if (!exports_format.Has("date-time"))
  TypeSystem.Format("date-time", (value2) => {
    let temp = value2.replace(/"/g, "");
    if (isISO8601.test(temp) || isFormalDate.test(temp) || isShortenDate.test(temp) || _validateDateTime(temp)) {
      let date22 = new Date(temp);
      if (!Number.isNaN(date22.getTime()))
        return true;
    }
    return false;
  });
Object.entries(fullFormats).forEach((formatEntry) => {
  let [formatName, formatValue] = formatEntry;
  if (!exports_format.Has(formatName)) {
    if (formatValue instanceof RegExp)
      TypeSystem.Format(formatName, (value2) => formatValue.test(value2));
    else if (typeof formatValue === "function")
      TypeSystem.Format(formatName, formatValue);
  }
});
var t = Object.assign({}, Type);
var parseFileUnit = (size) => {
  if (typeof size === "string")
    switch (size.slice(-1)) {
      case "k":
        return +size.slice(0, size.length - 1) * 1024;
      case "m":
        return +size.slice(0, size.length - 1) * 1048576;
      default:
        return +size;
    }
  return size;
};
var validateFile = (options, value2) => {
  if (!(value2 instanceof Blob))
    return false;
  if (options.minSize && value2.size < parseFileUnit(options.minSize))
    return false;
  if (options.maxSize && value2.size > parseFileUnit(options.maxSize))
    return false;
  if (options.extension)
    if (typeof options.extension === "string") {
      if (!value2.type.startsWith(options.extension))
        return false;
    } else {
      for (let i = 0;i < options.extension.length; i++)
        if (value2.type.startsWith(options.extension[i]))
          return true;
      return false;
    }
  return true;
};
var File2 = exports_type.Get("Files") ?? TypeSystem.Type("File", validateFile);
var Files = exports_type.Get("Files") ?? TypeSystem.Type("Files", (options, value2) => {
  if (!Array.isArray(value2))
    return validateFile(options, value2);
  if (options.minItems && value2.length < options.minItems)
    return false;
  if (options.maxItems && value2.length > options.maxItems)
    return false;
  for (let i = 0;i < value2.length; i++)
    if (!validateFile(options, value2[i]))
      return false;
  return true;
});
if (!exports_format.Has("numeric"))
  exports_format.Set("numeric", (value2) => !!value2 && !isNaN(+value2));
if (!exports_format.Has("boolean"))
  exports_format.Set("boolean", (value2) => value2 === "true" || value2 === "false");
if (!exports_format.Has("ObjectString"))
  exports_format.Set("ObjectString", (value2) => {
    let start = value2.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value2.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value2), true;
    } catch {
      return false;
    }
  });
if (!exports_format.Has("ArrayString"))
  exports_format.Set("ArrayString", (value2) => {
    let start = value2.charCodeAt(0);
    if (start === 9 || start === 10 || start === 32)
      start = value2.trimStart().charCodeAt(0);
    if (start !== 123 && start !== 91)
      return false;
    try {
      return JSON.parse(value2), true;
    } catch {
      return false;
    }
  });
exports_type.Set("UnionEnum", (schema3, value2) => {
  return (typeof value2 === "number" || typeof value2 === "string" || value2 === null) && schema3.enum.includes(value2);
});
var ElysiaType = { Numeric: (property) => {
  let schema3 = Type.Number(property);
  return t.Transform(t.Union([t.String({ format: "numeric", default: 0 }), t.Number(property)], property)).Decode((value2) => {
    let number3 = +value2;
    if (isNaN(number3))
      return value2;
    if (property && !exports_value2.Check(schema3, number3))
      throw new ValidationError("property", schema3, number3);
    return number3;
  }).Encode((value2) => value2);
}, Date: (property) => {
  let schema3 = Type.Date(property);
  return t.Transform(t.Union([Type.Date(property), t.String({ format: "date", default: new Date().toISOString() }), t.String({ format: "date-time", default: new Date().toISOString() }), t.Number()], property)).Decode((value2) => {
    if (typeof value2 === "number") {
      let date32 = new Date(value2);
      if (!exports_value2.Check(schema3, date32))
        throw new ValidationError("property", schema3, date32);
      return date32;
    }
    if (value2 instanceof Date)
      return value2;
    let date22 = new Date(value2);
    if (!exports_value2.Check(schema3, date22))
      throw new ValidationError("property", schema3, date22);
    return date22;
  }).Encode((value2) => {
    if (typeof value2 === "string")
      return new Date(value2);
    return value2;
  });
}, BooleanString: (property) => {
  let schema3 = Type.Boolean(property);
  return t.Transform(t.Union([t.Boolean(property), t.String({ format: "boolean", default: false })], property)).Decode((value2) => {
    if (typeof value2 === "string")
      return value2 === "true";
    if (value2 !== undefined && !exports_value2.Check(schema3, value2))
      throw new ValidationError("property", schema3, value2);
    return value2;
  }).Encode((value2) => value2);
}, ObjectString: (properties, options) => {
  let schema3 = t.Object(properties, options), defaultValue = JSON.stringify(exports_value2.Create(schema3)), compiler2;
  try {
    compiler2 = TypeCompiler.Compile(schema3);
  } catch {
  }
  return t.Transform(t.Union([t.String({ format: "ObjectString", default: defaultValue }), schema3])).Decode((value2) => {
    if (typeof value2 === "string") {
      if (value2.charCodeAt(0) !== 123)
        throw new ValidationError("property", schema3, value2);
      try {
        value2 = JSON.parse(value2);
      } catch {
        throw new ValidationError("property", schema3, value2);
      }
      if (compiler2) {
        if (!compiler2.Check(value2))
          throw new ValidationError("property", schema3, value2);
        return compiler2.Decode(value2);
      }
      if (!exports_value2.Check(schema3, value2))
        throw new ValidationError("property", schema3, value2);
      return exports_value2.Decode(schema3, value2);
    }
    return value2;
  }).Encode((value2) => {
    if (typeof value2 === "string")
      try {
        value2 = JSON.parse(value2);
      } catch {
        throw new ValidationError("property", schema3, value2);
      }
    if (!exports_value2.Check(schema3, value2))
      throw new ValidationError("property", schema3, value2);
    return JSON.stringify(value2);
  });
}, ArrayString: (children = {}, options) => {
  let schema3 = t.Array(children, options), defaultValue = JSON.stringify(exports_value2.Create(schema3)), compiler2;
  try {
    compiler2 = TypeCompiler.Compile(schema3);
  } catch {
  }
  return t.Transform(t.Union([t.String({ format: "ArrayString", default: defaultValue }), schema3])).Decode((value2) => {
    if (typeof value2 === "string") {
      if (value2.charCodeAt(0) !== 91)
        throw new ValidationError("property", schema3, value2);
      try {
        value2 = JSON.parse(value2);
      } catch {
        throw new ValidationError("property", schema3, value2);
      }
      if (compiler2) {
        if (!compiler2.Check(value2))
          throw new ValidationError("property", schema3, value2);
        return compiler2.Decode(value2);
      }
      if (!exports_value2.Check(schema3, value2))
        throw new ValidationError("property", schema3, value2);
      return exports_value2.Decode(schema3, value2);
    }
    return value2;
  }).Encode((value2) => {
    if (typeof value2 === "string")
      try {
        value2 = JSON.parse(value2);
      } catch {
        throw new ValidationError("property", schema3, value2);
      }
    if (!exports_value2.Check(schema3, value2))
      throw new ValidationError("property", schema3, value2);
    return JSON.stringify(value2);
  });
}, File: File2, Files: (options = {}) => t.Transform(Files(options)).Decode((value2) => {
  if (Array.isArray(value2))
    return value2;
  return [value2];
}).Encode((value2) => value2), Nullable: (schema3) => t.Union([schema3, t.Null()]), MaybeEmpty: (schema3) => t.Union([schema3, t.Null(), t.Undefined()]), Cookie: (properties, { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign, ...options } = {}) => {
  let v = t.Object(properties, options);
  return v.config = { domain, expires, httpOnly, maxAge, path, priority, sameSite, secure, secrets, sign }, v;
}, UnionEnum: (values, options = {}) => {
  let type3 = values.every((value2) => typeof value2 === "string") ? { type: "string" } : values.every((value2) => typeof value2 === "number") ? { type: "number" } : values.every((value2) => value2 === null) ? { type: "null" } : {};
  if (values.some((x) => typeof x === "object" && x !== null))
    throw new Error("This type does not support objects or arrays");
  return { default: values[0], ...options, [Kind]: "UnionEnum", ...type3, enum: values };
} };
t.BooleanString = ElysiaType.BooleanString;
t.ObjectString = ElysiaType.ObjectString;
t.ArrayString = ElysiaType.ArrayString;
t.Numeric = ElysiaType.Numeric;
t.File = (arg = {}) => ElysiaType.File({ default: "File", ...arg, extension: arg?.type, type: "string", format: "binary" });
t.Files = (arg = {}) => ElysiaType.Files({ ...arg, elysiaMeta: "Files", default: "Files", extension: arg?.type, type: "array", items: { ...arg, default: "Files", type: "string", format: "binary" } });
t.Nullable = (schema3) => ElysiaType.Nullable(schema3);
t.MaybeEmpty = ElysiaType.MaybeEmpty;
t.Cookie = ElysiaType.Cookie;
t.Date = ElysiaType.Date;
t.UnionEnum = ElysiaType.UnionEnum;
var import_cookie2 = __toESM2(require_dist(), 1);
var import_cookie = __toESM2(require_dist(), 1);
var import_fast_decode_uri_component = __toESM2(require_fast_decode_uri_component(), 1);

class Cookie {
  name;
  jar;
  initial;
  constructor(name, jar, initial = {}) {
    this.name = name;
    this.jar = jar;
    this.initial = initial;
  }
  get cookie() {
    return this.jar[this.name] ?? this.initial;
  }
  set cookie(jar) {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    this.jar[this.name] = jar;
  }
  get setCookie() {
    if (!(this.name in this.jar))
      this.jar[this.name] = this.initial;
    return this.jar[this.name];
  }
  set setCookie(jar) {
    this.cookie = jar;
  }
  get value() {
    return this.cookie.value;
  }
  set value(value2) {
    this.setCookie.value = value2;
  }
  get expires() {
    return this.cookie.expires;
  }
  set expires(expires) {
    this.setCookie.expires = expires;
  }
  get maxAge() {
    return this.cookie.maxAge;
  }
  set maxAge(maxAge) {
    this.setCookie.maxAge = maxAge;
  }
  get domain() {
    return this.cookie.domain;
  }
  set domain(domain) {
    this.setCookie.domain = domain;
  }
  get path() {
    return this.cookie.path;
  }
  set path(path) {
    this.setCookie.path = path;
  }
  get secure() {
    return this.cookie.secure;
  }
  set secure(secure) {
    this.setCookie.secure = secure;
  }
  get httpOnly() {
    return this.cookie.httpOnly;
  }
  set httpOnly(httpOnly) {
    this.setCookie.httpOnly = httpOnly;
  }
  get sameSite() {
    return this.cookie.sameSite;
  }
  set sameSite(sameSite) {
    this.setCookie.sameSite = sameSite;
  }
  get priority() {
    return this.cookie.priority;
  }
  set priority(priority) {
    this.setCookie.priority = priority;
  }
  get partitioned() {
    return this.cookie.partitioned;
  }
  set partitioned(partitioned) {
    this.setCookie.partitioned = partitioned;
  }
  get secrets() {
    return this.cookie.secrets;
  }
  set secrets(secrets) {
    this.setCookie.secrets = secrets;
  }
  update(config) {
    return this.setCookie = Object.assign(this.cookie, typeof config === "function" ? config(this.cookie) : config), this;
  }
  set(config) {
    return this.setCookie = Object.assign({ ...this.initial, value: this.value }, typeof config === "function" ? config(this.cookie) : config), this;
  }
  remove() {
    if (this.value === undefined)
      return;
    return this.set({ expires: new Date(0), maxAge: 0, value: "" }), this;
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
}
var createCookieJar = (set22, store, initial) => {
  if (!set22.cookie)
    set22.cookie = {};
  return new Proxy(store, { get(_2, key) {
    if (key in store)
      return new Cookie(key, set22.cookie, Object.assign({}, initial ?? {}, store[key]));
    return new Cookie(key, set22.cookie, Object.assign({}, initial));
  } });
};
var parseCookie = async (set22, cookieString, { secrets, sign, ...initial } = {}) => {
  if (!cookieString)
    return createCookieJar(set22, {}, initial);
  let isStringKey = typeof secrets === "string";
  if (sign && sign !== true && !Array.isArray(sign))
    sign = [sign];
  let jar = {}, cookies = import_cookie.parse(cookieString);
  for (let [name, v] of Object.entries(cookies)) {
    let value2 = import_fast_decode_uri_component.default(v);
    if (sign === true || sign?.includes(name)) {
      if (!secrets)
        throw new Error("No secret is provided to cookie plugin");
      if (isStringKey) {
        let temp = await unsignCookie(value2, secrets);
        if (temp === false)
          throw new InvalidCookieSignature(name);
        value2 = temp;
      } else {
        let decoded = true;
        for (let i = 0;i < secrets.length; i++) {
          let temp = await unsignCookie(value2, secrets[i]);
          if (temp !== false) {
            decoded = true, value2 = temp;
            break;
          }
        }
        if (!decoded)
          throw new InvalidCookieSignature(name);
      }
    }
    jar[name] = { value: value2 };
  }
  return createCookieJar(set22, jar, initial);
};
var hasHeaderShorthand = "toJSON" in new Headers;
var isNotEmpty = (obj) => {
  if (!obj)
    return false;
  for (let x in obj)
    return true;
  return false;
};
var handleFile = (response, set22) => {
  let size = response.size;
  if (!set22 && size || size && set22 && set22.status !== 206 && set22.status !== 304 && set22.status !== 412 && set22.status !== 416) {
    if (set22 && isNotEmpty(set22.headers)) {
      if (set22.headers instanceof Headers) {
        if (hasHeaderShorthand)
          set22.headers = set22.headers.toJSON();
        else
          for (let [key, value2] of set22.headers.entries())
            if (key in set22.headers)
              set22.headers[key] = value2;
      }
      return new Response(response, { status: set22.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}` }, set22.headers) });
    }
    return new Response(response, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${size - 1}/${size}`, "transfer-encoding": "chunked" } });
  }
  return new Response(response);
};
var parseSetCookies = (headers, setCookie) => {
  if (!headers)
    return headers;
  headers.delete("set-cookie");
  for (let i = 0;i < setCookie.length; i++) {
    let index = setCookie[i].indexOf("=");
    headers.append("set-cookie", `${setCookie[i].slice(0, index)}=${setCookie[i].slice(index + 1) || ""}`);
  }
  return headers;
};
var serializeCookie = (cookies) => {
  if (!cookies || !isNotEmpty(cookies))
    return;
  let set22 = [];
  for (let [key, property] of Object.entries(cookies)) {
    if (!key || !property)
      continue;
    let value2 = property.value;
    if (value2 === undefined || value2 === null)
      continue;
    set22.push(import_cookie2.serialize(key, typeof value2 === "object" ? JSON.stringify(value2) : value2 + "", property));
  }
  if (set22.length === 0)
    return;
  if (set22.length === 1)
    return set22[0];
  return set22;
};
var handleStream = async (generator, set22, request) => {
  let init = generator.next();
  if (init instanceof Promise)
    init = await init;
  if (init.done) {
    if (set22)
      return mapResponse(init.value, set22, request);
    return mapCompactResponse(init.value, request);
  }
  return new Response(new ReadableStream({ async start(controller) {
    let end = false;
    if (request?.signal.addEventListener("abort", () => {
      end = true;
      try {
        controller.close();
      } catch {
      }
    }), init.value !== undefined && init.value !== null)
      if (typeof init.value === "object")
        try {
          controller.enqueue(Buffer.from(JSON.stringify(init.value)));
        } catch {
          controller.enqueue(Buffer.from(init.value.toString()));
        }
      else
        controller.enqueue(Buffer.from(init.value.toString()));
    for await (let chunk of generator) {
      if (end)
        break;
      if (chunk === undefined || chunk === null)
        continue;
      if (typeof chunk === "object")
        try {
          controller.enqueue(Buffer.from(JSON.stringify(chunk)));
        } catch {
          controller.enqueue(Buffer.from(chunk.toString()));
        }
      else
        controller.enqueue(Buffer.from(chunk.toString()));
      await new Promise((resolve) => setTimeout(() => resolve(), 0));
    }
    try {
      controller.close();
    } catch {
    }
  } }), { ...set22, headers: { "transfer-encoding": "chunked", "content-type": "text/event-stream; charset=utf-8", ...set22?.headers } });
};
async function* streamResponse(response) {
  let body = response.body;
  if (!body)
    return;
  let reader = body.getReader(), decoder = new TextDecoder;
  try {
    while (true) {
      let { done, value: value2 } = await reader.read();
      if (done)
        break;
      yield decoder.decode(value2);
    }
  } finally {
    reader.releaseLock();
  }
}
var mapResponse = (response, set22, request) => {
  if (isNotEmpty(set22.headers) || set22.status !== 200 || set22.redirect || set22.cookie) {
    if (typeof set22.status === "string")
      set22.status = StatusMap[set22.status];
    if (set22.redirect) {
      if (set22.headers.Location = set22.redirect, !set22.status || set22.status < 300 || set22.status >= 400)
        set22.status = 302;
    }
    if (set22.cookie && isNotEmpty(set22.cookie)) {
      let cookie = serializeCookie(set22.cookie);
      if (cookie)
        set22.headers["set-cookie"] = cookie;
    }
    if (set22.headers["set-cookie"] && Array.isArray(set22.headers["set-cookie"]))
      set22.headers = parseSetCookies(new Headers(set22.headers), set22.headers["set-cookie"]);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set22);
      case "Blob":
        return handleFile(response, set22);
      case "Array":
        return Response.json(response, set22);
      case "Object":
        return Response.json(response, set22);
      case "ElysiaCustomStatusResponse":
        return set22.status = response.code, mapResponse(response.response, set22, request);
      case "ReadableStream":
        if (!set22.headers["content-type"]?.startsWith("text/event-stream"))
          set22.headers["content-type"] = "text/event-stream; charset=utf-8";
        return request?.signal.addEventListener("abort", { handleEvent() {
          if (!request?.signal.aborted)
            response.cancel(request);
        } }, { once: true }), new Response(response, set22);
      case undefined:
        if (!response)
          return new Response("", set22);
        return Response.json(response, set22);
      case "Response":
        let isCookieSet = false;
        if (set22.headers instanceof Headers)
          for (let key of set22.headers.keys())
            if (key === "set-cookie") {
              if (isCookieSet)
                continue;
              isCookieSet = true;
              for (let cookie of set22.headers.getSetCookie())
                response.headers.append("set-cookie", cookie);
            } else
              response.headers.append(key, set22.headers?.get(key) ?? "");
        else
          for (let key in set22.headers)
            response.headers.append(key, set22.headers[key]);
        if (response.status !== set22.status)
          set22.status = response.status;
        if (response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response), set22, request);
        return response;
      case "Error":
        return errorToResponse(response, set22);
      case "Promise":
        return response.then((x) => mapResponse(x, set22));
      case "Function":
        return mapResponse(response(), set22);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set22);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set22);
        return new Response(response?.toString(), set22);
      case "FormData":
        return new Response(response, set22);
      default:
        if (response instanceof Response) {
          let isCookieSet2 = false;
          if (set22.headers instanceof Headers)
            for (let key of set22.headers.keys())
              if (key === "set-cookie") {
                if (isCookieSet2)
                  continue;
                isCookieSet2 = true;
                for (let cookie of set22.headers.getSetCookie())
                  response.headers.append("set-cookie", cookie);
              } else
                response.headers.append(key, set22.headers?.get(key) ?? "");
          else
            for (let key in set22.headers)
              response.headers.append(key, set22.headers[key]);
          if (hasHeaderShorthand)
            set22.headers = response.headers.toJSON();
          else
            for (let [key, value2] of response.headers.entries())
              if (key in set22.headers)
                set22.headers[key] = value2;
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set22));
        if (response instanceof Error)
          return errorToResponse(response, set22);
        if (response instanceof ElysiaCustomStatusResponse)
          return set22.status = response.code, mapResponse(response.response, set22, request);
        if (typeof response?.next === "function")
          return handleStream(response, set22, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapResponse(x, set22));
        if (typeof response?.toResponse === "function")
          return mapResponse(response.toResponse(), set22);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set22.headers["Content-Type"])
              set22.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set22);
          }
        }
        return new Response(response, set22);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set22);
      case "Array":
        return Response.json(response);
      case "Object":
        return Response.json(response, set22);
      case "ElysiaCustomStatusResponse":
        return set22.status = response.code, mapResponse(response.response, set22, request);
      case "ReadableStream":
        return request?.signal.addEventListener("abort", { handleEvent() {
          if (!request?.signal.aborted)
            response.cancel(request);
        } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        if (response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response), set22, request);
        return response;
      case "Error":
        return errorToResponse(response, set22);
      case "Promise":
        return response.then((x) => {
          let r = mapCompactResponse(x, request);
          if (r !== undefined)
            return r;
          return new Response("");
        });
      case "Function":
        return mapCompactResponse(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set22);
        return new Response(response?.toString(), set22);
      case "FormData":
        return new Response(response, set22);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x) => mapResponse(x, set22));
        if (response instanceof Error)
          return errorToResponse(response, set22);
        if (response instanceof ElysiaCustomStatusResponse)
          return set22.status = response.code, mapResponse(response.response, set22, request);
        if (typeof response?.next === "function")
          return handleStream(response, set22, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapResponse(x, set22));
        if (typeof response?.toResponse === "function")
          return mapResponse(response.toResponse(), set22);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set22.headers["Content-Type"])
              set22.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set22);
          }
        }
        return new Response(response);
    }
};
var mapEarlyResponse = (response, set22, request) => {
  if (response === undefined || response === null)
    return;
  if (isNotEmpty(set22.headers) || set22.status !== 200 || set22.redirect || set22.cookie) {
    if (typeof set22.status === "string")
      set22.status = StatusMap[set22.status];
    if (set22.redirect) {
      if (set22.headers.Location = set22.redirect, !set22.status || set22.status < 300 || set22.status >= 400)
        set22.status = 302;
    }
    if (set22.cookie && isNotEmpty(set22.cookie)) {
      let cookie = serializeCookie(set22.cookie);
      if (cookie)
        set22.headers["set-cookie"] = cookie;
    }
    if (set22.headers["set-cookie"] && Array.isArray(set22.headers["set-cookie"]))
      set22.headers = parseSetCookies(new Headers(set22.headers), set22.headers["set-cookie"]);
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response, set22);
      case "Blob":
        return handleFile(response, set22);
      case "Array":
        return Response.json(response, set22);
      case "Object":
        return Response.json(response, set22);
      case "ElysiaCustomStatusResponse":
        return set22.status = response.code, mapEarlyResponse(response.response, set22, request);
      case "ReadableStream":
        if (!set22.headers["content-type"]?.startsWith("text/event-stream"))
          set22.headers["content-type"] = "text/event-stream; charset=utf-8";
        return request?.signal.addEventListener("abort", { handleEvent() {
          if (!request?.signal.aborted)
            response.cancel(request);
        } }, { once: true }), new Response(response, set22);
      case undefined:
        if (!response)
          return;
        return Response.json(response, set22);
      case "Response":
        let isCookieSet = false;
        if (set22.headers instanceof Headers)
          for (let key of set22.headers.keys())
            if (key === "set-cookie") {
              if (isCookieSet)
                continue;
              isCookieSet = true;
              for (let cookie of set22.headers.getSetCookie())
                response.headers.append("set-cookie", cookie);
            } else
              response.headers.append(key, set22.headers?.get(key) ?? "");
        else
          for (let key in set22.headers)
            response.headers.append(key, set22.headers[key]);
        if (response.status !== set22.status)
          set22.status = response.status;
        if (response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response), set22, request);
        return response;
      case "Promise":
        return response.then((x) => {
          let r = mapEarlyResponse(x, set22);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse(response, set22);
      case "Function":
        return mapEarlyResponse(response(), set22);
      case "Number":
      case "Boolean":
        return new Response(response.toString(), set22);
      case "FormData":
        return new Response(response);
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set22);
        return new Response(response?.toString(), set22);
      default:
        if (response instanceof Response) {
          let isCookieSet2 = false;
          if (set22.headers instanceof Headers)
            for (let key of set22.headers.keys())
              if (key === "set-cookie") {
                if (isCookieSet2)
                  continue;
                isCookieSet2 = true;
                for (let cookie of set22.headers.getSetCookie())
                  response.headers.append("set-cookie", cookie);
              } else
                response.headers.append(key, set22.headers?.get(key) ?? "");
          else
            for (let key in set22.headers)
              response.headers.append(key, set22.headers[key]);
          if (response.status !== set22.status)
            set22.status = response.status;
          return response;
        }
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set22));
        if (response instanceof Error)
          return errorToResponse(response, set22);
        if (response instanceof ElysiaCustomStatusResponse)
          return set22.status = response.code, mapEarlyResponse(response.response, set22, request);
        if (typeof response?.next === "function")
          return handleStream(response, set22, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse(x, set22));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set22);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set22.headers["Content-Type"])
              set22.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set22);
          }
        }
        return new Response(response, set22);
    }
  } else
    switch (response?.constructor?.name) {
      case "String":
        return new Response(response);
      case "Blob":
        return handleFile(response, set22);
      case "Array":
        return Response.json(response);
      case "Object":
        return Response.json(response, set22);
      case "ElysiaCustomStatusResponse":
        return set22.status = response.code, mapEarlyResponse(response.response, set22, request);
      case "ReadableStream":
        return request?.signal.addEventListener("abort", { handleEvent() {
          if (!request?.signal.aborted)
            response.cancel(request);
        } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!response)
          return new Response("");
        return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
      case "Response":
        if (response.headers.get("transfer-encoding") === "chunked")
          return handleStream(streamResponse(response));
        return response;
      case "Promise":
        return response.then((x) => {
          let r = mapEarlyResponse(x, set22);
          if (r !== undefined)
            return r;
        });
      case "Error":
        return errorToResponse(response, set22);
      case "Function":
        return mapCompactResponse(response(), request);
      case "Number":
      case "Boolean":
        return new Response(response.toString());
      case "Cookie":
        if (response instanceof Cookie)
          return new Response(response.value, set22);
        return new Response(response?.toString(), set22);
      case "FormData":
        return new Response(response);
      default:
        if (response instanceof Response)
          return response;
        if (response instanceof Promise)
          return response.then((x) => mapEarlyResponse(x, set22));
        if (response instanceof Error)
          return errorToResponse(response, set22);
        if (response instanceof ElysiaCustomStatusResponse)
          return set22.status = response.code, mapEarlyResponse(response.response, set22, request);
        if (typeof response?.next === "function")
          return handleStream(response, set22, request);
        if (typeof response?.then === "function")
          return response.then((x) => mapEarlyResponse(x, set22));
        if (typeof response?.toResponse === "function")
          return mapEarlyResponse(response.toResponse(), set22);
        if ("charCodeAt" in response) {
          let code = response.charCodeAt(0);
          if (code === 123 || code === 91) {
            if (!set22.headers["Content-Type"])
              set22.headers["Content-Type"] = "application/json";
            return new Response(JSON.stringify(response), set22);
          }
        }
        return new Response(response);
    }
};
var mapCompactResponse = (response, request) => {
  switch (response?.constructor?.name) {
    case "String":
      return new Response(response);
    case "Blob":
      return handleFile(response);
    case "Array":
      return Response.json(response);
    case "Object":
      return Response.json(response);
    case "ElysiaCustomStatusResponse":
      return mapResponse(response.response, { status: response.code, headers: {} });
    case "ReadableStream":
      return request?.signal.addEventListener("abort", { handleEvent() {
        if (!request?.signal.aborted)
          response.cancel(request);
      } }, { once: true }), new Response(response, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!response)
        return new Response("");
      return new Response(JSON.stringify(response), { headers: { "content-type": "application/json" } });
    case "Response":
      if (response.headers.get("transfer-encoding") === "chunked")
        return handleStream(streamResponse(response));
      return response;
    case "Error":
      return errorToResponse(response);
    case "Promise":
      return response.then((x) => mapCompactResponse(x, request));
    case "Function":
      return mapCompactResponse(response(), request);
    case "Number":
    case "Boolean":
      return new Response(response.toString());
    case "FormData":
      return new Response(response);
    default:
      if (response instanceof Response)
        return response;
      if (response instanceof Promise)
        return response.then((x) => mapCompactResponse(x, request));
      if (response instanceof Error)
        return errorToResponse(response);
      if (response instanceof ElysiaCustomStatusResponse)
        return mapResponse(response.response, { status: response.code, headers: {} });
      if (typeof response?.next === "function")
        return handleStream(response, undefined, request);
      if (typeof response?.then === "function")
        return response.then((x) => mapResponse(x, set));
      if (typeof response?.toResponse === "function")
        return mapCompactResponse(response.toResponse());
      if ("charCodeAt" in response) {
        let code = response.charCodeAt(0);
        if (code === 123 || code === 91)
          return new Response(JSON.stringify(response), { headers: { "Content-Type": "application/json" } });
      }
      return new Response(response);
  }
};
var errorToResponse = (error3, set22) => new Response(JSON.stringify({ name: error3?.name, message: error3?.message, cause: error3?.cause }), { status: set22?.status !== 200 ? set22?.status ?? 500 : 500, headers: set22?.headers });
var createStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function")
    return;
  let response = mapResponse(handle, { headers: setHeaders });
  if (hooks.parse.length === 0 && hooks.transform.length === 0 && hooks.beforeHandle.length === 0 && hooks.afterHandle.length === 0)
    return response.clone.bind(response);
};
var createNativeStaticHandler = (handle, hooks, setHeaders = {}) => {
  if (typeof handle === "function" || handle instanceof Blob)
    return;
  let response = mapResponse(handle, { headers: setHeaders });
  if (hooks.parse.length === 0 && hooks.transform.length === 0 && hooks.beforeHandle.length === 0 && hooks.afterHandle.length === 0) {
    if (!response.headers.has("content-type"))
      response.headers.append("content-type", "text/plain;charset=utf-8");
    return response.clone.bind(response);
  }
};
var replaceUrlPath = (url, pathname) => {
  let urlObject = new URL(url);
  return urlObject.pathname = pathname, urlObject.toString();
};
var isClass = (v) => typeof v === "function" && /^\s*class\s+/.test(v.toString()) || v.toString().startsWith("[object ") && v.toString() !== "[object Object]" || isNotEmpty(Object.getPrototypeOf(v));
var isObject = (item) => item && typeof item === "object" && !Array.isArray(item);
var mergeDeep = (target, source, { skipKeys, override = true } = {}) => {
  if (!isObject(target) || !isObject(source))
    return target;
  for (let [key, value2] of Object.entries(source)) {
    if (skipKeys?.includes(key))
      continue;
    if (!isObject(value2) || !(key in target) || isClass(value2)) {
      if (override || !(key in target))
        target[key] = value2;
      continue;
    }
    target[key] = mergeDeep(target[key], value2, { skipKeys, override });
  }
  return target;
};
var mergeCookie = (a, b) => {
  let { properties: _2, ...target } = a ?? {}, { properties: __, ...source } = b ?? {};
  return mergeDeep(target, source);
};
var mergeObjectArray = (a = [], b = []) => {
  if (!a)
    return [];
  if (!b)
    return a;
  let array3 = [], checksums = [];
  if (!Array.isArray(a))
    a = [a];
  if (!Array.isArray(b))
    b = [b];
  for (let item of a)
    if (array3.push(item), item.checksum)
      checksums.push(item.checksum);
  for (let item of b)
    if (!checksums.includes(item.checksum))
      array3.push(item);
  return array3;
};
var primitiveHooks = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "mapResponse", "afterResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var primitiveHookMap = primitiveHooks.reduce((acc, x) => (acc[x] = true, acc), {});
var mergeResponse = (a, b) => {
  let isRecordNumber = (x) => typeof x === "object" && Object.keys(x).every(isNumericString);
  if (isRecordNumber(a) && isRecordNumber(b))
    return { ...a, ...b };
  else if (a && !isRecordNumber(a) && isRecordNumber(b))
    return { 200: a, ...b };
  return b ?? a;
};
var mergeSchemaValidator = (a, b) => {
  return { body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse(a?.response, b?.response) };
};
var mergeHook = (a, b) => {
  return { ...a, ...b, body: b?.body ?? a?.body, headers: b?.headers ?? a?.headers, params: b?.params ?? a?.params, query: b?.query ?? a?.query, cookie: b?.cookie ?? a?.cookie, response: mergeResponse(a?.response, b?.response), type: a?.type || b?.type, detail: mergeDeep(b?.detail ?? {}, a?.detail ?? {}), parse: mergeObjectArray(a?.parse, b?.parse), transform: mergeObjectArray(a?.transform, b?.transform), beforeHandle: mergeObjectArray(a?.beforeHandle, b?.beforeHandle), afterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle), mapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse), afterResponse: mergeObjectArray(a?.afterResponse, b?.afterResponse), trace: mergeObjectArray(a?.trace, b?.trace), error: mergeObjectArray(a?.error, b?.error) };
};
var replaceSchemaType = (schema3, options, root = true) => {
  if (!Array.isArray(options))
    return _replaceSchemaType(schema3, options, root);
  for (let option of options)
    schema3 = _replaceSchemaType(schema3, option, root);
  return schema3;
};
var _replaceSchemaType = (schema3, options, root = true) => {
  if (!schema3)
    return schema3;
  if (options.untilObjectFound && !root && schema3.type === "object")
    return schema3;
  let fromSymbol = options.from[Kind];
  if (schema3.oneOf) {
    for (let i = 0;i < schema3.oneOf.length; i++)
      schema3.oneOf[i] = _replaceSchemaType(schema3.oneOf[i], options, root);
    return schema3;
  }
  if (schema3.anyOf) {
    for (let i = 0;i < schema3.anyOf.length; i++)
      schema3.anyOf[i] = _replaceSchemaType(schema3.anyOf[i], options, root);
    return schema3;
  }
  if (schema3.allOf) {
    for (let i = 0;i < schema3.allOf.length; i++)
      schema3.allOf[i] = _replaceSchemaType(schema3.allOf[i], options, root);
    return schema3;
  }
  if (schema3.not) {
    for (let i = 0;i < schema3.not.length; i++)
      schema3.not[i] = _replaceSchemaType(schema3.not[i], options, root);
    return schema3;
  }
  let isRoot = root && !!options.excludeRoot;
  if (schema3[Kind] === fromSymbol) {
    let { anyOf, oneOf, allOf, not: not3, properties: properties2, items, ...rest3 } = schema3, to = options.to(rest3), transform4, composeProperties = (v) => {
      if (properties2 && v.type === "object") {
        let newProperties = {};
        for (let [key, value22] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value22, options, false);
        return { ...rest3, ...v, properties: newProperties };
      }
      if (items && v.type === "array")
        return { ...rest3, ...v, items: _replaceSchemaType(items, options, false) };
      let value2 = { ...rest3, ...v };
      if (delete value2.required, properties2 && v.type === "string" && v.format === "ObjectString" && v.default === "{}")
        transform4 = t.ObjectString(properties2, rest3), value2.default = JSON.stringify(exports_value2.Create(t.Object(properties2))), value2.properties = properties2;
      if (items && v.type === "string" && v.format === "ArrayString" && v.default === "[]")
        transform4 = t.ArrayString(items, rest3), value2.default = JSON.stringify(exports_value2.Create(t.Array(items))), value2.items = items;
      return value2;
    };
    if (isRoot) {
      if (properties2) {
        let newProperties = {};
        for (let [key, value2] of Object.entries(properties2))
          newProperties[key] = _replaceSchemaType(value2, options, false);
        return { ...rest3, properties: newProperties };
      } else if (items?.map)
        return { ...rest3, items: items.map((v) => _replaceSchemaType(v, options, false)) };
      return rest3;
    }
    if (to.anyOf)
      for (let i = 0;i < to.anyOf.length; i++)
        to.anyOf[i] = composeProperties(to.anyOf[i]);
    else if (to.oneOf)
      for (let i = 0;i < to.oneOf.length; i++)
        to.oneOf[i] = composeProperties(to.oneOf[i]);
    else if (to.allOf)
      for (let i = 0;i < to.allOf.length; i++)
        to.allOf[i] = composeProperties(to.allOf[i]);
    else if (to.not)
      for (let i = 0;i < to.not.length; i++)
        to.not[i] = composeProperties(to.not[i]);
    if (transform4)
      to[TransformKind] = transform4[TransformKind];
    if (to.anyOf || to.oneOf || to.allOf || to.not)
      return to;
    if (properties2) {
      let newProperties = {};
      for (let [key, value2] of Object.entries(properties2))
        newProperties[key] = _replaceSchemaType(value2, options, false);
      return { ...rest3, ...to, properties: newProperties };
    } else if (items?.map)
      return { ...rest3, ...to, items: items.map((v) => _replaceSchemaType(v, options, false)) };
    return { ...rest3, ...to };
  }
  let properties = schema3?.properties;
  if (properties && root && options.rootOnly !== true)
    for (let [key, value2] of Object.entries(properties))
      switch (value2[Kind]) {
        case fromSymbol:
          let { anyOf, oneOf, allOf, not: not3, type: type3, ...rest3 } = value2, to = options.to(rest3);
          if (to.anyOf)
            for (let i = 0;i < to.anyOf.length; i++)
              to.anyOf[i] = { ...rest3, ...to.anyOf[i] };
          else if (to.oneOf)
            for (let i = 0;i < to.oneOf.length; i++)
              to.oneOf[i] = { ...rest3, ...to.oneOf[i] };
          else if (to.allOf)
            for (let i = 0;i < to.allOf.length; i++)
              to.allOf[i] = { ...rest3, ...to.allOf[i] };
          else if (to.not)
            for (let i = 0;i < to.not.length; i++)
              to.not[i] = { ...rest3, ...to.not[i] };
          properties[key] = { ...rest3, ..._replaceSchemaType(rest3, options, false) };
          break;
        case "Object":
        case "Union":
          properties[key] = _replaceSchemaType(value2, options, false);
          break;
        default:
          if (value2.items)
            for (let i = 0;i < value2.items.length; i++)
              value2.items[i] = _replaceSchemaType(value2.items[i], options, false);
          else if (value2.anyOf || value2.oneOf || value2.allOf || value2.not)
            properties[key] = _replaceSchemaType(value2, options, false);
          break;
      }
  return schema3;
};
var createCleaner = (schema3) => (value2) => {
  if (typeof value2 === "object")
    try {
      return exports_value2.Clean(schema3, structuredClone(value2));
    } catch {
      try {
        return exports_value2.Clean(schema3, value2);
      } catch {
        return value2;
      }
    }
  return value2;
};
var getSchemaValidator = (s, { models = {}, dynamic = false, normalize = false, additionalProperties = false, coerce = false, additionalCoerce = [] } = {}) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  let schema3 = typeof s === "string" ? models[s] : s;
  if (coerce || additionalCoerce)
    if (coerce)
      schema3 = replaceSchemaType(schema3, [{ from: t.Number(), to: (options) => t.Numeric(options), untilObjectFound: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), untilObjectFound: true }, ...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]]);
    else
      schema3 = replaceSchemaType(schema3, [...Array.isArray(additionalCoerce) ? additionalCoerce : [additionalCoerce]]);
  if (schema3.type === "object" && "additionalProperties" in schema3 === false)
    schema3.additionalProperties = additionalProperties;
  if (dynamic) {
    let validator = { schema: schema3, references: "", checkFunc: () => {
    }, code: "", Check: (value2) => exports_value2.Check(schema3, value2), Errors: (value2) => exports_value2.Errors(schema3, value2), Code: () => "", Clean: createCleaner(schema3), Decode: (value2) => exports_value2.Decode(schema3, value2), Encode: (value2) => exports_value2.Encode(schema3, value2) };
    if (normalize && schema3.additionalProperties === false)
      validator.Clean = createCleaner(schema3);
    if (schema3.config) {
      if (validator.config = schema3.config, validator?.schema?.config)
        delete validator.schema.config;
    }
    return validator.parse = (v) => {
      try {
        return validator.Decode(v);
      } catch (error3) {
        throw [...validator.Errors(v)].map(mapValueError);
      }
    }, validator.safeParse = (v) => {
      try {
        return { success: true, data: validator.Decode(v), error: null };
      } catch (error3) {
        let errors2 = [...compiled.Errors(v)].map(mapValueError);
        return { success: false, data: null, error: errors2[0]?.summary, errors: errors2 };
      }
    }, validator;
  }
  let compiled = TypeCompiler.Compile(schema3, Object.values(models));
  if (compiled.Clean = createCleaner(schema3), schema3.config) {
    if (compiled.config = schema3.config, compiled?.schema?.config)
      delete compiled.schema.config;
  }
  return compiled.parse = (v) => {
    try {
      return compiled.Decode(v);
    } catch (error3) {
      throw [...compiled.Errors(v)].map(mapValueError);
    }
  }, compiled.safeParse = (v) => {
    try {
      return { success: true, data: compiled.Decode(v), error: null };
    } catch (error3) {
      let errors2 = [...compiled.Errors(v)].map(mapValueError);
      return { success: false, data: null, error: errors2[0]?.summary, errors: errors2 };
    }
  }, compiled;
};
var getResponseSchemaValidator = (s, { models = {}, dynamic = false, normalize = false, additionalProperties = false }) => {
  if (!s)
    return;
  if (typeof s === "string" && !(s in models))
    return;
  let maybeSchemaOrRecord = typeof s === "string" ? models[s] : s, compile = (schema3, references) => {
    if (dynamic)
      return { schema: schema3, references: "", checkFunc: () => {
      }, code: "", Check: (value2) => exports_value2.Check(schema3, value2), Errors: (value2) => exports_value2.Errors(schema3, value2), Code: () => "", Clean: createCleaner(schema3), Decode: (value2) => exports_value2.Decode(schema3, value2), Encode: (value2) => exports_value2.Encode(schema3, value2) };
    let compiledValidator = TypeCompiler.Compile(schema3, references);
    if (normalize && schema3.additionalProperties === false)
      compiledValidator.Clean = createCleaner(schema3);
    return compiledValidator;
  };
  if (Kind in maybeSchemaOrRecord) {
    if ("additionalProperties" in maybeSchemaOrRecord === false)
      maybeSchemaOrRecord.additionalProperties = additionalProperties;
    return { 200: compile(maybeSchemaOrRecord, Object.values(models)) };
  }
  let record3 = {};
  return Object.keys(maybeSchemaOrRecord).forEach((status) => {
    let maybeNameOrSchema = maybeSchemaOrRecord[+status];
    if (typeof maybeNameOrSchema === "string") {
      if (maybeNameOrSchema in models) {
        let schema3 = models[maybeNameOrSchema];
        schema3.type === "object" && "additionalProperties" in schema3, record3[+status] = Kind in schema3 ? compile(schema3, Object.values(models)) : schema3;
      }
      return;
    }
    if (maybeNameOrSchema.type === "object" && "additionalProperties" in maybeNameOrSchema === false)
      maybeNameOrSchema.additionalProperties = additionalProperties;
    record3[+status] = Kind in maybeNameOrSchema ? compile(maybeNameOrSchema, Object.values(models)) : maybeNameOrSchema;
  }), record3;
};
var isBun = typeof Bun !== "undefined";
var hasHash = isBun && typeof Bun.hash === "function";
var checksum = (s) => {
  if (hasHash)
    return Bun.hash(s);
  let h = 9;
  for (let i = 0;i < s.length; )
    h = Math.imul(h ^ s.charCodeAt(i++), 387420489);
  return h = h ^ h >>> 9;
};
var _stringToStructureCoercions;
var stringToStructureCoercions = () => {
  if (!_stringToStructureCoercions)
    _stringToStructureCoercions = [{ from: t.Object({}), to: () => t.ObjectString({}), excludeRoot: true }, { from: t.Array(t.Any()), to: () => t.ArrayString(t.Any()) }];
  return _stringToStructureCoercions;
};
var _coercePrimitiveRoot;
var coercePrimitiveRoot = () => {
  if (!_coercePrimitiveRoot)
    _coercePrimitiveRoot = [{ from: t.Number(), to: (options) => t.Numeric(options), rootOnly: true }, { from: t.Boolean(), to: (options) => t.BooleanString(options), rootOnly: true }];
  return _coercePrimitiveRoot;
};
var getCookieValidator = ({ validator, defaultConfig = {}, config, dynamic, models }) => {
  let cookieValidator = getSchemaValidator(validator, { dynamic, models, additionalProperties: true, coerce: true, additionalCoerce: stringToStructureCoercions() });
  if (isNotEmpty(defaultConfig))
    if (cookieValidator)
      cookieValidator.config = mergeCookie(cookieValidator.config, config);
    else
      cookieValidator = getSchemaValidator(t.Cookie({}), { dynamic, models, additionalProperties: true }), cookieValidator.config = defaultConfig;
  return cookieValidator;
};
var injectChecksum = (checksum2, x) => {
  if (!x)
    return;
  if (!Array.isArray(x)) {
    let fn = x;
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
    return fn;
  }
  let fns = [...x];
  for (let fn of fns) {
    if (checksum2 && !fn.checksum)
      fn.checksum = checksum2;
    if (fn.scope === "scoped")
      fn.scope = "local";
  }
  return fns;
};
var mergeLifeCycle = (a, b, checksum2) => {
  return { start: mergeObjectArray(a.start, injectChecksum(checksum2, b?.start)), request: mergeObjectArray(a.request, injectChecksum(checksum2, b?.request)), parse: mergeObjectArray(a.parse, injectChecksum(checksum2, b?.parse)), transform: mergeObjectArray(a.transform, injectChecksum(checksum2, b?.transform)), beforeHandle: mergeObjectArray(a.beforeHandle, injectChecksum(checksum2, b?.beforeHandle)), afterHandle: mergeObjectArray(a.afterHandle, injectChecksum(checksum2, b?.afterHandle)), mapResponse: mergeObjectArray(a.mapResponse, injectChecksum(checksum2, b?.mapResponse)), afterResponse: mergeObjectArray(a.afterResponse, injectChecksum(checksum2, b?.afterResponse)), trace: mergeObjectArray(a.trace, injectChecksum(checksum2, b?.trace)), error: mergeObjectArray(a.error, injectChecksum(checksum2, b?.error)), stop: mergeObjectArray(a.stop, injectChecksum(checksum2, b?.stop)) };
};
var asHookType = (fn, inject, { skipIfHasType = false } = {}) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (skipIfHasType)
      fn.scope ??= inject;
    else
      fn.scope = inject;
    return fn;
  }
  for (let x of fn)
    if (skipIfHasType)
      x.scope ??= inject;
    else
      x.scope = inject;
  return fn;
};
var filterGlobal = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn))
    switch (fn.scope) {
      case "global":
      case "scoped":
        return { ...fn };
      default:
        return { fn };
    }
  let array3 = [];
  for (let x of fn)
    switch (x.scope) {
      case "global":
      case "scoped":
        array3.push({ ...x });
        break;
    }
  return array3;
};
var filterGlobalHook = (hook) => {
  return { ...hook, type: hook?.type, detail: hook?.detail, parse: filterGlobal(hook?.parse), transform: filterGlobal(hook?.transform), beforeHandle: filterGlobal(hook?.beforeHandle), afterHandle: filterGlobal(hook?.afterHandle), mapResponse: filterGlobal(hook?.mapResponse), afterResponse: filterGlobal(hook?.afterResponse), error: filterGlobal(hook?.error), trace: filterGlobal(hook?.trace) };
};
var StatusMap = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var InvertedStatusMap = Object.fromEntries(Object.entries(StatusMap).map(([k, v]) => [v, k]));
function removeTrailingEquals(digest) {
  let trimmedDigest = digest;
  while (trimmedDigest.endsWith("="))
    trimmedDigest = trimmedDigest.slice(0, -1);
  return trimmedDigest;
}
var encoder = new TextEncoder;
var signCookie = async (val, secret) => {
  if (typeof val !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  let secretKey = await crypto.subtle.importKey("raw", encoder.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), hmacBuffer = await crypto.subtle.sign("HMAC", secretKey, encoder.encode(val));
  return val + "." + removeTrailingEquals(Buffer.from(hmacBuffer).toString("base64"));
};
var unsignCookie = async (input, secret) => {
  if (typeof input !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret === null)
    throw new TypeError("Secret key must be provided.");
  let tentativeValue = input.slice(0, input.lastIndexOf("."));
  return await signCookie(tentativeValue, secret) === input ? tentativeValue : false;
};
var traceBackMacro = (extension, property) => {
  if (!extension || typeof extension !== "object" || !property)
    return;
  for (let [key, value2] of Object.entries(property)) {
    if (key in primitiveHookMap || !(key in extension))
      continue;
    let v = extension[key];
    if (typeof v === "function")
      v(value2), delete property[key];
  }
};
var createMacroManager = ({ globalHook, localHook }) => (stackName) => (type3, fn) => {
  if (typeof type3 === "function")
    type3 = { fn: type3 };
  if ("fn" in type3 || Array.isArray(type3)) {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (Array.isArray(type3))
      localHook[stackName] = localHook[stackName].concat(type3);
    else
      localHook[stackName].push(type3);
    return;
  }
  let { insert = "after", stack = "local" } = type3;
  if (typeof fn === "function")
    fn = { fn };
  if (stack === "global")
    if (!Array.isArray(fn))
      if (insert === "before")
        globalHook[stackName].unshift(fn);
      else
        globalHook[stackName].push(fn);
    else if (insert === "before")
      globalHook[stackName] = fn.concat(globalHook[stackName]);
    else
      globalHook[stackName] = globalHook[stackName].concat(fn);
  else {
    if (!localHook[stackName])
      localHook[stackName] = [];
    if (typeof localHook[stackName] === "function")
      localHook[stackName] = [localHook[stackName]];
    if (!Array.isArray(fn))
      if (insert === "before")
        localHook[stackName].unshift(fn);
      else
        localHook[stackName].push(fn);
    else if (insert === "before")
      localHook[stackName] = fn.concat(localHook[stackName]);
    else
      localHook[stackName] = localHook[stackName].concat(fn);
  }
};
var parseNumericString = (message) => {
  if (typeof message === "number")
    return message;
  if (message.length < 16) {
    if (message.trim().length === 0)
      return null;
    let length = Number(message);
    if (Number.isNaN(length))
      return null;
    return length;
  }
  if (message.length === 16) {
    if (message.trim().length === 0)
      return null;
    let number3 = Number(message);
    if (Number.isNaN(number3) || number3.toString() !== message)
      return null;
    return number3;
  }
  return null;
};
var isNumericString = (message) => parseNumericString(message) !== null;

class PromiseGroup {
  onError;
  root = null;
  promises = [];
  constructor(onError = console.error) {
    this.onError = onError;
  }
  get size() {
    return this.promises.length;
  }
  add(promise3) {
    return this.promises.push(promise3), this.root ||= this.drain(), promise3;
  }
  async drain() {
    while (this.promises.length > 0) {
      try {
        await this.promises[0];
      } catch (error3) {
        this.onError(error3);
      }
      this.promises.shift();
    }
    this.root = null;
  }
  then(onfulfilled, onrejected) {
    return (this.root ?? Promise.resolve()).then(onfulfilled, onrejected);
  }
}
var fnToContainer = (fn) => {
  if (!fn)
    return fn;
  if (!Array.isArray(fn)) {
    if (typeof fn === "function")
      return { fn };
    else if ("fn" in fn)
      return fn;
  }
  let fns = [];
  for (let x of fn)
    if (typeof x === "function")
      fns.push({ fn: x });
    else if ("fn" in x)
      fns.push(x);
  return fns;
};
var localHookToLifeCycleStore = (a) => {
  return { ...a, start: fnToContainer(a?.start), request: fnToContainer(a?.request), parse: fnToContainer(a?.parse), transform: fnToContainer(a?.transform), beforeHandle: fnToContainer(a?.beforeHandle), afterHandle: fnToContainer(a?.afterHandle), mapResponse: fnToContainer(a?.mapResponse), afterResponse: fnToContainer(a?.afterResponse), trace: fnToContainer(a?.trace), error: fnToContainer(a?.error), stop: fnToContainer(a?.stop) };
};
var lifeCycleToFn = (a) => {
  return { ...a, start: a.start?.map((x) => x.fn), request: a.request?.map((x) => x.fn), parse: a.parse?.map((x) => x.fn), transform: a.transform?.map((x) => x.fn), beforeHandle: a.beforeHandle?.map((x) => x.fn), afterHandle: a.afterHandle?.map((x) => x.fn), afterResponse: a.afterResponse?.map((x) => x.fn), mapResponse: a.mapResponse?.map((x) => x.fn), trace: a.trace?.map((x) => x.fn), error: a.error?.map((x) => x.fn), stop: a.stop?.map((x) => x.fn) };
};
var cloneInference = (inference) => ({ body: inference.body, cookie: inference.cookie, headers: inference.headers, query: inference.query, set: inference.set, server: inference.server });
var redirect = (url, status = 302) => Response.redirect(url, status);
var ELYSIA_FORM_DATA = Symbol("ElysiaFormData");
var ELYSIA_REQUEST_ID = Symbol("ElysiaRequestId");
var randomId = () => crypto.getRandomValues(new Uint32Array(1))[0];
var deduplicateChecksum = (array3) => {
  let hashes = [];
  for (let i = 0;i < array3.length; i++) {
    let item = array3[i];
    if (item.checksum) {
      if (hashes.includes(item.checksum))
        array3.splice(i, 1), i--;
      hashes.push(item.checksum);
    }
  }
  return array3;
};
var promoteEvent = (events, as = "scoped") => {
  if (as === "scoped") {
    for (let event of events)
      if ("scope" in event && event.scope === "local")
        event.scope = "scoped";
    return;
  }
  for (let event of events)
    if ("scope" in event)
      event.scope = "global";
};
var env = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var ERROR_CODE = Symbol("ElysiaErrorCode");
var isProduction = (env?.NODE_ENV ?? env?.ENV) === "production";

class ElysiaCustomStatusResponse {
  code;
  response;
  constructor(code, response) {
    let res = response ?? (code in InvertedStatusMap ? InvertedStatusMap[code] : code);
    this.code = StatusMap[code] ?? code, this.response = res;
  }
}
var error3 = (code, response) => new ElysiaCustomStatusResponse(code, response);

class InternalServerError extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor(message) {
    super(message ?? "INTERNAL_SERVER_ERROR");
  }
}

class NotFoundError extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor(message) {
    super(message ?? "NOT_FOUND");
  }
}

class ParseError extends Error {
  code = "PARSE";
  status = 400;
  constructor() {
    super("Failed to parse body");
  }
}

class InvalidCookieSignature extends Error {
  key;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor(key, message) {
    super(message ?? `"${key}" has invalid cookie signature`);
    this.key = key;
  }
}
var mapValueError = (error22) => {
  if (!error22)
    return { summary: undefined };
  let { message, path, value: value2, type: type3 } = error22, property = path.slice(1).replaceAll("/", "."), isRoot = path === "";
  switch (type3) {
    case 42:
      return { ...error22, summary: isRoot ? "Value should not be provided" : `Property '${property}' should not be provided` };
    case 45:
      return { ...error22, summary: isRoot ? "Value is missing" : `Property '${property}' is missing` };
    case 50:
      let quoteIndex = message.indexOf("'"), format = message.slice(quoteIndex + 1, message.indexOf("'", quoteIndex + 1));
      return { ...error22, summary: isRoot ? "Value should be an email" : `Property '${property}' should be ${format}` };
    case 54:
      return { ...error22, summary: `${message.slice(0, 9)} property '${property}' to be ${message.slice(8)} but found: ${value2}` };
    case 62:
      let union4 = error22.schema.anyOf.map((x) => `'${x?.format ?? x.type}'`).join(", ");
      return { ...error22, summary: isRoot ? `Value should be one of ${union4}` : `Property '${property}' should be one of: ${union4}` };
    default:
      return { summary: message, ...error22 };
  }
};

class ValidationError extends Error {
  type;
  validator;
  value;
  code = "VALIDATION";
  status = 422;
  constructor(type3, validator, value2) {
    if (value2 && typeof value2 === "object" && value2 instanceof ElysiaCustomStatusResponse)
      value2 = value2.response;
    let error22 = isProduction ? undefined : ("Errors" in validator) ? validator.Errors(value2).First() : exports_value2.Errors(validator, value2).First(), customError = error22?.schema.error !== undefined ? typeof error22.schema.error === "function" ? error22.schema.error({ type: type3, validator, value: value2, get errors() {
      return [...validator.Errors(value2)].map(mapValueError);
    } }) : error22.schema.error : undefined, accessor = error22?.path || "root", message = "";
    if (customError !== undefined)
      message = typeof customError === "object" ? JSON.stringify(customError) : customError + "";
    else if (isProduction)
      message = JSON.stringify({ type: "validation", on: type3, summary: mapValueError(error22).summary, message: error22?.message, found: value2 });
    else {
      let schema3 = validator?.schema ?? validator, errors2 = "Errors" in validator ? [...validator.Errors(value2)].map(mapValueError) : [...exports_value2.Errors(validator, value2)].map(mapValueError), expected;
      try {
        expected = exports_value2.Create(schema3);
      } catch (error32) {
        expected = { type: "Could not create expected value", message: error32?.message, error: error32 };
      }
      message = JSON.stringify({ type: "validation", on: type3, summary: errors2[0]?.summary, property: accessor, message: error22?.message, expected, found: value2, errors: errors2 }, null, 2);
    }
    super(message);
    this.type = type3;
    this.validator = validator;
    this.value = value2;
    Object.setPrototypeOf(this, ValidationError.prototype);
  }
  get all() {
    return "Errors" in this.validator ? [...this.validator.Errors(this.value)].map(mapValueError) : [...exports_value2.Errors(this.validator, this.value)].map(mapValueError);
  }
  static simplifyModel(validator) {
    let model = "schema" in validator ? validator.schema : validator;
    try {
      return exports_value2.Create(model);
    } catch {
      return model;
    }
  }
  get model() {
    return ValidationError.simplifyModel(this.validator);
  }
  toResponse(headers) {
    return new Response(this.message, { status: 400, headers: { ...headers, "content-type": "application/json" } });
  }
}
var websocket = { open(ws) {
  ws.data.open?.(ws);
}, message(ws, message) {
  ws.data.message?.(ws, message);
}, drain(ws) {
  ws.data.drain?.(ws);
}, close(ws, code, reason) {
  ws.data.close?.(ws, code, reason);
} };

class ElysiaWS {
  raw;
  data;
  validator;
  _validator;
  constructor(raw, data) {
    this.raw = raw;
    this.data = data;
    if (this.validator = raw.data.validator, raw.data.id)
      this.id = raw.data.id;
    else
      this.id = randomId().toString();
  }
  get id() {
    return this.raw.data.id;
  }
  set id(newID) {
    this.raw.data.id = newID;
  }
  get publish() {
    return (topic, data = undefined, compress) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (typeof data === "object")
        data = JSON.stringify(data);
      return this.raw.publish(topic, data, compress), this;
    };
  }
  get send() {
    return (data) => {
      if (this.validator?.Check(data) === false)
        throw new ValidationError("message", this.validator, data);
      if (Buffer.isBuffer(data))
        return this.raw.send(data), this;
      if (typeof data === "object")
        data = JSON.stringify(data);
      return this.raw.send(data), this;
    };
  }
  get subscribe() {
    return (room) => {
      return this.raw.subscribe(room), this;
    };
  }
  get unsubscribe() {
    return (room) => {
      return this.raw.unsubscribe(room), this;
    };
  }
  get cork() {
    return (callback) => {
      return this.raw.cork(callback), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var version = "1.1.26";
var import_fast_decode_uri_component2 = __toESM2(require_fast_decode_uri_component(), 1);
var plusRegex = /\+/g;
function parseQueryFromURL(input) {
  let result = {};
  if (typeof input !== "string")
    return result;
  let key = "", value2 = "", startingIndex = -1, equalityIndex = -1, flags = 0, l = input.length;
  for (let i = 0;i < l; i++)
    switch (input.charCodeAt(i)) {
      case 38:
        let hasBothKeyValuePair = equalityIndex > startingIndex;
        if (!hasBothKeyValuePair)
          equalityIndex = i;
        if (key = input.slice(startingIndex + 1, equalityIndex), hasBothKeyValuePair || key.length > 0) {
          if (flags & 1)
            key = key.replace(plusRegex, " ");
          if (flags & 2)
            key = import_fast_decode_uri_component2.default(key) || key;
          if (!result[key]) {
            if (hasBothKeyValuePair) {
              if (value2 = input.slice(equalityIndex + 1, i), flags & 4)
                value2 = value2.replace(plusRegex, " ");
              if (flags & 8)
                value2 = import_fast_decode_uri_component2.default(value2) || value2;
            }
            result[key] = value2;
          }
        }
        key = "", value2 = "", startingIndex = i, equalityIndex = i, flags = 0;
        break;
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          flags |= 8;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          flags |= 4;
        else
          flags |= 1;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          flags |= 8;
        else
          flags |= 2;
        break;
    }
  if (startingIndex < l) {
    let hasBothKeyValuePair = equalityIndex > startingIndex;
    if (key = input.slice(startingIndex + 1, hasBothKeyValuePair ? equalityIndex : l), hasBothKeyValuePair || key.length > 0) {
      if (flags & 1)
        key = key.replace(plusRegex, " ");
      if (flags & 2)
        key = import_fast_decode_uri_component2.default(key) || key;
      if (!result[key]) {
        if (hasBothKeyValuePair) {
          if (value2 = input.slice(equalityIndex + 1, l), flags & 4)
            value2 = value2.replace(plusRegex, " ");
          if (flags & 8)
            value2 = import_fast_decode_uri_component2.default(value2) || value2;
        }
        result[key] = value2;
      }
    }
  }
  return result;
}
var parseQuery = (input) => {
  let result = {};
  if (typeof input !== "string")
    return result;
  let inputLength = input.length, key = "", value2 = "", startingIndex = -1, equalityIndex = -1, shouldDecodeKey = false, shouldDecodeValue = false, keyHasPlus = false, valueHasPlus = false, hasBothKeyValuePair = false, c = 0;
  for (let i = 0;i < inputLength + 1; i++) {
    if (i !== inputLength)
      c = input.charCodeAt(i);
    else
      c = 38;
    switch (c) {
      case 38: {
        if (hasBothKeyValuePair = equalityIndex > startingIndex, !hasBothKeyValuePair)
          equalityIndex = i;
        if (key = input.slice(startingIndex + 1, equalityIndex), hasBothKeyValuePair || key.length > 0) {
          if (keyHasPlus)
            key = key.replace(plusRegex, " ");
          if (shouldDecodeKey)
            key = import_fast_decode_uri_component2.default(key) || key;
          if (hasBothKeyValuePair) {
            if (value2 = input.slice(equalityIndex + 1, i), valueHasPlus)
              value2 = value2.replace(plusRegex, " ");
            if (shouldDecodeValue)
              value2 = import_fast_decode_uri_component2.default(value2) || value2;
          }
          let currentValue = result[key];
          if (currentValue === undefined)
            result[key] = value2;
          else if (currentValue.pop)
            currentValue.push(value2);
          else
            result[key] = [currentValue, value2];
        }
        value2 = "", startingIndex = i, equalityIndex = i, shouldDecodeKey = false, shouldDecodeValue = false, keyHasPlus = false, valueHasPlus = false;
        break;
      }
      case 61:
        if (equalityIndex <= startingIndex)
          equalityIndex = i;
        else
          shouldDecodeValue = true;
        break;
      case 43:
        if (equalityIndex > startingIndex)
          valueHasPlus = true;
        else
          keyHasPlus = true;
        break;
      case 37:
        if (equalityIndex > startingIndex)
          shouldDecodeValue = true;
        else
          shouldDecodeKey = true;
        break;
    }
  }
  return result;
};
var import_fast_decode_uri_component3 = __toESM2(require_fast_decode_uri_component(), 1);
var ELYSIA_TRACE = Symbol("ElysiaTrace");
var createProcess = () => {
  let { promise: promise3, resolve } = Promise.withResolvers(), { promise: end, resolve: resolveEnd } = Promise.withResolvers(), { promise: error22, resolve: resolveError } = Promise.withResolvers(), callbacks = [], callbacksEnd = [];
  return [(callback) => {
    if (callback)
      callbacks.push(callback);
    return promise3;
  }, (process2) => {
    let processes = [], resolvers = [], groupError = null;
    for (let i = 0;i < (process2.total ?? 0); i++) {
      let { promise: promise22, resolve: resolve2 } = Promise.withResolvers(), { promise: end2, resolve: resolveEnd2 } = Promise.withResolvers(), { promise: error32, resolve: resolveError2 } = Promise.withResolvers(), callbacks2 = [], callbacksEnd2 = [];
      processes.push((callback) => {
        if (callback)
          callbacks2.push(callback);
        return promise22;
      }), resolvers.push((process3) => {
        let result2 = { ...process3, end: end2, error: error32, index: i, onStop(callback) {
          if (callback)
            callbacksEnd2.push(callback);
          return end2;
        } };
        resolve2(result2);
        for (let i2 = 0;i2 < callbacks2.length; i2++)
          callbacks2[i2](result2);
        return (error4 = null) => {
          let end3 = performance.now();
          if (error4)
            groupError = error4;
          let detail = { end: end3, error: error4, get elapsed() {
            return end3 - process3.begin;
          } };
          for (let i2 = 0;i2 < callbacksEnd2.length; i2++)
            callbacksEnd2[i2](detail);
          resolveEnd2(end3), resolveError2(error4);
        };
      });
    }
    let result = { ...process2, end, error: error22, onEvent(callback) {
      for (let i = 0;i < processes.length; i++)
        processes[i](callback);
    }, onStop(callback) {
      if (callback)
        callbacksEnd.push(callback);
      return end;
    } };
    resolve(result);
    for (let i = 0;i < callbacks.length; i++)
      callbacks[i](result);
    return { resolveChild: resolvers, resolve(error32 = null) {
      let end2 = performance.now();
      if (!error32 && groupError)
        error32 = groupError;
      let detail = { end: end2, error: error32, get elapsed() {
        return end2 - process2.begin;
      } };
      for (let i = 0;i < callbacksEnd.length; i++)
        callbacksEnd[i](detail);
      resolveEnd(end2), resolveError(error32);
    } };
  }];
};
var createTracer = (traceListener) => {
  return (context) => {
    let [onRequest, resolveRequest] = createProcess(), [onParse, resolveParse] = createProcess(), [onTransform, resolveTransform] = createProcess(), [onBeforeHandle, resolveBeforeHandle] = createProcess(), [onHandle, resolveHandle] = createProcess(), [onAfterHandle, resolveAfterHandle] = createProcess(), [onError, resolveError] = createProcess(), [onMapResponse, resolveMapResponse] = createProcess(), [onAfterResponse, resolveAfterResponse] = createProcess();
    return traceListener({ id: context[ELYSIA_REQUEST_ID], context, set: context.set, onRequest, onParse, onTransform, onBeforeHandle, onHandle, onAfterHandle, onMapResponse, onAfterResponse, onError }), { request: resolveRequest, parse: resolveParse, transform: resolveTransform, beforeHandle: resolveBeforeHandle, handle: resolveHandle, afterHandle: resolveAfterHandle, error: resolveError, mapResponse: resolveMapResponse, afterResponse: resolveAfterResponse };
  };
};
var headersHasToJSON = new Headers().toJSON;
var TypeBoxSymbol = { optional: Symbol.for("TypeBox.Optional"), kind: Symbol.for("TypeBox.Kind") };
var isOptional = (validator) => {
  if (!validator)
    return false;
  let schema3 = validator?.schema;
  return !!schema3 && TypeBoxSymbol.optional in schema3;
};
var hasAdditionalProperties = (_schema) => {
  if (!_schema)
    return false;
  let schema3 = _schema?.schema ?? _schema;
  if (schema3.anyOf)
    return schema3.anyOf.some(hasAdditionalProperties);
  if (schema3.someOf)
    return schema3.someOf.some(hasAdditionalProperties);
  if (schema3.allOf)
    return schema3.allOf.some(hasAdditionalProperties);
  if (schema3.not)
    return schema3.not.some(hasAdditionalProperties);
  if (schema3.type === "object") {
    let properties = schema3.properties;
    if ("additionalProperties" in schema3)
      return schema3.additionalProperties;
    if ("patternProperties" in schema3)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasAdditionalProperties(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasAdditionalProperties(property.anyOf[i]))
            return true;
      }
      return property.additionalProperties;
    }
    return false;
  }
  return false;
};
var createReport = ({ context = "c", trace, addFn }) => {
  if (!trace.length)
    return () => {
      return { resolveChild() {
        return () => {
        };
      }, resolve() {
      } };
    };
  for (let i = 0;i < trace.length; i++)
    addFn(`let report${i}, reportChild${i}, reportErr${i}, reportErrChild${i}; let trace${i} = ${context}[ELYSIA_TRACE]?.[${i}] ?? trace[${i}](${context});
`);
  return (event, { name, total = 0 } = {}) => {
    if (!name)
      name = "anonymous";
    let reporter = event === "error" ? "reportErr" : "report";
    for (let i = 0;i < trace.length; i++)
      addFn(`
${reporter}${i} = trace${i}.${event}({id,event: '${event}',name: '${name}',begin: performance.now(),total: ${total}})
`);
    return { resolve() {
      for (let i = 0;i < trace.length; i++)
        addFn(`
${reporter}${i}.resolve()
`);
    }, resolveChild(name2) {
      for (let i = 0;i < trace.length; i++)
        addFn(`${reporter}Child${i} = ${reporter}${i}.resolveChild?.shift()?.({id,event: '${event}',name: '${name2}',begin: performance.now()})
`);
      return (binding) => {
        for (let i = 0;i < trace.length; i++)
          if (binding)
            addFn(`
                             \tif (${binding} instanceof Error)
                    \t\t\t\t${reporter}Child${i}?.(${binding})
                           \t\telse
                             \t\t${reporter}Child${i}?.()
`);
          else
            addFn(`${reporter}Child${i}?.()
`);
      };
    } };
  };
};
var composeValidationFactory = ({ injectResponse = "", normalize = false, validator }) => ({ composeValidation: (type3, value2 = `c.${type3}`) => `c.set.status = 422; throw new ValidationError('${type3}', validator.${type3}, ${value2})`, composeResponseValidation: (name = "r") => {
  let code = `
` + injectResponse + `
`;
  code += `if(${name} instanceof ElysiaCustomStatusResponse) {
\t\t\tc.set.status = ${name}.code
\t\t\t${name} = ${name}.response
\t\t}

\t\tconst isResponse = ${name} instanceof Response

`, code += `switch(c.set.status) {
`;
  for (let [status, value2] of Object.entries(validator.response)) {
    if (code += `\tcase ${status}:
\t\t\t\tif (!isResponse) {
`, normalize && "Clean" in value2 && !hasAdditionalProperties(value2))
      code += `${name} = validator.response['${status}'].Clean(${name})
`;
    code += `if(validator.response['${status}'].Check(${name}) === false) {
\t\t\t\t\tc.set.status = 422

\t\t\t\t\tthrow new ValidationError('response', validator.response['${status}'], ${name})
\t\t\t\t}

\t\t\t\tc.set.status = ${status}
\t\t\t}

\t\t\tbreak

`;
  }
  return code += `
}
`, code;
} });
var KindSymbol = Symbol.for("TypeBox.Kind");
var hasProperty = (expectedProperty, schema3) => {
  if (!schema3)
    return;
  if (schema3.type === "object") {
    let properties = schema3.properties;
    if (!properties)
      return false;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (expectedProperty in property)
        return true;
      if (property.type === "object") {
        if (hasProperty(expectedProperty, property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasProperty(expectedProperty, property.anyOf[i]))
            return true;
      }
    }
    return false;
  }
  return expectedProperty in schema3;
};
var TransformSymbol = Symbol.for("TypeBox.Transform");
var hasTransform = (schema3) => {
  if (!schema3)
    return;
  if (schema3.type === "object" && schema3.properties) {
    let properties = schema3.properties;
    for (let key of Object.keys(properties)) {
      let property = properties[key];
      if (property.type === "object") {
        if (hasTransform(property))
          return true;
      } else if (property.anyOf) {
        for (let i = 0;i < property.anyOf.length; i++)
          if (hasTransform(property.anyOf[i]))
            return true;
      }
      if (TransformSymbol in property)
        return true;
    }
    return false;
  }
  return TransformSymbol in schema3 || schema3.properties && TransformSymbol in schema3.properties;
};
var matchFnReturn = /(?:return|=>) \S+\(/g;
var isAsyncName = (v) => {
  return (v?.fn ?? v).constructor.name === "AsyncFunction";
};
var isAsync = (v) => {
  let fn = v?.fn ?? v;
  if (fn.constructor.name === "AsyncFunction")
    return true;
  let literal3 = fn.toString();
  if (literal3.includes("=> response.clone("))
    return false;
  if (literal3.includes("await"))
    return true;
  if (literal3.includes("async"))
    return true;
  return !!literal3.match(matchFnReturn);
};
var isGenerator = (v) => {
  let fn = v?.fn ?? v;
  return fn.constructor.name === "AsyncGeneratorFunction" || fn.constructor.name === "GeneratorFunction";
};
var composeHandler = ({ app, path, method, localHook, hooks, validator, handler, allowMeta = false, inference }) => {
  let isHandleFn = typeof handler === "function";
  if (!isHandleFn) {
    if (handler = mapResponse(handler, { headers: app.setHeaders ?? {} }), hooks.parse.length === 0 && hooks.transform.length === 0 && hooks.beforeHandle.length === 0 && hooks.afterHandle.length === 0)
      return Function("a", "return function () { return a.clone() }")(handler);
  }
  let handle = isHandleFn ? "handler(c)" : "handler", hasAfterResponse = hooks.afterResponse.length > 0, hasTrace = hooks.trace.length > 0, fnLiteral = "";
  if (inference = sucrose(Object.assign(localHook, { handler }), inference), inference.server)
    fnLiteral += `
Object.defineProperty(c, 'server', {
\t\t\tget: function() { return getServer() }
\t\t})
`;
  if (inference.body)
    fnLiteral += `let isParsing = false
`;
  validator.createBody?.(), validator.createQuery?.(), validator.createHeaders?.(), validator.createParams?.(), validator.createCookie?.(), validator.createResponse?.();
  let hasQuery = inference.query || !!validator.query, hasBody = method !== "$INTERNALWS" && method !== "GET" && method !== "HEAD" && (inference.body || !!validator.body || hooks.parse.length), defaultHeaders = app.setHeaders, hasDefaultHeaders = defaultHeaders && !!Object.keys(defaultHeaders).length, hasHeaders = inference.headers || validator.headers, hasCookie = inference.cookie || !!validator.cookie, cookieValidator = hasCookie ? getCookieValidator({ validator: validator.cookie, defaultConfig: app.config.cookie, dynamic: !!app.config.aot, config: validator.cookie?.config ?? {}, models: app.definitions.type }) : undefined, cookieMeta = cookieValidator?.config, encodeCookie = "";
  if (cookieMeta?.sign) {
    if (!cookieMeta.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${method}) ${path}.`);
    let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
    if (encodeCookie += `const _setCookie = c.set.cookie
\t\tif(_setCookie) {`, cookieMeta.sign === true)
      encodeCookie += `for(const [key, cookie] of Object.entries(_setCookie)) {
\t\t\t\tc.set.cookie[key].value = await signCookie(cookie.value, '${secret}')
\t\t\t}`;
    else
      for (let name of cookieMeta.sign)
        encodeCookie += `if(_setCookie['${name}']?.value) { c.set.cookie['${name}'].value = await signCookie(_setCookie['${name}'].value, '${secret}') }
`;
    encodeCookie += `}
`;
  }
  let normalize = app.config.normalize, { composeValidation, composeResponseValidation } = composeValidationFactory({ normalize, validator });
  if (hasHeaders)
    fnLiteral += headersHasToJSON ? `c.headers = c.request.headers.toJSON()
` : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
\t\t\t\t\tc.headers[key] = value
\t\t\t\t`;
  if (hasCookie) {
    let get = (name, defaultValue) => {
      let value2 = cookieMeta?.[name] ?? defaultValue;
      if (!value2)
        return typeof defaultValue === "string" ? `${name}: "${defaultValue}",` : `${name}: ${defaultValue},`;
      if (typeof value2 === "string")
        return `${name}: '${value2}',`;
      if (value2 instanceof Date)
        return `${name}: new Date(${value2.getTime()}),`;
      return `${name}: ${value2},`;
    }, options = cookieMeta ? `{
\t\t\tsecrets: ${cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? `'${cookieMeta.secrets}'` : "[" + cookieMeta.secrets.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},
\t\t\tsign: ${cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? "[" + cookieMeta.sign.reduce((a, b) => a + `'${b}',`, "") + "]" : "undefined"},
\t\t\t${get("domain")}
\t\t\t${get("expires")}
\t\t\t${get("httpOnly")}
\t\t\t${get("maxAge")}
\t\t\t${get("path", "/")}
\t\t\t${get("priority")}
\t\t\t${get("sameSite")}
\t\t\t${get("secure")}
\t\t}` : "undefined";
    if (hasHeaders)
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.headers.cookie, ${options})
`;
    else
      fnLiteral += `
c.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${options})
`;
  }
  if (hasQuery) {
    let destructured = [];
    if (validator.query && validator.query.schema.type === "object") {
      let properties = validator.query.schema.properties;
      if (!hasAdditionalProperties(validator.query))
        for (let [key, _value] of Object.entries(properties)) {
          let value2 = _value;
          if (value2 && TypeBoxSymbol.optional in value2 && value2.type === "array" && value2.items)
            value2 = value2.items;
          let { type: type3, anyOf } = value2, isArray = type3 === "array" || anyOf?.some((v) => v.type === "string" && v.format === "ArrayString");
          destructured.push({ key, isArray, isNestedObjectArray: isArray && value2.items?.type === "object" || !!value2.items?.anyOf?.some((x) => x.type === "object" || x.type === "array"), isObject: type3 === "object" || anyOf?.some((v) => v.type === "string" && v.format === "ArrayString"), anyOf: !!anyOf });
        }
    }
    if (!destructured.length)
      fnLiteral += `if(c.qi === -1) {
\t\t\t\tc.query = {}
\t\t\t} else {
\t\t\t\tc.query = parseQueryFromURL(c.url.slice(c.qi + 1))
\t\t\t}`;
    else
      fnLiteral += `if(c.qi !== -1) {
\t\t\t\tlet url = '&' + decodeURIComponent(c.url.slice(c.qi + 1))

\t\t\t\t${destructured.map(({ key, isArray, isObject: isObject2, isNestedObjectArray, anyOf }, index) => {
        let init = `${index === 0 ? "let" : ""} memory = url.indexOf('&${key}=')
\t\t\t\t\t\t\tlet a${index}
`;
        if (isArray)
          return init + (isNestedObjectArray ? `while (memory !== -1) {
\t\t\t\t\t\t\t\t\t\t\tconst start = memory + ${key.length + 2}
\t\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)

\t\t\t\t\t\t\t\t\t\t\tif(a${index} === undefined)
\t\t\t\t\t\t\t\t\t\t\t\ta${index} = ''
\t\t\t\t\t\t\t\t\t\t\telse
\t\t\t\t\t\t\t\t\t\t\t\ta${index} += ','

\t\t\t\t\t\t\t\t\t\t\tlet temp

\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) temp = url.slice(start).replace(/\\+|%20/g, ' ')
\t\t\t\t\t\t\t\t\t\t\telse temp = url.slice(start, memory).replace(/\\+|%20/g, ' ')

\t\t\t\t\t\t\t\t\t\t\tconst charCode = temp.charCodeAt(0)
\t\t\t\t\t\t\t\t\t\t\tif(charCode !== 91 && charCode !== 123)
\t\t\t\t\t\t\t\t\t\t\t\ttemp = '"' + temp + '"'

\t\t\t\t\t\t\t\t\t\t\ta${index} += temp

\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) break

\t\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&${key}=', memory)
\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) break
\t\t\t\t\t\t\t\t\t\t}

\t\t\t\t\t\t\t\t\t\ttry {
\t\t\t\t\t\t\t\t\t\t    if(a${index}.charCodeAt(0) === 91)
\t\t\t\t\t\t\t\t\t\t\t\ta${index} = JSON.parse(a${index})
\t\t\t\t\t\t\t\t\t\t\telse
\t\t\t\t\t\t\t\t\t\t\t\ta${index} = JSON.parse('[' + a${index} + ']')
\t\t\t\t\t\t\t\t\t\t} catch {}
` : `while (memory !== -1) {
\t\t\t\t\t\t\t\t\t\t\tconst start = memory + ${key.length + 2}
\t\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)

\t\t\t\t\t\t\t\t\t\t\tif(a${index} === undefined)
\t\t\t\t\t\t\t\t\t\t\t\ta${index} = []

\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) {
\t\t\t\t\t\t\t\t\t\t\t\ta${index}.push(url.slice(start).replace(/\\+|%20/g, ' '))
\t\t\t\t\t\t\t\t\t\t\t\tbreak
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\telse a${index}.push(url.slice(start, memory).replace(/\\+|%20/g, ' '))

\t\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&${key}=', memory)
\t\t\t\t\t\t\t\t\t\t\tif(memory === -1) break
\t\t\t\t\t\t\t\t\t\t}
`);
        if (isObject2)
          return init + `if (memory !== -1) {
\t\t\t\t\t\t\t\t\t\tconst start = memory + ${key.length + 2}
\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)

\t\t\t\t\t\t\t\t\t\tif(memory === -1) a${index} = url.slice(start).replace(/\\+|%20/g, ' ')
\t\t\t\t\t\t\t\t\t\telse a${index} = url.slice(start, memory).replace(/\\+|%20/g, ' ')

\t\t\t\t\t\t\t\t\t\tif (a${index} !== undefined) {
\t\t\t\t\t\t\t\t\t\t\ttry {
\t\t\t\t\t\t\t\t\t\t\t\ta${index} = JSON.parse(a${index})
\t\t\t\t\t\t\t\t\t\t\t} catch {}
\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t}`;
        return init + `if (memory !== -1) {
\t\t\t\t\t\t\t\t\t\tconst start = memory + ${key.length + 2}
\t\t\t\t\t\t\t\t\t\tmemory = url.indexOf('&', start)

\t\t\t\t\t\t\t\t\t\tif(memory === -1) a${index} = url.slice(start).replace(/\\+|%20/g, ' ')
\t\t\t\t\t\t\t\t\t\telse {
\t\t\t\t\t\t\t\t\t\t\ta${index} = url.slice(start, memory).replace(/\\+|%20/g, ' ')

\t\t\t\t\t\t\t\t\t\t\t${anyOf ? `
\t\t\t\t\t\t\t\t\t\t\tlet deepMemory = url.indexOf('&${key}=', memory)

\t\t\t\t\t\t\t\t\t\t\tif(deepMemory !== -1) {
\t\t\t\t\t\t\t\t\t\t\t\ta${index} = [a${index}]
\t\t\t\t\t\t\t\t\t\t\t\tlet first = true

\t\t\t\t\t\t\t\t\t\t\t\twhile(true) {
\t\t\t\t\t\t\t\t\t\t\t\t\tconst start = deepMemory + ${key.length + 2}
\t\t\t\t\t\t\t\t\t\t\t\t\tif(first)
\t\t\t\t\t\t\t\t\t\t\t\t\t\tfirst = false
\t\t\t\t\t\t\t\t\t\t\t\t\telse
\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeepMemory = url.indexOf('&', start)

\t\t\t\t\t\t\t\t\t\t\t\t\tlet value
\t\t\t\t\t\t\t\t\t\t\t\t\tif(deepMemory === -1) value = url.slice(start).replace(/\\+|%20/g, ' ')
\t\t\t\t\t\t\t\t\t\t\t\t\telse value = url.slice(start, deepMemory).replace(/\\+|%20/g, ' ')

\t\t\t\t\t\t\t\t\t\t\t\t\tconst vStart = value.charCodeAt(0)
\t\t\t\t\t\t\t\t\t\t\t\t\tconst vEnd = value.charCodeAt(value.length - 1)

\t\t\t\t\t\t\t\t\t\t\t\t\tif((vStart === 91 && vEnd === 93) || (vStart === 123 && vEnd === 125))
\t\t\t\t\t\t\t\t\t\t\t\t\t\ttry {
\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ta${index}.push(JSON.parse(value))
\t\t\t\t\t\t\t\t\t\t\t\t\t\t} catch {
\t\t\t\t\t\t\t\t\t\t\t\t\t\t \ta${index}.push(value)
\t\t\t\t\t\t\t\t\t\t\t\t\t\t}

\t\t\t\t\t\t\t\t\t\t\t\t\tif(deepMemory === -1) break
\t\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t\t\t\t` : ""}
\t\t\t\t\t\t\t\t\t\t}
\t\t\t\t\t\t\t\t\t}`;
      }).join(`
`)}

\t\t\t\tc.query = {
\t\t\t\t\t${destructured.map(({ key }, index) => `'${key}': a${index}`).join(", ")}
\t\t\t\t}
\t\t\t} else {
\t\t\t\tc.query = {}
\t\t\t}`;
  }
  if (hasTrace)
    fnLiteral += `
const id = c[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  fnLiteral += `
try {
`;
  let isAsyncHandler = typeof handler === "function" && isAsync(handler), saveResponse = hasTrace || hooks.afterResponse.length > 0 ? "c.response = " : "", maybeAsync = hasCookie || hasBody || isAsyncHandler || hooks.parse.length > 0 || hooks.afterHandle.some(isAsync) || hooks.beforeHandle.some(isAsync) || hooks.transform.some(isAsync) || hooks.mapResponse.some(isAsync), maybeStream = (typeof handler === "function" ? isGenerator(handler) : false) || hooks.beforeHandle.some(isGenerator) || hooks.afterHandle.some(isGenerator) || hooks.transform.some(isGenerator), hasSet = inference.cookie || inference.set || hasHeaders || hasTrace || validator.response || isHandleFn && hasDefaultHeaders || maybeStream, requestMapper = ", c.request";
  fnLiteral += `c.route = \`${path}\`
`;
  let parseReporter = report("parse", { total: hooks.parse.length });
  if (hasBody) {
    let hasBodyInference = hooks.parse.length || inference.body || validator.body;
    if (fnLiteral += `isParsing = true
`, hooks.type && !hooks.parse.length)
      switch (hooks.type) {
        case "json":
        case "application/json":
          if (isOptional(validator.body))
            fnLiteral += "try { c.body = await c.request.json() } catch {}";
          else
            fnLiteral += "c.body = await c.request.json()";
          break;
        case "text":
        case "text/plain":
          fnLiteral += `c.body = await c.request.text()
`;
          break;
        case "urlencoded":
        case "application/x-www-form-urlencoded":
          fnLiteral += `c.body = parseQuery(await c.request.text())
`;
          break;
        case "arrayBuffer":
        case "application/octet-stream":
          fnLiteral += `c.body = await c.request.arrayBuffer()
`;
          break;
        case "formdata":
        case "multipart/form-data":
          if (fnLiteral += `c.body = {}
`, isOptional(validator.body))
            fnLiteral += "let form; try { form = await c.request.formData() } catch {}";
          else
            fnLiteral += "const form = await c.request.formData()";
          fnLiteral += `
if(form)
\t\t\t\t\t\tfor (const key of form.keys()) {
\t\t\t\t\t\t\tif (c.body[key])
\t\t\t\t\t\t\t\tcontinue

\t\t\t\t\t\t\tconst value = form.getAll(key)
\t\t\t\t\t\t\tif (value.length === 1)
\t\t\t\t\t\t\t\tc.body[key] = value[0]
\t\t\t\t\t\t\telse c.body[key] = value
\t\t\t\t\t\t} else form = {}
`;
          break;
      }
    else if (hasBodyInference) {
      if (fnLiteral += `
`, fnLiteral += hasHeaders ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", fnLiteral += `
\t\t\t\tif (contentType) {
\t\t\t\t\tconst index = contentType.indexOf(';')
\t\t\t\t\tif (index !== -1) contentType = contentType.substring(0, index)

\t\t\t\t\tc.contentType = contentType
`, hooks.parse.length) {
        fnLiteral += `let used = false
`;
        let reporter = report("parse", { total: hooks.parse.length });
        for (let i = 0;i < hooks.parse.length; i++) {
          let endUnit = reporter.resolveChild(hooks.parse[i].fn.name), name = `bo${i}`;
          if (i !== 0)
            fnLiteral += `if(!used) {
`;
          if (fnLiteral += `let ${name} = parse[${i}](c, contentType)
`, fnLiteral += `if(${name} instanceof Promise) ${name} = await ${name}
`, fnLiteral += `if(${name} !== undefined) { c.body = ${name}; used = true }
`, endUnit(), i !== 0)
            fnLiteral += "}";
        }
        reporter.resolve();
      }
      if (fnLiteral += `
delete c.contentType
`, hooks.parse.length)
        fnLiteral += "if (!used) {";
      if (hooks.type && !Array.isArray(hooks.type))
        switch (hooks.type) {
          case "json":
          case "application/json":
            if (isOptional(validator.body))
              fnLiteral += "try { c.body = await c.request.json() } catch {}";
            else
              fnLiteral += "c.body = await c.request.json()";
            break;
          case "text":
          case "text/plain":
            fnLiteral += `c.body = await c.request.text()
`;
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            fnLiteral += `c.body = parseQuery(await c.request.text())
`;
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            fnLiteral += `c.body = await c.request.arrayBuffer()
`;
            break;
          case "formdata":
          case "multipart/form-data":
            fnLiteral += `c.body = {}

\t\t\t\t\t\t\tconst form = await c.request.formData()
\t\t\t\t\t\t\tfor (const key of form.keys()) {
\t\t\t\t\t\t\t\tif (c.body[key])
\t\t\t\t\t\t\t\t\tcontinue

\t\t\t\t\t\t\t\tconst value = form.getAll(key)
\t\t\t\t\t\t\t\tif (value.length === 1)
\t\t\t\t\t\t\t\t\tc.body[key] = value[0]
\t\t\t\t\t\t\t\telse c.body[key] = value
\t\t\t\t\t\t\t}
`;
            break;
        }
      else
        fnLiteral += `
\t\t\t\t\tswitch (contentType) {
\t\t\t\t\t\tcase 'application/json':
\t\t\t\t\t\t\t${isOptional(validator.body) ? "try { c.body = await c.request.json() } catch {}" : "c.body = await c.request.json()"}
\t\t\t\t\t\t\tbreak

\t\t\t\t\t\tcase 'text/plain':
\t\t\t\t\t\t\tc.body = await c.request.text()
\t\t\t\t\t\t\tbreak

\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':
\t\t\t\t\t\t\tc.body = parseQuery(await c.request.text())
\t\t\t\t\t\t\tbreak

\t\t\t\t\t\tcase 'application/octet-stream':
\t\t\t\t\t\t\tc.body = await c.request.arrayBuffer();
\t\t\t\t\t\t\tbreak

\t\t\t\t\t\tcase 'multipart/form-data':
\t\t\t\t\t\t\tc.body = {}

\t\t\t\t\t\t\tconst form = await c.request.formData()
\t\t\t\t\t\t\tfor (const key of form.keys()) {
\t\t\t\t\t\t\t\tif (c.body[key])
\t\t\t\t\t\t\t\t\tcontinue

\t\t\t\t\t\t\t\tconst value = form.getAll(key)
\t\t\t\t\t\t\t\tif (value.length === 1)
\t\t\t\t\t\t\t\t\tc.body[key] = value[0]
\t\t\t\t\t\t\t\telse c.body[key] = value
\t\t\t\t\t\t\t}

\t\t\t\t\t\t\tbreak
\t\t\t\t\t}`;
      if (hooks.parse.length)
        fnLiteral += "}";
      fnLiteral += `}
`;
    }
    fnLiteral += `
isParsing = false
`;
  }
  if (parseReporter.resolve(), hooks?.transform) {
    let reporter = report("transform", { total: hooks.transform.length });
    if (hooks.transform.length)
      fnLiteral += `
let transformed
`;
    for (let i = 0;i < hooks.transform.length; i++) {
      let transform4 = hooks.transform[i], endUnit = reporter.resolveChild(transform4.fn.name);
      if (fnLiteral += isAsync(transform4) ? `transformed = await transform[${i}](c)
` : `transformed = transform[${i}](c)
`, transform4.subType === "mapDerive")
        fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)
\t\t\t\t\tthrow transformed
\t\t\t\telse {
\t\t\t\t\ttransformed.request = c.request
\t\t\t\t\ttransformed.store = c.store
\t\t\t\t\ttransformed.qi = c.qi
\t\t\t\t\ttransformed.path = c.path
\t\t\t\t\ttransformed.url = c.url
\t\t\t\t\ttransformed.redirect = c.redirect
\t\t\t\t\ttransformed.set = c.set
\t\t\t\t\ttransformed.error = c.error

\t\t\t\t\tc = transformed
\t\t\t}`;
      else
        fnLiteral += `if(transformed instanceof ElysiaCustomStatusResponse)
\t\t\t\t\tthrow transformed
\t\t\t\telse
\t\t\t\t\tObject.assign(c, transformed)
`;
      endUnit();
    }
    reporter.resolve();
  }
  if (validator) {
    if (fnLiteral += `
`, validator.headers) {
      if (normalize && "Clean" in validator.headers && !hasAdditionalProperties(validator.headers))
        fnLiteral += `c.headers = validator.headers.Clean(c.headers);
`;
      if (hasProperty("default", validator.headers.schema))
        for (let [key, value2] of Object.entries(exports_value2.Default(validator.headers.schema, {}))) {
          let parsed = typeof value2 === "object" ? JSON.stringify(value2) : typeof value2 === "string" ? `'${value2}'` : value2;
          if (parsed !== undefined)
            fnLiteral += `c.headers['${key}'] ??= ${parsed}
`;
        }
      if (isOptional(validator.headers))
        fnLiteral += "if(isNotEmpty(c.headers)) {";
      if (fnLiteral += `if(validator.headers.Check(c.headers) === false) {
\t\t\t\t${composeValidation("headers")}
\t\t\t}`, hasTransform(validator.headers.schema))
        fnLiteral += `c.headers = validator.headers.Decode(c.headers)
`;
      if (isOptional(validator.headers))
        fnLiteral += "}";
    }
    if (validator.params) {
      if (hasProperty("default", validator.params.schema))
        for (let [key, value2] of Object.entries(exports_value2.Default(validator.params.schema, {}))) {
          let parsed = typeof value2 === "object" ? JSON.stringify(value2) : typeof value2 === "string" ? `'${value2}'` : value2;
          if (parsed !== undefined)
            fnLiteral += `c.params['${key}'] ??= ${parsed}
`;
        }
      if (fnLiteral += `if(validator.params.Check(c.params) === false) {
\t\t\t\t${composeValidation("params")}
\t\t\t}`, hasTransform(validator.params.schema))
        fnLiteral += `
c.params = validator.params.Decode(c.params)
`;
    }
    if (validator.query) {
      if (normalize && "Clean" in validator.query && !hasAdditionalProperties(validator.query))
        fnLiteral += `c.query = validator.query.Clean(c.query);
`;
      if (hasProperty("default", validator.query.schema))
        for (let [key, value2] of Object.entries(exports_value2.Default(validator.query.schema, {}))) {
          let parsed = typeof value2 === "object" ? JSON.stringify(value2) : typeof value2 === "string" ? `'${value2}'` : value2;
          if (parsed !== undefined)
            fnLiteral += `if(c.query['${key}'] === undefined) c.query['${key}'] = ${parsed}
`;
        }
      if (isOptional(validator.query))
        fnLiteral += "if(isNotEmpty(c.query)) {";
      if (fnLiteral += `if(validator.query.Check(c.query) === false) {
          \t\t${composeValidation("query")}
\t\t\t}`, hasTransform(validator.query.schema))
        fnLiteral += `
c.query = validator.query.Decode(Object.assign({}, c.query))
`;
      if (isOptional(validator.query))
        fnLiteral += "}";
    }
    if (validator.body) {
      if (normalize && "Clean" in validator.body && !hasAdditionalProperties(validator.body))
        fnLiteral += `c.body = validator.body.Clean(c.body);
`;
      let doesHaveTransform = hasTransform(validator.body.schema);
      if (doesHaveTransform || isOptional(validator.body))
        fnLiteral += `
const isNotEmptyObject = c.body && (typeof c.body === "object" && isNotEmpty(c.body))
`;
      if (hasProperty("default", validator.body.schema)) {
        let value2 = exports_value2.Default(validator.body.schema, validator.body.schema.type === "object" ? {} : undefined), parsed = typeof value2 === "object" ? JSON.stringify(value2) : typeof value2 === "string" ? `'${value2}'` : value2;
        if (fnLiteral += `if(validator.body.Check(c.body) === false) {
\t\t\t\t\tif (typeof c.body === 'object') {
\t\t\t\t\t\tc.body = Object.assign(${parsed}, c.body)
\t\t\t\t\t} else { c.body = ${parsed} }`, isOptional(validator.body))
          fnLiteral += `
\t\t\t\t\t    if(isNotEmptyObject && validator.body.Check(c.body) === false) {
            \t\t\t\t${composeValidation("body")}
             \t\t\t}
                    }`;
        else
          fnLiteral += `
    \t\t\t\tif(validator.body.Check(c.body) === false) {
        \t\t\t\t${composeValidation("body")}
         \t\t\t}
                }`;
      } else if (isOptional(validator.body))
        fnLiteral += `if(isNotEmptyObject && validator.body.Check(c.body) === false) {
         \t\t\t${composeValidation("body")}
          \t\t}`;
      else
        fnLiteral += `if(validator.body.Check(c.body) === false) {
         \t\t\t${composeValidation("body")}
          \t\t}`;
      if (doesHaveTransform)
        fnLiteral += `
if(isNotEmptyObject) c.body = validator.body.Decode(c.body)
`;
    }
    if (isNotEmpty(cookieValidator?.schema?.properties ?? cookieValidator?.schema?.schema ?? {})) {
      if (fnLiteral += `const cookieValue = {}
    \t\t\tfor(const [key, value] of Object.entries(c.cookie))
    \t\t\t\tcookieValue[key] = value.value
`, hasProperty("default", cookieValidator.schema))
        for (let [key, value2] of Object.entries(exports_value2.Default(cookieValidator.schema, {})))
          fnLiteral += `cookieValue['${key}'] = ${typeof value2 === "object" ? JSON.stringify(value2) : value2}
`;
      if (isOptional(validator.cookie))
        fnLiteral += "if(isNotEmpty(c.cookie)) {";
      if (fnLiteral += `if(validator.cookie.Check(cookieValue) === false) {
\t\t\t\t${composeValidation("cookie", "cookieValue")}
\t\t\t}`, hasTransform(validator.cookie.schema))
        fnLiteral += `
for(const [key, value] of Object.entries(validator.cookie.Decode(cookieValue)))
\t\t\t\t\tc.cookie[key].value = value
`;
      if (isOptional(validator.cookie))
        fnLiteral += "}";
    }
  }
  if (hooks?.beforeHandle) {
    let reporter = report("beforeHandle", { total: hooks.beforeHandle.length }), hasResolve = false;
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      let beforeHandle = hooks.beforeHandle[i], endUnit = reporter.resolveChild(beforeHandle.fn.name), returning = hasReturn(beforeHandle);
      if (beforeHandle.subType === "resolve" || beforeHandle.subType === "mapResolve") {
        if (!hasResolve)
          hasResolve = true, fnLiteral += `
let resolved
`;
        if (fnLiteral += isAsync(beforeHandle) ? `resolved = await beforeHandle[${i}](c);
` : `resolved = beforeHandle[${i}](c);
`, beforeHandle.subType === "mapResolve")
          fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)
\t\t\t\t\t\tthrow resolved
\t\t\t\t\telse {
\t\t\t\t\t\tresolved.request = c.request
\t\t\t\t\t\tresolved.store = c.store
\t\t\t\t\t\tresolved.qi = c.qi
\t\t\t\t\t\tresolved.path = c.path
\t\t\t\t\t\tresolved.url = c.url
\t\t\t\t\t\tresolved.redirect = c.redirect
\t\t\t\t\t\tresolved.set = c.set
\t\t\t\t\t\tresolved.error = c.error

\t\t\t\t\t\tc = resolved
\t\t\t\t\t}`;
        else
          fnLiteral += `if(resolved instanceof ElysiaCustomStatusResponse)
\t\t\t\t\t\tthrow resolved
\t\t\t\t\telse
\t\t\t\t\t\tObject.assign(c, resolved)
`;
      } else if (!returning)
        fnLiteral += isAsync(beforeHandle) ? `await beforeHandle[${i}](c);
` : `beforeHandle[${i}](c);
`, endUnit();
      else {
        if (fnLiteral += isAsync(beforeHandle) ? `be = await beforeHandle[${i}](c);
` : `be = beforeHandle[${i}](c);
`, endUnit("be"), fnLiteral += `if(be !== undefined) {
`, reporter.resolve(), hooks.afterHandle?.length) {
          report("handle", { name: isHandleFn ? handler.name : undefined }).resolve();
          let reporter2 = report("afterHandle", { total: hooks.afterHandle.length });
          for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
            let hook = hooks.afterHandle[i2], returning2 = hasReturn(hook), endUnit2 = reporter2.resolveChild(hook.fn.name);
            if (fnLiteral += `c.response = be
`, !returning2)
              fnLiteral += isAsync(hook.fn) ? `await afterHandle[${i2}](c, be)
` : `afterHandle[${i2}](c, be)
`;
            else
              fnLiteral += isAsync(hook.fn) ? `af = await afterHandle[${i2}](c)
` : `af = afterHandle[${i2}](c)
`, fnLiteral += `if(af !== undefined) { c.response = be = af }
`;
            endUnit2("af");
          }
          reporter2.resolve();
        }
        if (validator.response)
          fnLiteral += composeResponseValidation("be");
        let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
        if (hooks.mapResponse.length) {
          fnLiteral += `
c.response = be
`;
          for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
            let mapResponse2 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse2.fn.name);
            fnLiteral += `
if(mr === undefined) {
\t\t\t\t\t\t\tmr = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i2}](c)
\t\t\t\t\t\t\tif(mr !== undefined) be = c.response = mr
\t\t\t\t\t\t}
`, endUnit2();
          }
        }
        mapResponseReporter.resolve(), fnLiteral += encodeCookie, fnLiteral += `return mapEarlyResponse(${saveResponse} be, c.set ${requestMapper})}
`;
      }
    }
    reporter.resolve();
  }
  if (hooks?.afterHandle.length) {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (hooks.afterHandle.length)
      fnLiteral += isAsyncHandler ? `let r = c.response = await ${handle};
` : `let r = c.response = ${handle};
`;
    else
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`;
    handleReporter.resolve();
    let reporter = report("afterHandle", { total: hooks.afterHandle.length });
    for (let i = 0;i < hooks.afterHandle.length; i++) {
      let hook = hooks.afterHandle[i], returning = hasReturn(hook), endUnit = reporter.resolveChild(hook.fn.name);
      if (!returning)
        fnLiteral += isAsync(hook.fn) ? `await afterHandle[${i}](c)
` : `afterHandle[${i}](c)
`, endUnit();
      else if (fnLiteral += isAsync(hook.fn) ? `af = await afterHandle[${i}](c)
` : `af = afterHandle[${i}](c)
`, endUnit("af"), validator.response)
        fnLiteral += "if(af !== undefined) {", reporter.resolve(), fnLiteral += composeResponseValidation("af"), fnLiteral += "c.response = af }";
      else
        fnLiteral += "if(af !== undefined) {", reporter.resolve(), fnLiteral += `c.response = af}
`;
    }
    if (reporter.resolve(), fnLiteral += `r = c.response
`, validator.response)
      fnLiteral += composeResponseValidation();
    fnLiteral += encodeCookie;
    let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
    if (hooks.mapResponse.length)
      for (let i = 0;i < hooks.mapResponse.length; i++) {
        let mapResponse2 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
        fnLiteral += `
mr = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i}](c)
\t\t\t\tif(mr !== undefined) r = c.response = mr
`, endUnit();
      }
    if (mapResponseReporter.resolve(), hasSet)
      fnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})
`;
    else
      fnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})
`;
  } else {
    let handleReporter = report("handle", { name: isHandleFn ? handler.name : undefined });
    if (validator.response || hooks.mapResponse.length) {
      if (fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`, handleReporter.resolve(), validator.response)
        fnLiteral += composeResponseValidation();
      report("afterHandle").resolve();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
      if (hooks.mapResponse.length) {
        fnLiteral += `
c.response = r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse2 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
          fnLiteral += `
if(mr === undefined) {
\t\t\t\t\t\tmr = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i}](c)
    \t\t\t\t\tif(mr !== undefined) r = c.response = mr
\t\t\t\t\t}
`, endUnit();
        }
      }
      if (mapResponseReporter.resolve(), fnLiteral += encodeCookie, handler instanceof Response)
        fnLiteral += inference.set ? `if(
\t\t\t\t\tisNotEmpty(c.set.headers) ||
\t\t\t\t\tc.set.status !== 200 ||
\t\t\t\t\tc.set.redirect ||
\t\t\t\t\tc.set.cookie
\t\t\t\t)
\t\t\t\t\treturn mapResponse(${saveResponse} ${handle}.clone(), c.set ${requestMapper})
\t\t\t\telse
\t\t\t\t\treturn ${handle}.clone()` : `return ${handle}.clone()`, fnLiteral += `
`;
      else if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})
`;
    } else if (hasCookie || hasTrace) {
      fnLiteral += isAsyncHandler ? `let r = await ${handle};
` : `let r = ${handle};
`, handleReporter.resolve(), report("afterHandle").resolve();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
      if (hooks.mapResponse.length) {
        fnLiteral += `
c.response = r
`;
        for (let i = 0;i < hooks.mapResponse.length; i++) {
          let mapResponse2 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
          fnLiteral += `
if(mr === undefined) {
\t\t\t\t\t\t\tmr = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i}](c)
    \t\t\t\t\t\tif(mr !== undefined) r = c.response = mr
\t\t\t\t\t\t}
`, endUnit();
        }
      }
      if (mapResponseReporter.resolve(), fnLiteral += encodeCookie, hasSet)
        fnLiteral += `return mapResponse(${saveResponse} r, c.set ${requestMapper})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse} r ${requestMapper})
`;
    } else {
      handleReporter.resolve();
      let handled = isAsyncHandler ? `await ${handle}` : handle;
      if (report("afterHandle").resolve(), handler instanceof Response)
        fnLiteral += inference.set ? `if(
\t\t\t\t\tisNotEmpty(c.set.headers) ||
\t\t\t\t\tc.set.status !== 200 ||
\t\t\t\t\tc.set.redirect ||
\t\t\t\t\tc.set.cookie
\t\t\t\t)
\t\t\t\t\treturn mapResponse(${saveResponse} ${handle}.clone(), c.set ${requestMapper})
\t\t\t\telse
\t\t\t\t\treturn ${handle}.clone()` : `return ${handle}.clone()`, fnLiteral += `
`;
      else if (hasSet)
        fnLiteral += `return mapResponse(${saveResponse} ${handled}, c.set ${requestMapper})
`;
      else
        fnLiteral += `return mapCompactResponse(${saveResponse} ${handled} ${requestMapper})
`;
    }
  }
  if (fnLiteral += `
} catch(error) {`, hasBody)
    fnLiteral += `
if(isParsing) error = new ParseError()
`;
  if (!maybeAsync)
    fnLiteral += `
return (async () => {
`;
  if (fnLiteral += `
const set = c.set
if (!set.status || set.status < 300) set.status = error?.status || 500
`, hasTrace)
    for (let i = 0;i < hooks.trace.length; i++)
      fnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error);
`;
  let errorReporter = report("error", { total: hooks.error.length });
  if (hooks.error.length) {
    fnLiteral += `
\t\t\t\tc.error = error
\t\t\t\tif(error instanceof TypeBoxError) {
\t\t\t\t\tc.code = "VALIDATION"
\t\t\t\t\tc.set.status = 422
\t\t\t\t} else
\t\t\t\t\tc.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
\t\t\t\tlet er
\t\t\t`;
    for (let i = 0;i < hooks.error.length; i++) {
      let endUnit = errorReporter.resolveChild(hooks.error[i].fn.name);
      if (isAsync(hooks.error[i]))
        fnLiteral += `
er = await handleErrors[${i}](c)
`;
      else
        fnLiteral += `
er = handleErrors[${i}](c)
if (er instanceof Promise) er = await er
`;
      endUnit();
      let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length });
      if (hooks.mapResponse.length)
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse2 = hooks.mapResponse[i2], endUnit2 = mapResponseReporter.resolveChild(mapResponse2.fn.name);
          fnLiteral += `
c.response = er

\t\t\t\t\t\t\ter = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i2}](c)
\t\t\t\t\t\t\tif(er instanceof Promise) er = await er
`, endUnit2();
        }
      if (mapResponseReporter.resolve(), fnLiteral += `er = mapEarlyResponse(er, set ${requestMapper})
`, fnLiteral += "if (er) {", hasTrace) {
        for (let i2 = 0;i2 < hooks.trace.length; i2++)
          fnLiteral += `
report${i2}.resolve()
`;
        errorReporter.resolve();
      }
      fnLiteral += `return er
}
`;
    }
  }
  if (errorReporter.resolve(), fnLiteral += `return handleError(c, error, true)
`, !maybeAsync)
    fnLiteral += "})()";
  if (fnLiteral += "}", hasAfterResponse || hasTrace) {
    if (fnLiteral += " finally { ", !maybeAsync)
      fnLiteral += ";(async () => {";
    let reporter = report("afterResponse", { total: hooks.afterResponse.length });
    if (hasAfterResponse)
      for (let i = 0;i < hooks.afterResponse.length; i++) {
        let endUnit = reporter.resolveChild(hooks.afterResponse[i].fn.name);
        fnLiteral += `
await afterResponse[${i}](c);
`, endUnit();
      }
    if (reporter.resolve(), !maybeAsync)
      fnLiteral += "})();";
    fnLiteral += "}";
  }
  fnLiteral = `const {
\t\thandler,
\t\thandleError,
\t\thooks: {
\t\t\ttransform,
\t\t\tresolve,
\t\t\tbeforeHandle,
\t\t\tafterHandle,
\t\t\tmapResponse: onMapResponse,
\t\t\tparse,
\t\t\terror: handleErrors,
\t\t\tafterResponse,
\t\t\ttrace: _trace
\t\t},
\t\tvalidator,
\t\tutils: {
\t\t\tmapResponse,
\t\t\tmapCompactResponse,
\t\t\tmapEarlyResponse,
\t\t\tparseQuery,
\t\t\tparseQueryFromURL,
\t\t\tisNotEmpty
\t\t},
\t\terror: {
\t\t\tNotFoundError,
\t\t\tValidationError,
\t\t\tInternalServerError,
\t\t\tParseError
\t\t},
\t\tschema,
\t\tdefinitions,
\t\tERROR_CODE,
\t\tparseCookie,
\t\tsignCookie,
\t\tdecodeURIComponent,
\t\tElysiaCustomStatusResponse,
\t\tELYSIA_TRACE,
\t\tELYSIA_REQUEST_ID,
\t\tgetServer,
\t\tTypeBoxError
\t} = hooks

\tconst trace = _trace.map(x => typeof x === 'function' ? x : x.fn)

\treturn ${maybeAsync ? "async" : ""} function handle(c) {
\t\t${hooks.beforeHandle.length ? "let be" : ""}
\t\t${hooks.afterHandle.length ? "let af" : ""}
\t\t${hooks.mapResponse.length ? "let mr" : ""}

\t\t${allowMeta ? "c.schema = schema; c.defs = definitions" : ""}
\t\t${fnLiteral}
\t}`;
  try {
    return Function("hooks", fnLiteral)({ handler, hooks: lifeCycleToFn(hooks), validator, handleError: app.handleError, utils: { mapResponse, mapCompactResponse, mapEarlyResponse, parseQuery, parseQueryFromURL, isNotEmpty }, error: { NotFoundError, ValidationError, InternalServerError, ParseError }, schema: app.router.history, definitions: app.definitions.type, ERROR_CODE, parseCookie, signCookie, decodeURIComponent: import_fast_decode_uri_component3.default, ElysiaCustomStatusResponse, ELYSIA_TRACE, ELYSIA_REQUEST_ID, getServer: () => app.getServer(), TypeBoxError });
  } catch {
    let debugHooks = lifeCycleToFn(hooks);
    console.log("[Composer] failed to generate optimized handler"), console.log("Please report the following to SaltyAom privately as it may include sensitive information about your codebase:"), console.log("---"), console.log({ handler: typeof handler === "function" ? handler.toString() : handler, hooks: { ...debugHooks, transform: debugHooks?.transform?.map?.((x) => x.toString()), resolve: debugHooks?.resolve?.map?.((x) => x.toString()), beforeHandle: debugHooks?.beforeHandle?.map?.((x) => x.toString()), afterHandle: debugHooks?.afterHandle?.map?.((x) => x.toString()), mapResponse: debugHooks?.mapResponse?.map?.((x) => x.toString()), parse: debugHooks?.parse?.map?.((x) => x.toString()), error: debugHooks?.error?.map?.((x) => x.toString()), afterResponse: debugHooks?.afterResponse?.map?.((x) => x.toString()), stop: debugHooks?.stop?.map?.((x) => x.toString()) }, validator, definitions: app.definitions.type }), console.log("---"), process.exit(1);
  }
};
var composeGeneralHandler = (app) => {
  let standardHostname = app.config.handler?.standardHostname ?? true, decoratorsLiteral = "", fnLiteral = "", defaultHeaders = app.setHeaders;
  for (let key of Object.keys(app.singleton.decorator))
    decoratorsLiteral += `,${key}: app.singleton.decorator.${key}`;
  let router = app.router, hasTrace = app.event.trace.length > 0, findDynamicRoute = `
\tconst route = router.find(request.method, path) ${router.http.root.ALL ? '?? router.find("ALL", path)' : ""}

\tif (route === null)
\t\treturn ${app.event.error.length ? "app.handleError(ctx, notFound)" : app.event.request.length ? `new Response(error404Message, {
\t\t\t\t\tstatus: ctx.set.status === 200 ? 404 : ctx.set.status,
\t\t\t\t\theaders: ctx.set.headers
\t\t\t\t})` : "error404.clone()"}

\tctx.params = route.params
`;
  findDynamicRoute += `if(route.store.handler) return route.store.handler(ctx)
\treturn (route.store.handler = route.store.compile())(ctx)
`;
  let switchMap = "";
  for (let [path, { code, all, static: staticFn }] of Object.entries(router.static.http.map)) {
    if (staticFn)
      switchMap += `case '${path}':
switch(request.method) {
${code}
${all ?? "default: break map"}}

`;
    switchMap += `case '${path}':
switch(request.method) {
${code}
${all ?? "default: break map"}}

`;
  }
  let maybeAsync = app.event.request.some(isAsync);
  if (fnLiteral += `const {
\t\tapp,
\t\tmapEarlyResponse,
\t\tNotFoundError,
\t\trandomId,
\t\thandleError,
\t\terror,
\t\tredirect,
\t\tELYSIA_TRACE,
\t\tELYSIA_REQUEST_ID,
\t\tgetServer
\t} = data

\tconst store = app.singleton.store
\tconst staticRouter = app.router.static.http
\tconst st = staticRouter.handlers
\tconst wsRouter = app.router.ws
\tconst router = app.router.http
\tconst trace = app.event.trace.map(x => typeof x === 'function' ? x : x.fn)

\tconst notFound = new NotFoundError()
\tconst hoc = app.extender.higherOrderFunctions.map(x => x.fn)

\t${app.event.request.length ? "const onRequest = app.event.request.map(x => x.fn)" : ""}
\t${app.event.error.length ? "" : `
const error404Message = notFound.message.toString()
\tconst error404 = new Response(error404Message, { status: 404 });
`}

\t${app.event.trace.length ? `const ${app.event.trace.map((_2, i) => `tr${i} = app.event.trace[${i}].fn`).join(",")}` : ""}

\t${maybeAsync ? "async" : ""} function map(request) {
`, app.event.request.length)
    fnLiteral += "let re";
  if (fnLiteral += `
const url = request.url
\t\tconst s = url.indexOf('/', ${standardHostname ? 11 : 7})
\t\tconst qi = url.indexOf('?', s + 1)
\t\tlet path
\t\tif(qi === -1)
\t\t\tpath = url.substring(s)
\t\telse
\t\t\tpath = url.substring(s, qi)
`, fnLiteral += `${hasTrace ? "const id = randomId()" : ""}
\t\tconst ctx = {
\t\t\trequest,
\t\t\tstore,
\t\t\tqi,
\t\t\tpath,
\t\t\turl,
\t\t\tredirect,
\t\t\tset: {
\t\t\t\theaders: ${Object.keys(defaultHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
\t\t\t\tstatus: 200
\t\t\t},
\t\t\terror
\t\t\t${app.inference.server ? `, get server() {
\t\t\t\t\t\t\treturn getServer()
\t\t\t\t\t\t}` : ""}
\t\t\t${hasTrace ? ",[ELYSIA_REQUEST_ID]: id" : ""}
\t\t\t${decoratorsLiteral}
\t\t}
`, app.event.trace.length)
    fnLiteral += `
ctx[ELYSIA_TRACE] = [${app.event.trace.map((_2, i) => `tr${i}(ctx)`).join(",")}]
`;
  let reporter = createReport({ context: "ctx", trace: app.event.trace, addFn(word) {
    fnLiteral += word;
  } })("request", { attribute: "ctx", total: app.event.request.length });
  if (app.event.request.length) {
    fnLiteral += `
 try {
`;
    for (let i = 0;i < app.event.request.length; i++) {
      let hook = app.event.request[i], withReturn = hasReturn(hook), maybeAsync2 = isAsync(hook), endUnit = reporter.resolveChild(app.event.request[i].fn.name);
      if (withReturn)
        fnLiteral += `re = mapEarlyResponse(
\t\t\t\t\t${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx),
\t\t\t\t\tctx.set,
\t\t\t\t\trequest
\t\t\t\t)
`, endUnit("re"), fnLiteral += `if(re !== undefined) return re
`;
      else
        fnLiteral += `${maybeAsync2 ? "await" : ""} onRequest[${i}](ctx)
`, endUnit();
    }
    fnLiteral += `} catch (error) {
\t\t\treturn app.handleError(ctx, error)
\t\t}`;
  }
  reporter.resolve();
  let wsPaths = app.router.static.ws, wsRouter = app.router.ws;
  if (Object.keys(wsPaths).length || wsRouter.history.length) {
    fnLiteral += `
\t\t\tif(request.method === 'GET') {
\t\t\t\tswitch(path) {`;
    for (let [path, index] of Object.entries(wsPaths))
      fnLiteral += `
\t\t\t\t\tcase '${path}':
\t\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket')
\t\t\t\t\t\t\treturn st[${index}](ctx)

\t\t\t\t\t\tbreak`;
    fnLiteral += `
\t\t\t\tdefault:
\t\t\t\t\tif(request.headers.get('upgrade') === 'websocket') {
\t\t\t\t\t\tconst route = wsRouter.find('ws', path)

\t\t\t\t\t\tif(route) {
\t\t\t\t\t\t\tctx.params = route.params

\t\t\t\t\t\t\tif(route.store.handler)
\t\t\t\t\t\t\t    return route.store.handler(ctx)

\t\t\t\t\t\t\treturn (route.store.handler = route.store.compile())(ctx)
\t\t\t\t\t\t}
\t\t\t\t\t}

\t\t\t\t\tbreak
\t\t\t}
\t\t}
`;
  }
  if (fnLiteral += `
\t\tmap: switch(path) {
\t\t\t${switchMap}

\t\t\tdefault:
\t\t\t\tbreak
\t\t}

\t\t${findDynamicRoute}
\t}
`, app.extender.higherOrderFunctions.length) {
    let handler = "map";
    for (let i = 0;i < app.extender.higherOrderFunctions.length; i++)
      handler = `hoc[${i}](${handler}, request)`;
    fnLiteral += `return function hocMap(request) { return ${handler}(request) }`;
  } else
    fnLiteral += "return map";
  let handleError = composeErrorHandler(app);
  return app.handleError = handleError, Function("data", fnLiteral)({ app, mapEarlyResponse, NotFoundError, randomId, handleError, error: error3, redirect, ELYSIA_TRACE, ELYSIA_REQUEST_ID, getServer: () => app.getServer() });
};
var composeErrorHandler = (app) => {
  let hooks = app.event, fnLiteral = "";
  fnLiteral += `const {
\t\tapp: { event: { error: onErrorContainer, afterResponse: resContainer, mapResponse: _onMapResponse, trace: _trace } },
\t\tmapResponse,
\t\tERROR_CODE,
\t\tElysiaCustomStatusResponse,
\t\tELYSIA_TRACE,
\t\tELYSIA_REQUEST_ID
\t} = inject

\tconst trace = _trace.map(x => typeof x === 'function' ? x : x.fn)
\tconst onMapResponse = []

\tfor(let i = 0; i < _onMapResponse.length; i++)
\t\tonMapResponse.push(_onMapResponse[i].fn ?? _onMapResponse[i])

\tdelete _onMapResponse

\tconst onError = onErrorContainer.map(x => x.fn)
\tconst res = resContainer.map(x => x.fn)

\treturn ${app.event.error.find(isAsync) || app.event.mapResponse.find(isAsync) ? "async" : ""} function(context, error, skipGlobal) {`;
  let hasTrace = app.event.trace.length > 0;
  if (hasTrace)
    fnLiteral += `
const id = context[ELYSIA_REQUEST_ID]
`;
  let report = createReport({ context: "context", trace: hooks.trace, addFn: (word) => {
    fnLiteral += word;
  } });
  fnLiteral += `
\t\tconst set = context.set
\t\tlet r

\t\tif(!context.code)
\t\t\tcontext.code = error.code ?? error[ERROR_CODE]

\t\tif(!(context.error instanceof Error))
\t\t\tcontext.error = error

\t\tif(error instanceof ElysiaCustomStatusResponse) {
\t\t\terror.status = error.code
\t\t\terror.message = error.response
\t\t}
`;
  let saveResponse = hasTrace || hooks.afterResponse.length > 0 || hooks.afterResponse.length > 0 ? "context.response = " : "";
  for (let i = 0;i < app.event.error.length; i++) {
    let handler = app.event.error[i], response = `${isAsync(handler) ? "await " : ""}onError[${i}](context)`;
    if (fnLiteral += `
if(skipGlobal !== true) {
`, hasReturn(handler)) {
      fnLiteral += `r = ${response}; if(r !== undefined) {
\t\t\t\tif(r instanceof Response) return r

\t\t\t\tif(r instanceof ElysiaCustomStatusResponse) {
\t\t\t\t\terror.status = error.code
\t\t\t\t\terror.message = error.response
\t\t\t\t}

\t\t\t\tif(set.status === 200) set.status = error.status
`;
      let mapResponseReporter2 = report("mapResponse", { total: hooks.mapResponse.length, name: "context" });
      if (hooks.mapResponse.length)
        for (let i2 = 0;i2 < hooks.mapResponse.length; i2++) {
          let mapResponse2 = hooks.mapResponse[i2], endUnit = mapResponseReporter2.resolveChild(mapResponse2.fn.name);
          fnLiteral += `
context.response = r
\t\t\t\t\t\tr = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i2}](context)
`, endUnit();
        }
      mapResponseReporter2.resolve(), fnLiteral += `return mapResponse(${saveResponse} r, set, context.request)}
`;
    } else
      fnLiteral += response + `
`;
    fnLiteral += `
}
`;
  }
  fnLiteral += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
\t    const reportedError = error.error ?? error
\t\tset.status = reportedError.status ?? 422
\t\treturn new Response(
\t\t\treportedError.message,
\t\t\t{
\t\t\t\theaders: Object.assign(
\t\t\t\t\t{ 'content-type': 'application/json'},
\t\t\t\t\tset.headers
\t\t\t\t),
\t\t\t\tstatus: set.status
\t\t\t}
\t\t)
\t} else {
\t\tif(error.code && typeof error.status === "number")
\t\t\treturn new Response(
\t\t\t\terror.message,
\t\t\t\t{ headers: set.headers, status: error.status }
\t\t\t)
`;
  let mapResponseReporter = report("mapResponse", { total: hooks.mapResponse.length, name: "context" });
  if (hooks.mapResponse.length)
    for (let i = 0;i < hooks.mapResponse.length; i++) {
      let mapResponse2 = hooks.mapResponse[i], endUnit = mapResponseReporter.resolveChild(mapResponse2.fn.name);
      fnLiteral += `
context.response = error
\t\t\terror = ${isAsyncName(mapResponse2) ? "await" : ""} onMapResponse[${i}](context)
`, endUnit();
    }
  return mapResponseReporter.resolve(), fnLiteral += `
return mapResponse(${saveResponse} error, set, context.request)
}
}`, Function("inject", fnLiteral)({ app, mapResponse, ERROR_CODE, ElysiaCustomStatusResponse, ELYSIA_TRACE, ELYSIA_REQUEST_ID });
};
var createDynamicHandler = (app) => async (request) => {
  let url = request.url, s = url.indexOf("/", 11), qi = url.indexOf("?", s + 1), path = qi === -1 ? url.substring(s) : url.substring(s, qi), set22 = { cookie: {}, status: 200, headers: {} }, context = Object.assign({}, app.singleton.decorator, { set: set22, store: app.singleton.store, request, path, qi, redirect });
  try {
    for (let i = 0;i < app.event.request.length; i++) {
      let onRequest = app.event.request[i].fn, response2 = onRequest(context);
      if (response2 instanceof Promise)
        response2 = await response2;
      if (response2 = mapEarlyResponse(response2, set22), response2)
        return context.response = response2;
    }
    let handler = app.router.dynamic.find(request.method, path) ?? app.router.dynamic.find("ALL", path);
    if (!handler)
      throw new NotFoundError;
    let { handle, hooks, validator, content } = handler.store, body;
    if (request.method !== "GET" && request.method !== "HEAD")
      if (content)
        switch (content) {
          case "application/json":
            body = await request.json();
            break;
          case "text/plain":
            body = await request.text();
            break;
          case "application/x-www-form-urlencoded":
            body = parseQuery(await request.text());
            break;
          case "application/octet-stream":
            body = await request.arrayBuffer();
            break;
          case "multipart/form-data":
            body = {};
            let form2 = await request.formData();
            for (let key of form2.keys()) {
              if (body[key])
                continue;
              let value2 = form2.getAll(key);
              if (value2.length === 1)
                body[key] = value2[0];
              else
                body[key] = value2;
            }
            break;
        }
      else {
        let contentType = request.headers.get("content-type");
        if (contentType) {
          let index = contentType.indexOf(";");
          if (index !== -1)
            contentType = contentType.slice(0, index);
          context.contentType = contentType;
          for (let i = 0;i < hooks.parse.length; i++) {
            let hook = hooks.parse[i].fn, temp = hook(context, contentType);
            if (temp instanceof Promise)
              temp = await temp;
            if (temp) {
              body = temp;
              break;
            }
          }
          if (delete context.contentType, body === undefined)
            switch (contentType) {
              case "application/json":
                body = await request.json();
                break;
              case "text/plain":
                body = await request.text();
                break;
              case "application/x-www-form-urlencoded":
                body = parseQuery(await request.text());
                break;
              case "application/octet-stream":
                body = await request.arrayBuffer();
                break;
              case "multipart/form-data":
                body = {};
                let form2 = await request.formData();
                for (let key of form2.keys()) {
                  if (body[key])
                    continue;
                  let value2 = form2.getAll(key);
                  if (value2.length === 1)
                    body[key] = value2[0];
                  else
                    body[key] = value2;
                }
                break;
            }
        }
      }
    context.body = body, context.params = handler?.params || undefined, context.query = qi === -1 ? {} : parseQueryFromURL(url.substring(qi + 1)), context.headers = {};
    for (let [key, value2] of request.headers.entries())
      context.headers[key] = value2;
    let cookieMeta = Object.assign({}, app.config?.cookie, validator?.cookie?.config), cookieHeaderValue = request.headers.get("cookie");
    context.cookie = await parseCookie(context.set, cookieHeaderValue, cookieMeta ? { secrets: cookieMeta.secrets !== undefined ? typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets.join(",") : undefined, sign: cookieMeta.sign === true ? true : cookieMeta.sign !== undefined ? typeof cookieMeta.sign === "string" ? cookieMeta.sign : cookieMeta.sign.join(",") : undefined } : undefined);
    for (let i = 0;i < hooks.transform.length; i++) {
      let hook = hooks.transform[i], operation = hook.fn(context);
      if (hook.subType === "derive")
        if (operation instanceof Promise)
          Object.assign(context, await operation);
        else
          Object.assign(context, operation);
      else if (operation instanceof Promise)
        await operation;
    }
    if (validator) {
      if (validator.createHeaders?.()) {
        let _header = {};
        for (let key in request.headers)
          _header[key] = request.headers.get(key);
        if (validator.headers.Check(_header) === false)
          throw new ValidationError("header", validator.headers, _header);
      } else if (validator.headers?.Decode)
        context.headers = validator.headers.Decode(context.headers);
      if (validator.createParams?.()?.Check(context.params) === false)
        throw new ValidationError("params", validator.params, context.params);
      else if (validator.params?.Decode)
        context.params = validator.params.Decode(context.params);
      if (validator.createQuery?.()?.Check(context.query) === false)
        throw new ValidationError("query", validator.query, context.query);
      else if (validator.query?.Decode)
        context.query = validator.query.Decode(context.query);
      if (validator.createCookie?.()) {
        let cookieValue = {};
        for (let [key, value2] of Object.entries(context.cookie))
          cookieValue[key] = value2.value;
        if (validator.cookie.Check(cookieValue) === false)
          throw new ValidationError("cookie", validator.cookie, cookieValue);
        else if (validator.cookie?.Decode)
          cookieValue = validator.cookie.Decode(cookieValue);
      }
      if (validator.createBody?.()?.Check(body) === false)
        throw new ValidationError("body", validator.body, body);
      else if (validator.body?.Decode)
        context.body = validator.body.Decode(body);
    }
    for (let i = 0;i < hooks.beforeHandle.length; i++) {
      let hook = hooks.beforeHandle[i], response2 = hook.fn(context);
      if (hook.subType === "resolve") {
        if (response2 instanceof ElysiaCustomStatusResponse) {
          let result = mapEarlyResponse(response2, context.set);
          if (result)
            return context.response = result;
        }
        if (response2 instanceof Promise)
          Object.assign(context, await response2);
        else
          Object.assign(context, response2);
        continue;
      } else if (response2 instanceof Promise)
        response2 = await response2;
      if (response2 !== undefined) {
        context.response = response2;
        for (let i2 = 0;i2 < hooks.afterHandle.length; i2++) {
          let newResponse = hooks.afterHandle[i2].fn(context);
          if (newResponse instanceof Promise)
            newResponse = await newResponse;
          if (newResponse)
            response2 = newResponse;
        }
        let result = mapEarlyResponse(response2, context.set);
        if (result)
          return context.response = result;
      }
    }
    let response = handle(context);
    if (response instanceof Promise)
      response = await response;
    if (!hooks.afterHandle.length) {
      let status = response instanceof ElysiaCustomStatusResponse ? response.code : set22.status ? typeof set22.status === "string" ? StatusMap[set22.status] : set22.status : 200, responseValidator = validator?.createResponse?.()?.[status];
      if (responseValidator?.Check(response) === false)
        throw new ValidationError("response", responseValidator, response);
      else if (responseValidator?.Decode)
        response = responseValidator.Decode(response);
    } else {
      context.response = response;
      for (let i = 0;i < hooks.afterHandle.length; i++) {
        let newResponse = hooks.afterHandle[i].fn(context);
        if (newResponse instanceof Promise)
          newResponse = await newResponse;
        let result = mapEarlyResponse(newResponse, context.set);
        if (result !== undefined) {
          let responseValidator = validator?.response?.[result.status];
          if (responseValidator?.Check(result) === false)
            throw new ValidationError("response", responseValidator, result);
          else if (responseValidator?.Decode)
            response = responseValidator.Decode(response);
          return context.response = result;
        }
      }
    }
    if (context.set.cookie && cookieMeta?.sign) {
      let secret = !cookieMeta.secrets ? undefined : typeof cookieMeta.secrets === "string" ? cookieMeta.secrets : cookieMeta.secrets[0];
      if (cookieMeta.sign === true)
        for (let [key, cookie] of Object.entries(context.set.cookie))
          context.set.cookie[key].value = await signCookie(cookie.value, "${secret}");
      else {
        let properties = validator?.cookie?.schema?.properties;
        for (let name of cookieMeta.sign) {
          if (!(name in properties))
            continue;
          if (context.set.cookie[name]?.value)
            context.set.cookie[name].value = await signCookie(context.set.cookie[name].value, secret);
        }
      }
    }
    return context.response = mapResponse(response, context.set);
  } catch (error22) {
    let reportedError = error22 instanceof TransformDecodeError && error22.error ? error22.error : error22;
    if (reportedError.status)
      set22.status = reportedError.status;
    return app.handleError(context, reportedError);
  } finally {
    for (let afterResponse of app.event.afterResponse)
      await afterResponse.fn(context);
  }
};
var createDynamicErrorHandler = (app) => async (context, error22) => {
  let errorContext = Object.assign(context, { error: error22, code: error22.code });
  errorContext.set = context.set;
  for (let i = 0;i < app.event.error.length; i++) {
    let response = app.event.error[i].fn(errorContext);
    if (response instanceof Promise)
      response = await response;
    if (response !== undefined && response !== null)
      return context.response = mapResponse(response, context.set);
  }
  return new Response(typeof error22.cause === "string" ? error22.cause : error22.message, { headers: context.set.headers, status: error22.status ?? 500 });
};

class Elysia {
  config;
  server = null;
  dependencies = {};
  _routes = {};
  _types = { Prefix: "", Scoped: false, Singleton: {}, Definitions: {}, Metadata: {} };
  _ephemeral = {};
  _volatile = {};
  static version = version;
  version = version;
  singleton = { decorator: {}, store: {}, derive: {}, resolve: {} };
  get store() {
    return this.singleton.store;
  }
  get decorator() {
    return this.singleton.decorator;
  }
  get _scoped() {
    return this.config.scoped;
  }
  definitions = { type: {}, error: {} };
  extender = { macros: [], higherOrderFunctions: [] };
  validator = { global: null, scoped: null, local: null, getCandidate() {
    return mergeSchemaValidator(mergeSchemaValidator(this.global, this.scoped), this.local);
  } };
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], afterResponse: [], trace: [], error: [], stop: [] };
  telemetry = { stack: undefined };
  router = { http: new Y, ws: new Y, dynamic: new Y, static: { http: { static: {}, handlers: [], map: {}, all: "" }, ws: {} }, history: [] };
  routeTree = new Map;
  get routes() {
    return this.router.history;
  }
  getGlobalRoutes() {
    return this.router.history;
  }
  inference = { body: false, cookie: false, headers: false, query: false, set: false, server: false };
  getServer() {
    return this.server;
  }
  _promisedModules;
  get promisedModules() {
    if (!this._promisedModules)
      this._promisedModules = new PromiseGroup;
    return this._promisedModules;
  }
  constructor(config = {}) {
    if (config.tags)
      if (!config.detail)
        config.detail = { tags: config.tags };
      else
        config.detail.tags = config.tags;
    if (config.nativeStaticResponse === undefined)
      config.nativeStaticResponse = true;
    if (this.config = {}, this.applyConfig(config ?? {}), config?.analytic && (config?.name || config?.seed !== undefined))
      this.telemetry.stack = new Error().stack;
  }
  env(model, env2 = Bun?.env ?? process.env) {
    if (getSchemaValidator(model, { dynamic: true, additionalProperties: true, coerce: true }).Check(env2) === false) {
      let error22 = new ValidationError("env", model, env2);
      throw new Error(error22.all.map((x) => x.summary).join(`
`));
    }
    return this;
  }
  wrap(fn) {
    return this.extender.higherOrderFunctions.push({ checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: fn.toString() })), fn }), this;
  }
  applyMacro(localHook) {
    if (this.extender.macros.length) {
      let manage = createMacroManager({ globalHook: this.event, localHook }), manager = { events: { global: this.event, local: localHook }, onParse: manage("parse"), onTransform: manage("transform"), onBeforeHandle: manage("beforeHandle"), onAfterHandle: manage("afterHandle"), mapResponse: manage("mapResponse"), onAfterResponse: manage("afterResponse"), onError: manage("error") };
      for (let macro of this.extender.macros)
        traceBackMacro(macro.fn(manager), localHook);
    }
  }
  applyConfig(config) {
    return this.config = { prefix: "", aot: true, strictPath: false, global: false, analytic: false, normalize: true, ...config, cookie: { path: "/", ...config?.cookie }, experimental: config?.experimental ?? {}, seed: config?.seed === undefined ? "" : config?.seed }, this;
  }
  get models() {
    let models = {};
    for (let [name, schema3] of Object.entries(this.definitions.type))
      models[name] = getSchemaValidator(schema3);
    return models;
  }
  add(method, path, handle, localHook, { allowMeta = false, skipPrefix = false } = { allowMeta: false, skipPrefix: false }) {
    if (localHook = localHookToLifeCycleStore(localHook), path !== "" && path.charCodeAt(0) !== 47)
      path = "/" + path;
    if (this.config.prefix && !skipPrefix && !this.config.scoped)
      path = this.config.prefix + path;
    if (localHook?.type)
      switch (localHook.type) {
        case "text":
          localHook.type = "text/plain";
          break;
        case "json":
          localHook.type = "application/json";
          break;
        case "formdata":
          localHook.type = "multipart/form-data";
          break;
        case "urlencoded":
          localHook.type = "application/x-www-form-urlencoded";
          break;
        case "arrayBuffer":
          localHook.type = "application/octet-stream";
          break;
        default:
          break;
      }
    let models = this.definitions.type, dynamic = !this.config.aot, instanceValidator = { ...this.validator.getCandidate() }, cloned = { body: localHook?.body ?? instanceValidator?.body, headers: localHook?.headers ?? instanceValidator?.headers, params: localHook?.params ?? instanceValidator?.params, query: localHook?.query ?? instanceValidator?.query, cookie: localHook?.cookie ?? instanceValidator?.cookie, response: localHook?.response ?? instanceValidator?.response }, cookieValidator = () => cloned.cookie ? getCookieValidator({ validator: cloned.cookie, defaultConfig: this.config.cookie, config: cloned.cookie?.config ?? {}, dynamic, models }) : undefined, normalize = this.config.normalize, validator = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.schema === true ? { body: getSchemaValidator(cloned.body, { dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot() }), headers: getSchemaValidator(cloned.headers, { dynamic, models, additionalProperties: !this.config.normalize, coerce: true, additionalCoerce: stringToStructureCoercions() }), params: getSchemaValidator(cloned.params, { dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions() }), query: getSchemaValidator(cloned.query, { dynamic, models, normalize, coerce: true, additionalCoerce: stringToStructureCoercions() }), cookie: cookieValidator(), response: getResponseSchemaValidator(cloned.response, { dynamic, models, normalize }) } : { createBody() {
      if (this.body)
        return this.body;
      return this.body = getSchemaValidator(cloned.body, { dynamic, models, normalize, additionalCoerce: coercePrimitiveRoot() });
    }, createHeaders() {
      if (this.headers)
        return this.headers;
      return this.headers = getSchemaValidator(cloned.headers, { dynamic, models, additionalProperties: !normalize, coerce: true, additionalCoerce: stringToStructureCoercions() });
    }, createParams() {
      if (this.params)
        return this.params;
      return this.params = getSchemaValidator(cloned.params, { dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions() });
    }, createQuery() {
      if (this.query)
        return this.query;
      return this.query = getSchemaValidator(cloned.query, { dynamic, models, coerce: true, additionalCoerce: stringToStructureCoercions() });
    }, createCookie() {
      if (this.cookie)
        return this.cookie;
      return this.cookie = cookieValidator();
    }, createResponse() {
      if (this.response)
        return this.response;
      return this.response = getResponseSchemaValidator(cloned.response, { dynamic, models, normalize });
    } }, loosePath = path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
    if (localHook = mergeHook(localHook, instanceValidator), localHook.tags)
      if (!localHook.detail)
        localHook.detail = { tags: localHook.tags };
      else
        localHook.detail.tags = localHook.tags;
    if (isNotEmpty(this.config.detail))
      localHook.detail = mergeDeep(Object.assign({}, this.config.detail), localHook.detail);
    this.applyMacro(localHook);
    let hooks = mergeHook(this.event, localHook);
    if (this.config.aot === false) {
      if (this.router.dynamic.add(method, path, { validator, hooks, content: localHook?.type, handle }), this.config.strictPath === false)
        this.router.dynamic.add(method, loosePath, { validator, hooks, content: localHook?.type, handle });
      this.router.history.push({ method, path, composed: null, handler: handle, hooks });
      return;
    }
    let shouldPrecompile = this.config.precompile === true || typeof this.config.precompile === "object" && this.config.precompile.compose === true, inference = cloneInference(this.inference), staticHandler = typeof handle !== "function" ? createStaticHandler(handle, hooks, this.setHeaders) : undefined, nativeStaticHandler = typeof handle !== "function" ? createNativeStaticHandler(handle, hooks, this.setHeaders) : undefined;
    if (this.config.nativeStaticResponse === true && nativeStaticHandler && (method === "GET" || method === "ALL"))
      this.router.static.http.static[path] = nativeStaticHandler();
    let compile = () => composeHandler({ app: this, path, method, localHook: mergeHook(localHook), hooks, validator, handler: handle, allowMeta, inference }), mainHandler = shouldPrecompile ? compile() : (context) => {
      return compile()(context);
    }, routeIndex = this.router.history.length;
    if (this.routeTree.has(method + path))
      for (let i = 0;i < this.router.history.length; i++) {
        let route = this.router.history[i];
        if (route.path === path && route.method === method) {
          let removed = this.router.history.splice(i, 1)[0];
          if (removed && this.routeTree.has(removed?.method + removed?.path))
            this.routeTree.delete(removed.method + removed.path);
        }
      }
    else
      this.routeTree.set(method + path, routeIndex);
    this.router.history.push({ method, path, composed: mainHandler, handler: handle, hooks });
    let staticRouter = this.router.static.http, handler = { handler: shouldPrecompile ? mainHandler : undefined, compile };
    if (method === "$INTERNALWS") {
      let loose = this.config.strictPath ? undefined : path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
      if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
        let index = staticRouter.handlers.length;
        if (staticRouter.handlers.push((ctx) => (staticRouter.handlers[index] = compile())(ctx)), this.router.static.ws[path] = index, loose)
          this.router.static.ws[loose] = index;
      } else if (this.router.ws.add("ws", path, handler), loose)
        this.router.ws.add("ws", loose, handler);
      return;
    }
    if (path.indexOf(":") === -1 && path.indexOf("*") === -1) {
      let index = staticRouter.handlers.length;
      if (staticRouter.handlers.push(staticHandler ?? ((ctx2) => (staticRouter.handlers[index] = compile())(ctx2))), !staticRouter.map[path])
        staticRouter.map[path] = { code: "" };
      let ctx = staticHandler ? "" : "ctx";
      if (method === "ALL")
        staticRouter.map[path].all = `default: return st[${index}](${ctx})
`;
      else
        staticRouter.map[path].code = `case '${method}': return st[${index}](${ctx})
${staticRouter.map[path].code}`;
      if (!this.config.strictPath) {
        if (!staticRouter.map[loosePath])
          staticRouter.map[loosePath] = { code: "" };
        if (this.config.nativeStaticResponse === true && nativeStaticHandler && (method === "GET" || method === "ALL"))
          this.router.static.http.static[loosePath] = nativeStaticHandler();
        if (method === "ALL")
          staticRouter.map[loosePath].all = `default: return st[${index}](${ctx})
`;
        else
          staticRouter.map[loosePath].code = `case '${method}': return st[${index}](${ctx})
${staticRouter.map[loosePath].code}`;
      }
    } else if (this.router.http.add(method, path, handler), !this.config.strictPath) {
      let loosePath2 = path.endsWith("/") ? path.slice(0, path.length - 1) : path + "/";
      if (this.config.nativeStaticResponse === true && staticHandler && (method === "GET" || method === "ALL"))
        this.router.static.http.static[loosePath2] = staticHandler();
      this.router.http.add(method, loosePath2, handler);
    }
  }
  setHeaders;
  headers(header) {
    if (!header)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = mergeDeep(this.setHeaders, header), this;
  }
  onStart(handler) {
    return this.on("start", handler), this;
  }
  onRequest(handler) {
    return this.on("request", handler), this;
  }
  onParse(options, handler) {
    if (!handler)
      return this.on("parse", options);
    return this.on(options, "parse", handler);
  }
  onTransform(options, handler) {
    if (!handler)
      return this.on("transform", options);
    return this.on(options, "transform", handler);
  }
  resolve(optionsOrResolve, resolve) {
    if (!resolve)
      resolve = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "resolve", fn: resolve };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  mapResolve(optionsOrResolve, mapper) {
    if (!mapper)
      mapper = optionsOrResolve, optionsOrResolve = { as: "local" };
    let hook = { subType: "mapResolve", fn: mapper };
    return this.onBeforeHandle(optionsOrResolve, hook);
  }
  onBeforeHandle(options, handler) {
    if (!handler)
      return this.on("beforeHandle", options);
    return this.on(options, "beforeHandle", handler);
  }
  onAfterHandle(options, handler) {
    if (!handler)
      return this.on("afterHandle", options);
    return this.on(options, "afterHandle", handler);
  }
  mapResponse(options, handler) {
    if (!handler)
      return this.on("mapResponse", options);
    return this.on(options, "mapResponse", handler);
  }
  onAfterResponse(options, handler) {
    if (!handler)
      return this.on("afterResponse", options);
    return this.on(options, "afterResponse", handler);
  }
  trace(options, handler) {
    if (!handler)
      handler = options, options = { as: "local" };
    if (!Array.isArray(handler))
      handler = [handler];
    for (let fn of handler)
      this.on(options, "trace", createTracer(fn));
    return this;
  }
  error(name, error22) {
    switch (typeof name) {
      case "string":
        return error22.prototype[ERROR_CODE] = name, this.definitions.error[name] = error22, this;
      case "function":
        return this.definitions.error = name(this.definitions.error), this;
    }
    for (let [code, error32] of Object.entries(name))
      error32.prototype[ERROR_CODE] = code, this.definitions.error[code] = error32;
    return this;
  }
  onError(options, handler) {
    if (!handler)
      return this.on("error", options);
    return this.on(options, "error", handler);
  }
  onStop(handler) {
    return this.on("stop", handler), this;
  }
  on(optionsOrType, typeOrHandlers, handlers) {
    let type3;
    switch (typeof optionsOrType) {
      case "string":
        type3 = optionsOrType, handlers = typeOrHandlers;
        break;
      case "object":
        if (type3 = typeOrHandlers, !Array.isArray(typeOrHandlers) && typeof typeOrHandlers === "object")
          handlers = typeOrHandlers;
        break;
    }
    if (Array.isArray(handlers))
      handlers = fnToContainer(handlers);
    else if (typeof handlers === "function")
      handlers = [{ fn: handlers }];
    else
      handlers = [handlers];
    let handles = handlers;
    for (let handle of handles)
      handle.scope = typeof optionsOrType === "string" ? "local" : optionsOrType?.as ?? "local";
    if (type3 !== "trace")
      sucrose({ [type3]: handles.map((x) => x.fn) }, this.inference);
    for (let handle of handles) {
      let fn = asHookType(handle, "global", { skipIfHasType: true });
      switch (type3) {
        case "start":
          this.event.start.push(fn);
          break;
        case "request":
          this.event.request.push(fn);
          break;
        case "parse":
          this.event.parse.push(fn);
          break;
        case "transform":
          this.event.transform.push(fn);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(fn);
          break;
        case "afterHandle":
          this.event.afterHandle.push(fn);
          break;
        case "mapResponse":
          this.event.mapResponse.push(fn);
          break;
        case "afterResponse":
          this.event.afterResponse.push(fn);
          break;
        case "trace":
          this.event.trace.push(fn);
          break;
        case "error":
          this.event.error.push(fn);
          break;
        case "stop":
          this.event.stop.push(fn);
          break;
      }
    }
    return this;
  }
  propagate() {
    return promoteEvent(this.event.parse), promoteEvent(this.event.transform), promoteEvent(this.event.beforeHandle), promoteEvent(this.event.afterHandle), promoteEvent(this.event.mapResponse), promoteEvent(this.event.afterResponse), promoteEvent(this.event.trace), promoteEvent(this.event.error), this;
  }
  as(type3) {
    let castType = { plugin: "scoped", global: "global" }[type3];
    if (promoteEvent(this.event.parse, castType), promoteEvent(this.event.transform, castType), promoteEvent(this.event.beforeHandle, castType), promoteEvent(this.event.afterHandle, castType), promoteEvent(this.event.mapResponse, castType), promoteEvent(this.event.afterResponse, castType), promoteEvent(this.event.trace, castType), promoteEvent(this.event.error, castType), type3 === "plugin")
      this.validator.scoped = mergeSchemaValidator(this.validator.scoped, this.validator.local), this.validator.local = null;
    else if (type3 === "global")
      this.validator.global = mergeSchemaValidator(this.validator.global, mergeSchemaValidator(this.validator.scoped, this.validator.local)), this.validator.scoped = null, this.validator.local = null;
    return this;
  }
  group(prefix, schemaOrRun, run) {
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.getServer = () => this.getServer(), instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender };
    let isSchema = typeof schemaOrRun === "object", sandbox = (isSchema ? run : schemaOrRun)(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.event.request.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks }) => {
      if (path = (isSchema ? "" : this.config.prefix) + prefix + path, isSchema) {
        let hook = schemaOrRun, localHook = hooks;
        this.add(method, path, handler, mergeHook(hook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error || {}, ...sandbox.event.error || {}] : [localHook.error, ...sandbox.event.error || {}] }));
      } else
        this.add(method, path, handler, mergeHook(hooks, { error: sandbox.event.error }), { skipPrefix: true });
    }), this;
  }
  guard(hook, run) {
    if (!run) {
      if (typeof hook === "object") {
        this.applyMacro(hook);
        let type3 = hook.as ?? "local";
        if (this.validator[type3] = { body: hook.body ?? this.validator[type3]?.body, headers: hook.headers ?? this.validator[type3]?.headers, params: hook.params ?? this.validator[type3]?.params, query: hook.query ?? this.validator[type3]?.query, response: hook.response ?? this.validator[type3]?.response, cookie: hook.cookie ?? this.validator[type3]?.cookie }, hook.parse)
          this.on({ as: type3 }, "parse", hook.parse);
        if (hook.transform)
          this.on({ as: type3 }, "transform", hook.transform);
        if (hook.beforeHandle)
          this.on({ as: type3 }, "beforeHandle", hook.beforeHandle);
        if (hook.afterHandle)
          this.on({ as: type3 }, "afterHandle", hook.afterHandle);
        if (hook.mapResponse)
          this.on({ as: type3 }, "mapResponse", hook.mapResponse);
        if (hook.afterResponse)
          this.on({ as: type3 }, "afterResponse", hook.afterResponse);
        if (hook.error)
          this.on({ as: type3 }, "error", hook.error);
        if (hook.detail)
          if (this.config.detail)
            this.config.detail = mergeDeep(Object.assign({}, this.config.detail), hook.detail);
          else
            this.config.detail = hook.detail;
        if (hook?.tags)
          if (!this.config.detail)
            this.config.detail = { tags: hook.tags };
          else
            this.config.detail.tags = hook.tags;
        return this;
      }
      return this.guard({}, hook);
    }
    let instance = new Elysia({ ...this.config, prefix: "" });
    instance.singleton = { ...this.singleton }, instance.definitions = { ...this.definitions }, instance.inference = cloneInference(this.inference), instance.extender = { ...this.extender };
    let sandbox = run(instance);
    if (this.singleton = mergeDeep(this.singleton, instance.singleton), this.definitions = mergeDeep(this.definitions, instance.definitions), sandbox.getServer = () => this.server, sandbox.event.request.length)
      this.event.request = [...this.event.request || [], ...sandbox.event.request || []];
    if (sandbox.event.mapResponse.length)
      this.event.mapResponse = [...this.event.mapResponse || [], ...sandbox.event.mapResponse || []];
    return this.model(sandbox.definitions.type), Object.values(instance.router.history).forEach(({ method, path, handler, hooks: localHook }) => {
      this.add(method, path, handler, mergeHook(hook, { ...localHook || {}, error: !localHook.error ? sandbox.event.error : Array.isArray(localHook.error) ? [...localHook.error || {}, ...sandbox.event.error || []] : [localHook.error, ...sandbox.event.error || []] }));
    }), this;
  }
  use(plugin, options) {
    if (options?.scoped)
      return this.guard({}, (app) => app.use(plugin));
    if (Array.isArray(plugin)) {
      let current = this;
      for (let p of plugin)
        current = this.use(p);
      return current;
    }
    if (plugin instanceof Promise)
      return this.promisedModules.add(plugin.then((plugin2) => {
        if (typeof plugin2 === "function")
          return plugin2(this);
        if (plugin2 instanceof Elysia)
          return this._use(plugin2).compile();
        if (typeof plugin2.default === "function")
          return plugin2.default(this);
        if (plugin2.default instanceof Elysia)
          return this._use(plugin2.default);
        throw new Error('Invalid plugin type. Expected Elysia instance, function, or module with "default" as Elysia instance or function that returns Elysia instance.');
      }).then((x) => x.compile())), this;
    return this._use(plugin);
  }
  _use(plugin) {
    if (typeof plugin === "function") {
      let instance = plugin(this);
      if (instance instanceof Promise)
        return this.promisedModules.add(instance.then((plugin2) => {
          if (plugin2 instanceof Elysia) {
            plugin2.getServer = () => this.getServer(), plugin2.getGlobalRoutes = () => this.getGlobalRoutes(), plugin2.model(this.definitions.type), plugin2.error(this.definitions.error);
            for (let { method, path, handler, hooks } of Object.values(plugin2.router.history))
              this.add(method, path, handler, mergeHook(hooks, { error: plugin2.event.error }));
            return plugin2.compile(), plugin2;
          }
          if (typeof plugin2 === "function")
            return plugin2(this);
          if (typeof plugin2.default === "function")
            return plugin2.default(this);
          return this._use(plugin2);
        }).then((x) => x.compile())), this;
      return instance;
    }
    let { name, seed } = plugin.config;
    plugin.getServer = () => this.getServer(), plugin.getGlobalRoutes = () => this.getGlobalRoutes(), plugin.model(this.definitions.type), plugin.error(this.definitions.error);
    let isScoped = plugin.config.scoped;
    if (isScoped) {
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          return this;
        this.dependencies[name].push(!this.config?.analytic ? { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies } : { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies, stack: plugin.telemetry.stack, routes: plugin.router.history, decorators: plugin.singleton.decorator, store: plugin.singleton.store, type: plugin.definitions.type, error: plugin.definitions.error, derive: plugin.event.transform.filter((x) => x.subType === "derive").map((x) => ({ fn: x.fn.toString(), stack: new Error().stack ?? "" })), resolve: plugin.event.transform.filter((x) => x.subType === "derive").map((x) => ({ fn: x.fn.toString(), stack: new Error().stack ?? "" })) });
      }
      plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros);
      let macroHashes = [];
      for (let i = 0;i < plugin.extender.macros.length; i++) {
        let macro = this.extender.macros[i];
        if (macroHashes.includes(macro.checksum))
          plugin.extender.macros.splice(i, 1), i--;
        macroHashes.push(macro.checksum);
      }
      if (plugin.onRequest((context) => {
        Object.assign(context, this.singleton.decorator), Object.assign(context.store, this.singleton.store);
      }), plugin.event.trace.length)
        plugin.event.trace.push(...plugin.event.trace);
      if (!plugin.config.prefix)
        console.warn("It's recommended to use scoped instance with a prefix to prevent collision routing with other instance.");
      if (plugin.event.error.length)
        plugin.event.error.push(...this.event.error);
      if (plugin.config.aot)
        plugin.compile();
      if (isScoped === true && plugin.config.prefix) {
        this.mount(plugin.config.prefix + "/", plugin.fetch);
        for (let route of plugin.router.history)
          this.routeTree.set(route.method + `${plugin.config.prefix}${route.path}`, this.router.history.length), this.router.history.push({ ...route, path: `${plugin.config.prefix}${route.path}`, hooks: mergeHook(route.hooks, { error: this.event.error }) });
      } else {
        this.mount(plugin.fetch);
        for (let route of plugin.router.history)
          this.routeTree.set(route.method + `${plugin.config.prefix}${route.path}`, this.router.history.length), this.router.history.push({ ...route, path: `${plugin.config.prefix}${route.path}`, hooks: mergeHook(route.hooks, { error: this.event.error }) });
      }
      return this;
    } else {
      if (this.headers(plugin.setHeaders), name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (!this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          this.extender.macros = this.extender.macros.concat(plugin.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
      } else
        this.extender.macros = this.extender.macros.concat(plugin.extender.macros), this.extender.higherOrderFunctions = this.extender.higherOrderFunctions.concat(plugin.extender.higherOrderFunctions);
      deduplicateChecksum(this.extender.macros), deduplicateChecksum(this.extender.higherOrderFunctions);
      let hofHashes = [];
      for (let i = 0;i < this.extender.higherOrderFunctions.length; i++) {
        let hof = this.extender.higherOrderFunctions[i];
        if (hof.checksum) {
          if (hofHashes.includes(hof.checksum))
            this.extender.higherOrderFunctions.splice(i, 1), i--;
          hofHashes.push(hof.checksum);
        }
      }
      this.inference = { body: this.inference.body || plugin.inference.body, cookie: this.inference.cookie || plugin.inference.cookie, headers: this.inference.headers || plugin.inference.headers, query: this.inference.query || plugin.inference.query, set: this.inference.set || plugin.inference.set, server: this.inference.server || plugin.inference.server };
    }
    this.decorate(plugin.singleton.decorator), this.state(plugin.singleton.store), this.model(plugin.definitions.type), this.error(plugin.definitions.error), plugin.extender.macros = this.extender.macros.concat(plugin.extender.macros);
    for (let { method, path, handler, hooks } of Object.values(plugin.router.history))
      this.add(method, path, handler, mergeHook(hooks, { error: plugin.event.error }));
    if (!isScoped)
      if (name) {
        if (!(name in this.dependencies))
          this.dependencies[name] = [];
        let current = seed !== undefined ? checksum(name + JSON.stringify(seed)) : 0;
        if (this.dependencies[name].some(({ checksum: checksum2 }) => current === checksum2))
          return this;
        this.dependencies[name].push(!this.config?.analytic ? { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies } : { name: plugin.config.name, seed: plugin.config.seed, checksum: current, dependencies: plugin.dependencies, stack: plugin.telemetry.stack, routes: plugin.router.history, decorators: plugin.singleton, store: plugin.singleton.store, type: plugin.definitions.type, error: plugin.definitions.error, derive: plugin.event.transform.filter((x) => x?.subType === "derive").map((x) => ({ fn: x.toString(), stack: new Error().stack ?? "" })), resolve: plugin.event.transform.filter((x) => x?.subType === "resolve").map((x) => ({ fn: x.toString(), stack: new Error().stack ?? "" })) }), this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event), current);
      } else
        this.event = mergeLifeCycle(this.event, filterGlobalHook(plugin.event));
    return this.validator.global = mergeHook(this.validator.global, { ...plugin.validator.global }), this.validator.local = mergeHook(this.validator.local, { ...plugin.validator.scoped }), this;
  }
  macro(macro) {
    let hook = { checksum: checksum(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: macro.toString() })), fn: macro };
    return this.extender.macros.push(hook), this;
  }
  mount(path, handle) {
    if (path instanceof Elysia || typeof path === "function" || path.length === 0 || path === "/") {
      let run = typeof path === "function" ? path : path instanceof Elysia ? path.compile().fetch : handle instanceof Elysia ? handle.compile().fetch : handle, handler2 = async ({ request, path: path2 }) => {
        if (request.method === "GET" || request.method === "HEAD" || !request.headers.get("content-type"))
          return run(new Request(replaceUrlPath(request.url, path2 || "/"), request));
        return run(new Request(replaceUrlPath(request.url, path2 || "/"), { ...request, body: await request.arrayBuffer() }));
      };
      return this.all("/*", handler2, { type: "none" }), this;
    }
    let length = path.length;
    if (handle instanceof Elysia)
      handle = handle.compile().fetch;
    let handler = async ({ request, path: path2 }) => {
      if (request.method === "GET" || request.method === "HEAD" || !request.headers.get("content-type"))
        return handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), request));
      return handle(new Request(replaceUrlPath(request.url, path2.slice(length) || "/"), { ...request, body: await request.arrayBuffer() }));
    };
    return this.all(path, handler, { type: "none" }), this.all(path + (path.endsWith("/") ? "*" : "/*"), handler, { type: "none" }), this;
  }
  get(path, handler, hook) {
    return this.add("GET", path, handler, hook), this;
  }
  post(path, handler, hook) {
    return this.add("POST", path, handler, hook), this;
  }
  put(path, handler, hook) {
    return this.add("PUT", path, handler, hook), this;
  }
  patch(path, handler, hook) {
    return this.add("PATCH", path, handler, hook), this;
  }
  delete(path, handler, hook) {
    return this.add("DELETE", path, handler, hook), this;
  }
  options(path, handler, hook) {
    return this.add("OPTIONS", path, handler, hook), this;
  }
  all(path, handler, hook) {
    return this.add("ALL", path, handler, hook), this;
  }
  head(path, handler, hook) {
    return this.add("HEAD", path, handler, hook), this;
  }
  connect(path, handler, hook) {
    return this.add("CONNECT", path, handler, hook), this;
  }
  route(method, path, handler, hook) {
    return this.add(method.toUpperCase(), path, handler, hook, hook?.config), this;
  }
  ws(path, options) {
    let transform4 = options.transformMessage ? Array.isArray(options.transformMessage) ? options.transformMessage : [options.transformMessage] : undefined, server = null, validateMessage = getSchemaValidator(options?.body, { models: this.definitions.type, normalize: this.config.normalize }), validateResponse = getSchemaValidator(options?.response, { models: this.definitions.type, normalize: this.config.normalize }), parseMessage = (message) => {
      if (typeof message === "string") {
        let start = message?.charCodeAt(0);
        if (start === 47 || start === 123)
          try {
            message = JSON.parse(message);
          } catch {
          }
        else if (isNumericString(message))
          message = +message;
      }
      if (transform4?.length)
        for (let i = 0;i < transform4.length; i++) {
          let temp = transform4[i](message);
          if (temp !== undefined)
            message = temp;
        }
      return message;
    };
    return this.route("$INTERNALWS", path, (context) => {
      let { set: set22, path: path2, qi, headers, query, params } = context;
      if (server === null)
        server = this.getServer();
      if (server?.upgrade(context.request, { headers: typeof options.upgrade === "function" ? options.upgrade(context) : options.upgrade, data: { validator: validateResponse, open(ws) {
        options.open?.(new ElysiaWS(ws, context));
      }, message: (ws, msg) => {
        let message = parseMessage(msg);
        if (validateMessage?.Check(message) === false)
          return void ws.send(new ValidationError("message", validateMessage, message).message);
        options.message?.(new ElysiaWS(ws, context), message);
      }, drain(ws) {
        options.drain?.(new ElysiaWS(ws, context));
      }, close(ws, code, reason) {
        options.close?.(new ElysiaWS(ws, context), code, reason);
      } } }))
        return;
      return set22.status = 400, "Expected a websocket connection";
    }, { beforeHandle: options.beforeHandle, transform: options.transform, headers: options.headers, params: options.params, query: options.query }), this;
  }
  state(options, name, value2) {
    if (name === undefined)
      value2 = options, options = { as: "append" }, name = "";
    else if (value2 === undefined) {
      if (typeof options === "string")
        value2 = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value2 = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value2) {
      case "object":
        if (name) {
          if (name in this.singleton.store)
            this.singleton.store[name] = mergeDeep(this.singleton.store[name], value2, { override: as === "override" });
          else
            this.singleton.store[name] = value2;
          return this;
        }
        if (value2 === null)
          return this;
        return this.singleton.store = mergeDeep(this.singleton.store, value2, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.store))
            this.singleton.store[name] = value2;
        } else
          this.singleton.store = value2(this.singleton.store);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.store))
          this.singleton.store[name] = value2;
        return this;
    }
  }
  decorate(options, name, value2) {
    if (name === undefined)
      value2 = options, options = { as: "append" }, name = "";
    else if (value2 === undefined) {
      if (typeof options === "string")
        value2 = name, name = options, options = { as: "append" };
      else if (typeof options === "object")
        value2 = name, name = "";
    }
    let { as } = options;
    if (typeof name !== "string")
      return this;
    switch (typeof value2) {
      case "object":
        if (name) {
          if (name in this.singleton.decorator)
            this.singleton.decorator[name] = mergeDeep(this.singleton.decorator[name], value2, { override: as === "override" });
          else
            this.singleton.decorator[name] = value2;
          return this;
        }
        if (value2 === null)
          return this;
        return this.singleton.decorator = mergeDeep(this.singleton.decorator, value2, { override: as === "override" }), this;
      case "function":
        if (name) {
          if (as === "override" || !(name in this.singleton.decorator))
            this.singleton.decorator[name] = value2;
        } else
          this.singleton.decorator = value2(this.singleton.decorator);
        return this;
      default:
        if (as === "override" || !(name in this.singleton.decorator))
          this.singleton.decorator[name] = value2;
        return this;
    }
  }
  derive(optionsOrTransform, transform4) {
    if (!transform4)
      transform4 = optionsOrTransform, optionsOrTransform = { as: "local" };
    let hook = { subType: "derive", fn: transform4 };
    return this.onTransform(optionsOrTransform, hook);
  }
  model(name, model) {
    switch (typeof name) {
      case "object":
        return Object.entries(name).forEach(([key, value2]) => {
          if (!(key in this.definitions.type))
            this.definitions.type[key] = value2;
        }), this;
      case "function":
        return this.definitions.type = name(this.definitions.type), this;
    }
    return this.definitions.type[name] = model, this;
  }
  mapDerive(optionsOrDerive, mapper) {
    if (!mapper)
      mapper = optionsOrDerive, optionsOrDerive = { as: "local" };
    let hook = { subType: "mapDerive", fn: mapper };
    return this.onTransform(optionsOrDerive, hook);
  }
  affix(base, type3, word) {
    if (word === "")
      return this;
    let delimieter = ["_", "-", " "], capitalize2 = (word2) => word2[0].toUpperCase() + word2.slice(1), joinKey = base === "prefix" ? (prefix, word2) => delimieter.includes(prefix.at(-1) ?? "") ? prefix + word2 : prefix + capitalize2(word2) : delimieter.includes(word.at(-1) ?? "") ? (suffix, word2) => word2 + suffix : (suffix, word2) => word2 + capitalize2(suffix), remap = (type22) => {
      let store = {};
      switch (type22) {
        case "decorator":
          for (let key in this.singleton.decorator)
            store[joinKey(word, key)] = this.singleton.decorator[key];
          this.singleton.decorator = store;
          break;
        case "state":
          for (let key in this.singleton.store)
            store[joinKey(word, key)] = this.singleton.store[key];
          this.singleton.store = store;
          break;
        case "model":
          for (let key in this.definitions.type)
            store[joinKey(word, key)] = this.definitions.type[key];
          this.definitions.type = store;
          break;
        case "error":
          for (let key in this.definitions.error)
            store[joinKey(word, key)] = this.definitions.error[key];
          this.definitions.error = store;
          break;
      }
    }, types = Array.isArray(type3) ? type3 : [type3];
    for (let type22 of types.some((x) => x === "all") ? ["decorator", "state", "model", "error"] : types)
      remap(type22);
    return this;
  }
  prefix(type3, word) {
    return this.affix("prefix", type3, word);
  }
  suffix(type3, word) {
    return this.affix("suffix", type3, word);
  }
  compile() {
    if (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server || {}, fetch: this.fetch });
    return this;
  }
  handle = async (request) => this.fetch(request);
  fetch = (request) => {
    return (this.fetch = this.config.aot ? composeGeneralHandler(this) : createDynamicHandler(this))(request);
  };
  handleError = async (context, error22) => (this.handleError = this.config.aot ? composeErrorHandler(this) : createDynamicErrorHandler(this))(context, error22);
  outerErrorHandler = (error22) => new Response(error22.message || error22.name || "Error", { status: error22?.status ?? 500 });
  listen = (options, callback) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.compile(), typeof options === "string") {
      if (!isNumericString(options))
        throw new Error("Port must be a numeric value");
      options = parseInt(options);
    }
    let fetch2 = this.fetch, serve = typeof options === "object" ? { development: !isProduction, reusePort: true, ...this.config.serve || {}, ...options || {}, static: this.router.static.http.static, websocket: { ...this.config.websocket || {}, ...websocket || {} }, fetch: fetch2, error: this.outerErrorHandler } : { development: !isProduction, reusePort: true, ...this.config.serve || {}, static: this.router.static.http.static, websocket: { ...this.config.websocket || {}, ...websocket || {} }, port: options, fetch: fetch2, error: this.outerErrorHandler };
    this.server = Bun?.serve(serve);
    for (let i = 0;i < this.event.start.length; i++)
      this.event.start[i].fn(this);
    if (callback)
      callback(this.server);
    return process.on("beforeExit", () => {
      if (this.server) {
        this.server.stop(), this.server = null;
        for (let i = 0;i < this.event.stop.length; i++)
          this.event.stop[i].fn(this);
      }
    }), this.promisedModules.then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async (closeActiveConnections) => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server) {
      if (this.server.stop(closeActiveConnections), this.server = null, this.event.stop.length)
        for (let i = 0;i < this.event.stop.length; i++)
          this.event.stop[i].fn(this);
    }
  };
  get modules() {
    return Promise.all(this.promisedModules.promises);
  }
}

// node_modules/@elysiajs/swagger/dist/swagger/index.js
var SwaggerUIRender = (info, version2, theme, stringifiedSwaggerOptions, autoDarkMode) => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${autoDarkMode && typeof theme === "string" ? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>` : ""}
    ${typeof theme === "string" ? `<link rel="stylesheet" href="${theme}" />` : `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version2}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${stringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;

// node_modules/@elysiajs/swagger/dist/scalar/theme.js
var theme_default = `
/* basic theme */
.light-mode {
  --theme-color-1: #2a2f45;
  --theme-color-2: #757575;
  --theme-color-3: #8e8e8e;
  --theme-color-accent: #f06292;

  --theme-background-1: #fff;
  --theme-background-2: #f6f6f6;
  --theme-background-3: #e7e7e7;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --theme-color-1: rgba(255, 255, 255, 0.9);
  --theme-color-2: rgba(156, 163, 175, 1);
  --theme-color-3: rgba(255, 255, 255, 0.44);
  --theme-color-accent: #f06292;

  --theme-background-1: #111728;
  --theme-background-2: #1e293b;
  --theme-background-3: #334155;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(255, 255, 255, 0.1);
}
/* Document Sidebar */
.light-mode .sidebar,
.dark-mode .sidebar {
  --sidebar-background-1: var(--theme-background-1);
  --sidebar-item-hover-color: currentColor;
  --sidebar-item-hover-background: var(--theme-background-2);
  --sidebar-item-active-background: var(--theme-background-accent);
  --sidebar-border-color: transparent;
  --sidebar-color-1: var(--theme-color-1);
  --sidebar-color-2: var(--theme-color-2);
  --sidebar-color-active: var(--theme-color-accent);
  --sidebar-search-background: transparent;
  --sidebar-search-border-color: var(--theme-border-color);
  --sidebar-search--color: var(--theme-color-3);
}
/* Document header only shows on mobile*/
.dark-mode .t-doc__header,
.light-mode .t-doc__header {
  --header-background-1: rgba(255, 255, 255, 0.85);
  --header-border-color: transparent;
  --header-color-1: var(--theme-color-1);
  --header-color-2: var(--theme-color-2);
  --header-background-toggle: var(--theme-color-3);
  --header-call-to-action-color: var(--theme-color-accent);
}

.dark-mode .t-doc__header {
  --header-background-1: rgba(17, 23, 40, 0.75);
}

/* advanced */
.light-mode {
  --theme-button-1: rgb(49 53 56);
  --theme-button-1-color: #fff;
  --theme-button-1-hover: rgb(28 31 33);

  --theme-color-green: #069061;
  --theme-color-red: #ef0006;
  --theme-color-yellow: #edbe20;
  --theme-color-blue: #0082d0;
  --theme-color-orange: #fb892c;
  --theme-color-purple: #5203d1;

  --theme-scrollbar-color: rgba(0, 0, 0, 0.18);
  --theme-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --theme-button-1: #f6f6f6;
  --theme-button-1-color: #000;
  --theme-button-1-hover: #e7e7e7;

  --theme-color-green: #a3ffa9;
  --theme-color-red: #ffa3a3;
  --theme-color-yellow: #fffca3;
  --theme-color-blue: #a5d6ff;
  --theme-color-orange: #e2ae83;
  --theme-color-purple: #d2a8ff;

  --theme-scrollbar-color: rgba(255, 255, 255, 0.24);
  --theme-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
/* Elysia Specific */
.scalar-api-client__send-request-button,
.show-api-client-button {
  background: #3c82f6 !important;
}
.show-api-client-button:before {
  display: none;
}

.sidebar-search:hover {
  transition: all 0.15s ease-in-out;
  --sidebar-search-border-color: var(--theme-color-accent) !important;
  color: var(--sidebar-color-1) !important;
}
.scalar-api-client__container .sidebar {
  --sidebar-border-color: var(--theme-border-color);
}
@media (min-width: 1150px) {
  .section-container:has( ~ .footer):before,
  .tag-section-container:before {
    content: "";
    position: absolute;
    top: -5px;
    left: 0;
    width: 100%;
    height: 10px;
    background: linear-gradient(90deg, var(--theme-background-1) 3%,transparent 10%);
  }
}
.section-flare {
  position: absolute;
  width: 100vw;
  height: 300px;
  --stripes: repeating-linear-gradient(
    100deg,
    #fff 0%,
    #fff 7%,
    transparent 10%,
    transparent 12%,
    #fff 16%
  );
  --stripesDark: repeating-linear-gradient(
    100deg,
    #000 0%,
    #000 7%,
    transparent 10%,
    transparent 12%,
    #000 16%
  );
  --rainbow: repeating-linear-gradient(
    100deg,
    #60a5fa 10%,
    #e879f9 16%,
    #5eead4 22%,
    #60a5fa 30%
  );
  background-image: var(--stripes), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(
    ellipse at 100% 0%,
    black 40%,
    transparent 70%
  );
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.15;
}
.dark-mode .section-flare {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
}
.section-flare:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.light-mode .t-doc__header,
.dark-mode .t-doc__header {
  animation: headerbackground forwards;
  animation-timeline: scroll();
  animation-range: 0px 200px;
  --header-border-color: transparent;
}
`;

// node_modules/@elysiajs/swagger/dist/scalar/index.js
var ScalarRender = (version2, config, cdn) => `<!doctype html>
<html>
  <head>
    <title>API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config.customCss ?? theme_default}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config.spec?.url}"
      data-configuration='${JSON.stringify(config)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version2}/dist/browser/standalone.min.js`}"></script>
  </body>
</html>`;

// node_modules/@elysiajs/swagger/dist/utils.js
var import_lodash = __toESM(require_lodash(), 1);
var toOpenAPIPath = (path) => path.split("/").map((x) => x.startsWith(":") ? `{${x.slice(1, x.length)}}` : x).join("/");
var mapProperties = (name, schema3, models) => {
  if (schema3 === undefined)
    return [];
  if (typeof schema3 === "string")
    if (schema3 in models)
      schema3 = models[schema3];
    else
      throw new Error(`Can't find model ${schema3}`);
  return Object.entries(schema3?.properties ?? []).map(([key, value2]) => {
    const { type: valueType = undefined, ...rest3 } = value2;
    return {
      ...rest3,
      schema: { type: valueType },
      in: name,
      name: key,
      required: schema3.required?.includes(key) ?? false
    };
  });
};
var mapTypesResponse = (types, schema3) => {
  if (typeof schema3 === "object" && ["void", "undefined", "null"].includes(schema3.type))
    return;
  const responses = {};
  for (const type3 of types)
    responses[type3] = {
      schema: typeof schema3 === "string" ? {
        $ref: `#/components/schemas/${schema3}`
      } : { ...schema3 }
    };
  return responses;
};
var capitalize2 = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var generateOperationId = (method, paths) => {
  let operationId = method.toLowerCase();
  if (paths === "/")
    return operationId + "Index";
  for (const path of paths.split("/")) {
    if (path.charCodeAt(0) === 123) {
      operationId += "By" + capitalize2(path.slice(1, -1));
    } else {
      operationId += capitalize2(path);
    }
  }
  return operationId;
};
var registerSchemaPath = ({ schema: schema3, path, method, hook, models }) => {
  if (hook)
    hook = import_lodash.default(hook);
  const contentType = hook?.type ?? [
    "application/json",
    "multipart/form-data",
    "text/plain"
  ];
  path = toOpenAPIPath(path);
  const contentTypes = typeof contentType === "string" ? [contentType] : contentType ?? ["application/json"];
  const bodySchema = hook?.body;
  const paramsSchema = hook?.params;
  const headerSchema = hook?.headers;
  const querySchema = hook?.query;
  let responseSchema = hook?.response;
  if (typeof responseSchema === "object") {
    if (Kind in responseSchema) {
      const { type: type3, properties, required: required3, additionalProperties, ...rest3 } = responseSchema;
      responseSchema = {
        "200": {
          ...rest3,
          description: rest3.description,
          content: mapTypesResponse(contentTypes, type3 === "object" || type3 === "array" ? {
            type: type3,
            properties,
            items: responseSchema.items,
            required: required3
          } : responseSchema)
        }
      };
    } else {
      Object.entries(responseSchema).forEach(([key, value2]) => {
        if (typeof value2 === "string") {
          if (!models[value2])
            return;
          const { type: type3, properties, required: required3, additionalProperties: _2, ...rest3 } = models[value2];
          responseSchema[key] = {
            ...rest3,
            description: rest3.description,
            content: mapTypesResponse(contentTypes, value2)
          };
        } else {
          const { type: type3, properties, required: required3, additionalProperties, ...rest3 } = value2;
          responseSchema[key] = {
            ...rest3,
            description: rest3.description,
            content: mapTypesResponse(contentTypes, rest3.type === "object" || rest3.type === "array" ? {
              type: rest3.type,
              properties,
              items: value2.items,
              required: required3
            } : value2)
          };
        }
      });
    }
  } else if (typeof responseSchema === "string") {
    if (!(responseSchema in models))
      return;
    const { type: type3, properties, required: required3, additionalProperties: _2, ...rest3 } = models[responseSchema];
    responseSchema = {
      "200": {
        ...rest3,
        content: mapTypesResponse(contentTypes, responseSchema)
      }
    };
  }
  const parameters3 = [
    ...mapProperties("header", headerSchema, models),
    ...mapProperties("path", paramsSchema, models),
    ...mapProperties("query", querySchema, models)
  ];
  schema3[path] = {
    ...schema3[path] ? schema3[path] : {},
    [method.toLowerCase()]: {
      ...headerSchema || paramsSchema || querySchema || bodySchema ? { parameters: parameters3 } : {},
      ...responseSchema ? {
        responses: responseSchema
      } : {},
      operationId: hook?.detail?.operationId ?? generateOperationId(method, path),
      ...hook?.detail,
      ...bodySchema ? {
        requestBody: {
          content: mapTypesResponse(contentTypes, typeof bodySchema === "string" ? {
            $ref: `#/components/schemas/${bodySchema}`
          } : bodySchema)
        }
      } : null
    }
  };
};
var filterPaths = (paths, { excludeStaticFile = true, exclude: exclude3 = [] }) => {
  const newPaths = {};
  for (const [key, value2] of Object.entries(paths))
    if (!exclude3.some((x) => {
      if (typeof x === "string")
        return key === x;
      return x.test(key);
    }) && !key.includes("/swagger") && !key.includes("*") && (excludeStaticFile ? !key.includes(".") : true)) {
      Object.keys(value2).forEach((method) => {
        const schema3 = value2[method];
        if (key.includes("{")) {
          if (!schema3.parameters)
            schema3.parameters = [];
          schema3.parameters = [
            ...key.split("/").filter((x) => x.startsWith("{") && !schema3.parameters.find((params) => params.in === "path" && params.name === x.slice(1, x.length - 1))).map((x) => ({
              schema: { type: "string" },
              in: "path",
              name: x.slice(1, x.length - 1),
              required: true
            })),
            ...schema3.parameters
          ];
        }
        if (!schema3.responses)
          schema3.responses = {
            200: {}
          };
      });
      newPaths[key] = value2;
    }
  return newPaths;
};

// node_modules/@elysiajs/swagger/dist/index.js
var swagger = ({ provider = "scalar", scalarVersion = "latest", scalarCDN = "", scalarConfig = {}, documentation = {}, version: version2 = "5.9.0", excludeStaticFile = true, path = "/swagger", exclude: exclude3 = [], swaggerOptions = {}, theme = `https://unpkg.com/swagger-ui-dist@${version2}/swagger-ui.css`, autoDarkMode = true, excludeMethods = ["OPTIONS"] } = {
  provider: "scalar",
  scalarVersion: "latest",
  scalarCDN: "",
  scalarConfig: {},
  documentation: {},
  version: "5.9.0",
  excludeStaticFile: true,
  path: "/swagger",
  exclude: [],
  swaggerOptions: {},
  autoDarkMode: true,
  excludeMethods: ["OPTIONS"]
}) => (app) => {
  const schema3 = {};
  let totalRoutes = 0;
  if (!version2)
    version2 = `https://unpkg.com/swagger-ui-dist@${version2}/swagger-ui.css`;
  const info = {
    title: "Elysia Documentation",
    description: "Development documentation",
    version: "0.0.0",
    ...documentation.info
  };
  const relativePath = path.startsWith("/") ? path.slice(1) : path;
  app.get(path, (() => {
    const combinedSwaggerOptions = {
      url: `${relativePath}/json`,
      dom_id: "#swagger-ui",
      ...swaggerOptions
    };
    const stringifiedSwaggerOptions = JSON.stringify(combinedSwaggerOptions, (key, value2) => {
      if (typeof value2 == "function")
        return;
      return value2;
    });
    const scalarConfiguration = {
      spec: {
        ...scalarConfig.spec,
        url: `${relativePath}/json`
      },
      ...scalarConfig
    };
    return new Response(provider === "swagger-ui" ? SwaggerUIRender(info, version2, theme, stringifiedSwaggerOptions, autoDarkMode) : ScalarRender(scalarVersion, scalarConfiguration, scalarCDN), {
      headers: {
        "content-type": "text/html; charset=utf8"
      }
    });
  })()).get(`${path}/json`, () => {
    const routes = app.routes;
    if (routes.length !== totalRoutes) {
      totalRoutes = routes.length;
      routes.forEach((route) => {
        if (excludeMethods.includes(route.method))
          return;
        registerSchemaPath({
          schema: schema3,
          hook: route.hooks,
          method: route.method,
          path: route.path,
          models: app.definitions?.type,
          contentType: route.hooks.type
        });
      });
    }
    return {
      openapi: "3.0.3",
      ...{
        ...documentation,
        info: {
          title: "Elysia Documentation",
          description: "Development documentation",
          version: "0.0.0",
          ...documentation.info
        }
      },
      paths: filterPaths(schema3, {
        excludeStaticFile,
        exclude: Array.isArray(exclude3) ? exclude3 : [exclude3]
      }),
      components: {
        ...documentation.components,
        schemas: {
          ...app.definitions?.type,
          ...documentation.components?.schemas
        }
      }
    };
  });
  return app;
};

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// node_modules/jose/dist/browser/lib/buffer_utils.js
var encoder2 = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT322 = 2 ** 32;
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder2.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0;i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode2 = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes = new Uint8Array(binary.length);
  for (let i = 0;i < binary.length; i++) {
    bytes[i] = binary.charCodeAt(i);
  }
  return bytes;
};
var decode2 = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch (_a) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/jose/dist/browser/util/errors.js
class JOSEError extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message) {
    var _a;
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === undefined || _a.call(Error, this, this.constructor);
  }
}

class JWTClaimValidationFailed extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JWTExpired extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JOSEAlgNotAllowed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
}

class JOSENotSupported extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
}
class JWSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
}

class JWTInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
}
class JWSSignatureVerificationFailed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
}

// node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash3) {
  return parseInt(hash3.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types) {
  if (types.length > 2) {
    const last = types.pop();
    msg += `one of type ${types.join(", ")}, or ${last}.`;
  } else if (types.length === 2) {
    msg += `one of type ${types[0]} or ${types[1]}.`;
  } else {
    msg += `of type ${types[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
var invalid_key_input_default = (actual, ...types) => {
  return message("Key must be ", actual, ...types);
};
function withAlg(alg, actual, ...types) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types);
}

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = (key) => {
  return isCryptoKey(key);
};
var types = ["CryptoKey"];

// node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters3 = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters3);
      continue;
    }
    for (const parameter of parameters3) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value2) {
  return typeof value2 === "object" && value2 !== null;
}
function isObject2(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck = (alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
};
var check_key_type_default = checkKeyType;

// node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default = validateCrit;

// node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash3 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash3, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash3, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash3, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash3, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}

// node_modules/jose/dist/browser/runtime/verify.js
var verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch (_a) {
    return false;
  }
};
var verify_default = verify;

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject2(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === undefined && jws.header === undefined) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== undefined && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === undefined) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== undefined && !isObject2(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode2(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder2.encode((_a = jws.protected) !== null && _a !== undefined ? _a : ""), encoder2.encode("."), typeof jws.payload === "string" ? encoder2.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode2(jws.signature);
  } catch (_c) {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed;
  }
  let payload;
  if (b64) {
    try {
      payload = decode2(jws.payload);
    } catch (_d) {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder2.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== undefined) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== undefined) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}

// node_modules/jose/dist/browser/lib/epoch.js
var epoch_default = (date4) => Math.floor(date4.getTime() / 1000);

// node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value2 = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value2);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value2 * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value2 * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value2 * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value2 * week);
    default:
      return Math.round(value2 * year);
  }
};

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = (value2) => value2.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
  }
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch (_a) {
  }
  if (!isObject2(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  if (maxTokenAge !== undefined)
    requiredClaims.push("iat");
  if (audience !== undefined)
    requiredClaims.push("aud");
  if (subject !== undefined)
    requiredClaims.push("sub");
  if (issuer !== undefined)
    requiredClaims.push("iss");
  for (const claim of new Set(requiredClaims.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || new Date);
  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
  }
  if (payload.nbf !== undefined) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
    }
  }
  if (payload.exp !== undefined) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
    }
  }
  return payload;
};

// node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === undefined ? undefined : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
// node_modules/jose/dist/browser/runtime/sign.js
var sign = async (alg, key, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};
var sign_default = sign;

// node_modules/jose/dist/browser/jws/flattened/sign.js
class FlattenedSign {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder2.encode(encode2(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder2.encode(encode2(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder2.encode("");
    }
    const data = concat(protectedHeader, encoder2.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode2(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
}

// node_modules/jose/dist/browser/jws/compact/sign.js
class CompactSign {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === undefined) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
}

// node_modules/jose/dist/browser/jwt/produce.js
class ProduceJWT {
  constructor(payload) {
    if (!isObject2(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: input };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: input };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(new Date) };
    } else {
      this._payload = { ...this._payload, iat: input };
    }
    return this;
  }
}

// node_modules/jose/dist/browser/jwt/sign.js
class SignJWT extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    var _a;
    const sig = new CompactSign(encoder2.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray((_a = this._protectedHeader) === null || _a === undefined ? undefined : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
}
// node_modules/@elysiajs/jwt/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __export2 = (target, all) => {
  for (var name in all)
    __defProp3(target, name, { get: all[name], enumerable: true });
};
var value_exports = {};
__export2(value_exports, {
  IsArray: () => IsArray5,
  IsAsyncIterator: () => IsAsyncIterator5,
  IsBigInt: () => IsBigInt5,
  IsBoolean: () => IsBoolean5,
  IsDate: () => IsDate5,
  IsFunction: () => IsFunction5,
  IsIterator: () => IsIterator5,
  IsNull: () => IsNull5,
  IsNumber: () => IsNumber5,
  IsObject: () => IsObject5,
  IsRegExp: () => IsRegExp4,
  IsString: () => IsString5,
  IsSymbol: () => IsSymbol5,
  IsUint8Array: () => IsUint8Array5,
  IsUndefined: () => IsUndefined5
});
function IsAsyncIterator5(value2) {
  return IsObject5(value2) && !IsArray5(value2) && !IsUint8Array5(value2) && Symbol.asyncIterator in value2;
}
function IsArray5(value2) {
  return Array.isArray(value2);
}
function IsBigInt5(value2) {
  return typeof value2 === "bigint";
}
function IsBoolean5(value2) {
  return typeof value2 === "boolean";
}
function IsDate5(value2) {
  return value2 instanceof globalThis.Date;
}
function IsFunction5(value2) {
  return typeof value2 === "function";
}
function IsIterator5(value2) {
  return IsObject5(value2) && !IsArray5(value2) && !IsUint8Array5(value2) && Symbol.iterator in value2;
}
function IsNull5(value2) {
  return value2 === null;
}
function IsNumber5(value2) {
  return typeof value2 === "number";
}
function IsObject5(value2) {
  return typeof value2 === "object" && value2 !== null;
}
function IsRegExp4(value2) {
  return value2 instanceof globalThis.RegExp;
}
function IsString5(value2) {
  return typeof value2 === "string";
}
function IsSymbol5(value2) {
  return typeof value2 === "symbol";
}
function IsUint8Array5(value2) {
  return value2 instanceof globalThis.Uint8Array;
}
function IsUndefined5(value2) {
  return value2 === undefined;
}
function ArrayType7(value2) {
  return value2.map((value22) => Visit17(value22));
}
function DateType5(value2) {
  return new Date(value2.getTime());
}
function Uint8ArrayType3(value2) {
  return new Uint8Array(value2);
}
function RegExpType2(value2) {
  return new RegExp(value2.source, value2.flags);
}
function ObjectType7(value2) {
  const result = {};
  for (const key of Object.getOwnPropertyNames(value2)) {
    result[key] = Visit17(value2[key]);
  }
  for (const key of Object.getOwnPropertySymbols(value2)) {
    result[key] = Visit17(value2[key]);
  }
  return result;
}
function Visit17(value2) {
  return IsArray5(value2) ? ArrayType7(value2) : IsDate5(value2) ? DateType5(value2) : IsUint8Array5(value2) ? Uint8ArrayType3(value2) : IsRegExp4(value2) ? RegExpType2(value2) : IsObject5(value2) ? ObjectType7(value2) : value2;
}
function Clone4(value2) {
  return Visit17(value2);
}
function CloneRest2(schemas) {
  return schemas.map((schema3) => CloneType2(schema3));
}
function CloneType2(schema3, options = {}) {
  return { ...Clone4(schema3), ...options };
}
var TypeBoxError2 = class extends Error {
  constructor(message2) {
    super(message2);
  }
};
var TransformKind2 = Symbol.for("TypeBox.Transform");
var ReadonlyKind2 = Symbol.for("TypeBox.Readonly");
var OptionalKind2 = Symbol.for("TypeBox.Optional");
var Hint2 = Symbol.for("TypeBox.Hint");
var Kind2 = Symbol.for("TypeBox.Kind");
function IsReadonly3(value2) {
  return IsObject5(value2) && value2[ReadonlyKind2] === "Readonly";
}
function IsOptional3(value2) {
  return IsObject5(value2) && value2[OptionalKind2] === "Optional";
}
function IsAny3(value2) {
  return IsKindOf3(value2, "Any");
}
function IsArray22(value2) {
  return IsKindOf3(value2, "Array");
}
function IsAsyncIterator22(value2) {
  return IsKindOf3(value2, "AsyncIterator");
}
function IsBigInt22(value2) {
  return IsKindOf3(value2, "BigInt");
}
function IsBoolean22(value2) {
  return IsKindOf3(value2, "Boolean");
}
function IsConstructor3(value2) {
  return IsKindOf3(value2, "Constructor");
}
function IsDate22(value2) {
  return IsKindOf3(value2, "Date");
}
function IsFunction22(value2) {
  return IsKindOf3(value2, "Function");
}
function IsInteger4(value2) {
  return IsKindOf3(value2, "Integer");
}
function IsIntersect3(value2) {
  return IsKindOf3(value2, "Intersect");
}
function IsIterator22(value2) {
  return IsKindOf3(value2, "Iterator");
}
function IsKindOf3(value2, kind) {
  return IsObject5(value2) && Kind2 in value2 && value2[Kind2] === kind;
}
function IsLiteral3(value2) {
  return IsKindOf3(value2, "Literal");
}
function IsMappedKey3(value2) {
  return IsKindOf3(value2, "MappedKey");
}
function IsMappedResult3(value2) {
  return IsKindOf3(value2, "MappedResult");
}
function IsNever3(value2) {
  return IsKindOf3(value2, "Never");
}
function IsNot3(value2) {
  return IsKindOf3(value2, "Not");
}
function IsNull22(value2) {
  return IsKindOf3(value2, "Null");
}
function IsNumber22(value2) {
  return IsKindOf3(value2, "Number");
}
function IsObject22(value2) {
  return IsKindOf3(value2, "Object");
}
function IsPromise4(value2) {
  return IsKindOf3(value2, "Promise");
}
function IsRecord3(value2) {
  return IsKindOf3(value2, "Record");
}
function IsRef3(value2) {
  return IsKindOf3(value2, "Ref");
}
function IsRegExp22(value2) {
  return IsKindOf3(value2, "RegExp");
}
function IsString22(value2) {
  return IsKindOf3(value2, "String");
}
function IsSymbol22(value2) {
  return IsKindOf3(value2, "Symbol");
}
function IsTemplateLiteral3(value2) {
  return IsKindOf3(value2, "TemplateLiteral");
}
function IsThis3(value2) {
  return IsKindOf3(value2, "This");
}
function IsTransform3(value2) {
  return IsObject5(value2) && TransformKind2 in value2;
}
function IsTuple3(value2) {
  return IsKindOf3(value2, "Tuple");
}
function IsUndefined22(value2) {
  return IsKindOf3(value2, "Undefined");
}
function IsUnion3(value2) {
  return IsKindOf3(value2, "Union");
}
function IsUint8Array22(value2) {
  return IsKindOf3(value2, "Uint8Array");
}
function IsUnknown3(value2) {
  return IsKindOf3(value2, "Unknown");
}
function IsUnsafe3(value2) {
  return IsKindOf3(value2, "Unsafe");
}
function IsVoid3(value2) {
  return IsKindOf3(value2, "Void");
}
function IsKind3(value2) {
  return IsObject5(value2) && Kind2 in value2 && IsString5(value2[Kind2]);
}
function IsSchema3(value2) {
  return IsAny3(value2) || IsArray22(value2) || IsBoolean22(value2) || IsBigInt22(value2) || IsAsyncIterator22(value2) || IsConstructor3(value2) || IsDate22(value2) || IsFunction22(value2) || IsInteger4(value2) || IsIntersect3(value2) || IsIterator22(value2) || IsLiteral3(value2) || IsMappedKey3(value2) || IsMappedResult3(value2) || IsNever3(value2) || IsNot3(value2) || IsNull22(value2) || IsNumber22(value2) || IsObject22(value2) || IsPromise4(value2) || IsRecord3(value2) || IsRef3(value2) || IsRegExp22(value2) || IsString22(value2) || IsSymbol22(value2) || IsTemplateLiteral3(value2) || IsThis3(value2) || IsTuple3(value2) || IsUndefined22(value2) || IsUnion3(value2) || IsUint8Array22(value2) || IsUnknown3(value2) || IsUnsafe3(value2) || IsVoid3(value2) || IsKind3(value2);
}
var type_exports = {};
__export2(type_exports, {
  IsAny: () => IsAny22,
  IsArray: () => IsArray32,
  IsAsyncIterator: () => IsAsyncIterator32,
  IsBigInt: () => IsBigInt32,
  IsBoolean: () => IsBoolean32,
  IsConstructor: () => IsConstructor22,
  IsDate: () => IsDate32,
  IsFunction: () => IsFunction32,
  IsInteger: () => IsInteger22,
  IsIntersect: () => IsIntersect22,
  IsIterator: () => IsIterator32,
  IsKind: () => IsKind22,
  IsKindOf: () => IsKindOf22,
  IsLiteral: () => IsLiteral22,
  IsLiteralBoolean: () => IsLiteralBoolean2,
  IsLiteralNumber: () => IsLiteralNumber2,
  IsLiteralString: () => IsLiteralString2,
  IsLiteralValue: () => IsLiteralValue2,
  IsMappedKey: () => IsMappedKey22,
  IsMappedResult: () => IsMappedResult22,
  IsNever: () => IsNever22,
  IsNot: () => IsNot22,
  IsNull: () => IsNull32,
  IsNumber: () => IsNumber32,
  IsObject: () => IsObject32,
  IsOptional: () => IsOptional22,
  IsPromise: () => IsPromise22,
  IsProperties: () => IsProperties2,
  IsReadonly: () => IsReadonly22,
  IsRecord: () => IsRecord22,
  IsRecursive: () => IsRecursive2,
  IsRef: () => IsRef22,
  IsRegExp: () => IsRegExp32,
  IsSchema: () => IsSchema22,
  IsString: () => IsString32,
  IsSymbol: () => IsSymbol32,
  IsTemplateLiteral: () => IsTemplateLiteral22,
  IsThis: () => IsThis22,
  IsTransform: () => IsTransform22,
  IsTuple: () => IsTuple22,
  IsUint8Array: () => IsUint8Array32,
  IsUndefined: () => IsUndefined32,
  IsUnion: () => IsUnion22,
  IsUnionLiteral: () => IsUnionLiteral2,
  IsUnknown: () => IsUnknown22,
  IsUnsafe: () => IsUnsafe22,
  IsVoid: () => IsVoid22,
  TypeGuardUnknownTypeError: () => TypeGuardUnknownTypeError2
});
var TypeGuardUnknownTypeError2 = class extends TypeBoxError2 {
};
var KnownTypes2 = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];
function IsPattern2(value2) {
  try {
    new RegExp(value2);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree2(value2) {
  if (!IsString5(value2))
    return false;
  for (let i = 0;i < value2.length; i++) {
    const code = value2.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties2(value2) {
  return IsOptionalBoolean2(value2) || IsSchema22(value2);
}
function IsOptionalBigInt2(value2) {
  return IsUndefined5(value2) || IsBigInt5(value2);
}
function IsOptionalNumber2(value2) {
  return IsUndefined5(value2) || IsNumber5(value2);
}
function IsOptionalBoolean2(value2) {
  return IsUndefined5(value2) || IsBoolean5(value2);
}
function IsOptionalString2(value2) {
  return IsUndefined5(value2) || IsString5(value2);
}
function IsOptionalPattern2(value2) {
  return IsUndefined5(value2) || IsString5(value2) && IsControlCharacterFree2(value2) && IsPattern2(value2);
}
function IsOptionalFormat2(value2) {
  return IsUndefined5(value2) || IsString5(value2) && IsControlCharacterFree2(value2);
}
function IsOptionalSchema2(value2) {
  return IsUndefined5(value2) || IsSchema22(value2);
}
function IsReadonly22(value2) {
  return IsObject5(value2) && value2[ReadonlyKind2] === "Readonly";
}
function IsOptional22(value2) {
  return IsObject5(value2) && value2[OptionalKind2] === "Optional";
}
function IsAny22(value2) {
  return IsKindOf22(value2, "Any") && IsOptionalString2(value2.$id);
}
function IsArray32(value2) {
  return IsKindOf22(value2, "Array") && value2.type === "array" && IsOptionalString2(value2.$id) && IsSchema22(value2.items) && IsOptionalNumber2(value2.minItems) && IsOptionalNumber2(value2.maxItems) && IsOptionalBoolean2(value2.uniqueItems) && IsOptionalSchema2(value2.contains) && IsOptionalNumber2(value2.minContains) && IsOptionalNumber2(value2.maxContains);
}
function IsAsyncIterator32(value2) {
  return IsKindOf22(value2, "AsyncIterator") && value2.type === "AsyncIterator" && IsOptionalString2(value2.$id) && IsSchema22(value2.items);
}
function IsBigInt32(value2) {
  return IsKindOf22(value2, "BigInt") && value2.type === "bigint" && IsOptionalString2(value2.$id) && IsOptionalBigInt2(value2.exclusiveMaximum) && IsOptionalBigInt2(value2.exclusiveMinimum) && IsOptionalBigInt2(value2.maximum) && IsOptionalBigInt2(value2.minimum) && IsOptionalBigInt2(value2.multipleOf);
}
function IsBoolean32(value2) {
  return IsKindOf22(value2, "Boolean") && value2.type === "boolean" && IsOptionalString2(value2.$id);
}
function IsConstructor22(value2) {
  return IsKindOf22(value2, "Constructor") && value2.type === "Constructor" && IsOptionalString2(value2.$id) && IsArray5(value2.parameters) && value2.parameters.every((schema3) => IsSchema22(schema3)) && IsSchema22(value2.returns);
}
function IsDate32(value2) {
  return IsKindOf22(value2, "Date") && value2.type === "Date" && IsOptionalString2(value2.$id) && IsOptionalNumber2(value2.exclusiveMaximumTimestamp) && IsOptionalNumber2(value2.exclusiveMinimumTimestamp) && IsOptionalNumber2(value2.maximumTimestamp) && IsOptionalNumber2(value2.minimumTimestamp) && IsOptionalNumber2(value2.multipleOfTimestamp);
}
function IsFunction32(value2) {
  return IsKindOf22(value2, "Function") && value2.type === "Function" && IsOptionalString2(value2.$id) && IsArray5(value2.parameters) && value2.parameters.every((schema3) => IsSchema22(schema3)) && IsSchema22(value2.returns);
}
function IsInteger22(value2) {
  return IsKindOf22(value2, "Integer") && value2.type === "integer" && IsOptionalString2(value2.$id) && IsOptionalNumber2(value2.exclusiveMaximum) && IsOptionalNumber2(value2.exclusiveMinimum) && IsOptionalNumber2(value2.maximum) && IsOptionalNumber2(value2.minimum) && IsOptionalNumber2(value2.multipleOf);
}
function IsProperties2(value2) {
  return IsObject5(value2) && Object.entries(value2).every(([key, schema3]) => IsControlCharacterFree2(key) && IsSchema22(schema3));
}
function IsIntersect22(value2) {
  return IsKindOf22(value2, "Intersect") && (IsString5(value2.type) && value2.type !== "object" ? false : true) && IsArray5(value2.allOf) && value2.allOf.every((schema3) => IsSchema22(schema3) && !IsTransform22(schema3)) && IsOptionalString2(value2.type) && (IsOptionalBoolean2(value2.unevaluatedProperties) || IsOptionalSchema2(value2.unevaluatedProperties)) && IsOptionalString2(value2.$id);
}
function IsIterator32(value2) {
  return IsKindOf22(value2, "Iterator") && value2.type === "Iterator" && IsOptionalString2(value2.$id) && IsSchema22(value2.items);
}
function IsKindOf22(value2, kind) {
  return IsObject5(value2) && Kind2 in value2 && value2[Kind2] === kind;
}
function IsLiteralString2(value2) {
  return IsLiteral22(value2) && IsString5(value2.const);
}
function IsLiteralNumber2(value2) {
  return IsLiteral22(value2) && IsNumber5(value2.const);
}
function IsLiteralBoolean2(value2) {
  return IsLiteral22(value2) && IsBoolean5(value2.const);
}
function IsLiteral22(value2) {
  return IsKindOf22(value2, "Literal") && IsOptionalString2(value2.$id) && IsLiteralValue2(value2.const);
}
function IsLiteralValue2(value2) {
  return IsBoolean5(value2) || IsNumber5(value2) || IsString5(value2);
}
function IsMappedKey22(value2) {
  return IsKindOf22(value2, "MappedKey") && IsArray5(value2.keys) && value2.keys.every((key) => IsNumber5(key) || IsString5(key));
}
function IsMappedResult22(value2) {
  return IsKindOf22(value2, "MappedResult") && IsProperties2(value2.properties);
}
function IsNever22(value2) {
  return IsKindOf22(value2, "Never") && IsObject5(value2.not) && Object.getOwnPropertyNames(value2.not).length === 0;
}
function IsNot22(value2) {
  return IsKindOf22(value2, "Not") && IsSchema22(value2.not);
}
function IsNull32(value2) {
  return IsKindOf22(value2, "Null") && value2.type === "null" && IsOptionalString2(value2.$id);
}
function IsNumber32(value2) {
  return IsKindOf22(value2, "Number") && value2.type === "number" && IsOptionalString2(value2.$id) && IsOptionalNumber2(value2.exclusiveMaximum) && IsOptionalNumber2(value2.exclusiveMinimum) && IsOptionalNumber2(value2.maximum) && IsOptionalNumber2(value2.minimum) && IsOptionalNumber2(value2.multipleOf);
}
function IsObject32(value2) {
  return IsKindOf22(value2, "Object") && value2.type === "object" && IsOptionalString2(value2.$id) && IsProperties2(value2.properties) && IsAdditionalProperties2(value2.additionalProperties) && IsOptionalNumber2(value2.minProperties) && IsOptionalNumber2(value2.maxProperties);
}
function IsPromise22(value2) {
  return IsKindOf22(value2, "Promise") && value2.type === "Promise" && IsOptionalString2(value2.$id) && IsSchema22(value2.item);
}
function IsRecord22(value2) {
  return IsKindOf22(value2, "Record") && value2.type === "object" && IsOptionalString2(value2.$id) && IsAdditionalProperties2(value2.additionalProperties) && IsObject5(value2.patternProperties) && ((schema3) => {
    const keys = Object.getOwnPropertyNames(schema3.patternProperties);
    return keys.length === 1 && IsPattern2(keys[0]) && IsObject5(schema3.patternProperties) && IsSchema22(schema3.patternProperties[keys[0]]);
  })(value2);
}
function IsRecursive2(value2) {
  return IsObject5(value2) && Hint2 in value2 && value2[Hint2] === "Recursive";
}
function IsRef22(value2) {
  return IsKindOf22(value2, "Ref") && IsOptionalString2(value2.$id) && IsString5(value2.$ref);
}
function IsRegExp32(value2) {
  return IsKindOf22(value2, "RegExp") && IsOptionalString2(value2.$id) && IsString5(value2.source) && IsString5(value2.flags) && IsOptionalNumber2(value2.maxLength) && IsOptionalNumber2(value2.minLength);
}
function IsString32(value2) {
  return IsKindOf22(value2, "String") && value2.type === "string" && IsOptionalString2(value2.$id) && IsOptionalNumber2(value2.minLength) && IsOptionalNumber2(value2.maxLength) && IsOptionalPattern2(value2.pattern) && IsOptionalFormat2(value2.format);
}
function IsSymbol32(value2) {
  return IsKindOf22(value2, "Symbol") && value2.type === "symbol" && IsOptionalString2(value2.$id);
}
function IsTemplateLiteral22(value2) {
  return IsKindOf22(value2, "TemplateLiteral") && value2.type === "string" && IsString5(value2.pattern) && value2.pattern[0] === "^" && value2.pattern[value2.pattern.length - 1] === "$";
}
function IsThis22(value2) {
  return IsKindOf22(value2, "This") && IsOptionalString2(value2.$id) && IsString5(value2.$ref);
}
function IsTransform22(value2) {
  return IsObject5(value2) && TransformKind2 in value2;
}
function IsTuple22(value2) {
  return IsKindOf22(value2, "Tuple") && value2.type === "array" && IsOptionalString2(value2.$id) && IsNumber5(value2.minItems) && IsNumber5(value2.maxItems) && value2.minItems === value2.maxItems && (IsUndefined5(value2.items) && IsUndefined5(value2.additionalItems) && value2.minItems === 0 || IsArray5(value2.items) && value2.items.every((schema3) => IsSchema22(schema3)));
}
function IsUndefined32(value2) {
  return IsKindOf22(value2, "Undefined") && value2.type === "undefined" && IsOptionalString2(value2.$id);
}
function IsUnionLiteral2(value2) {
  return IsUnion22(value2) && value2.anyOf.every((schema3) => IsLiteralString2(schema3) || IsLiteralNumber2(schema3));
}
function IsUnion22(value2) {
  return IsKindOf22(value2, "Union") && IsOptionalString2(value2.$id) && IsObject5(value2) && IsArray5(value2.anyOf) && value2.anyOf.every((schema3) => IsSchema22(schema3));
}
function IsUint8Array32(value2) {
  return IsKindOf22(value2, "Uint8Array") && value2.type === "Uint8Array" && IsOptionalString2(value2.$id) && IsOptionalNumber2(value2.minByteLength) && IsOptionalNumber2(value2.maxByteLength);
}
function IsUnknown22(value2) {
  return IsKindOf22(value2, "Unknown") && IsOptionalString2(value2.$id);
}
function IsUnsafe22(value2) {
  return IsKindOf22(value2, "Unsafe");
}
function IsVoid22(value2) {
  return IsKindOf22(value2, "Void") && value2.type === "void" && IsOptionalString2(value2.$id);
}
function IsKind22(value2) {
  return IsObject5(value2) && Kind2 in value2 && IsString5(value2[Kind2]) && !KnownTypes2.includes(value2[Kind2]);
}
function IsSchema22(value2) {
  return IsObject5(value2) && (IsAny22(value2) || IsArray32(value2) || IsBoolean32(value2) || IsBigInt32(value2) || IsAsyncIterator32(value2) || IsConstructor22(value2) || IsDate32(value2) || IsFunction32(value2) || IsInteger22(value2) || IsIntersect22(value2) || IsIterator32(value2) || IsLiteral22(value2) || IsMappedKey22(value2) || IsMappedResult22(value2) || IsNever22(value2) || IsNot22(value2) || IsNull32(value2) || IsNumber32(value2) || IsObject32(value2) || IsPromise22(value2) || IsRecord22(value2) || IsRef22(value2) || IsRegExp32(value2) || IsString32(value2) || IsSymbol32(value2) || IsTemplateLiteral22(value2) || IsThis22(value2) || IsTuple22(value2) || IsUndefined32(value2) || IsUnion22(value2) || IsUint8Array32(value2) || IsUnknown22(value2) || IsUnsafe22(value2) || IsVoid22(value2) || IsKind22(value2));
}
var PatternBoolean2 = "(true|false)";
var PatternNumber2 = "(0|[1-9][0-9]*)";
var PatternString2 = "(.*)";
var PatternBooleanExact2 = `^${PatternBoolean2}\$`;
var PatternNumberExact2 = `^${PatternNumber2}\$`;
var PatternStringExact2 = `^${PatternString2}\$`;
function SetIncludes2(T, S) {
  return T.includes(S);
}
function SetDistinct2(T) {
  return [...new Set(T)];
}
function SetIntersect2(T, S) {
  return T.filter((L) => S.includes(L));
}
function SetIntersectManyResolve2(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect2(Acc, L);
  }, Init);
}
function SetIntersectMany2(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve2(T.slice(1), T[0]) : [];
}
function SetUnionMany2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...L);
  return Acc;
}
function Any2(options = {}) {
  return { ...options, [Kind2]: "Any" };
}
function Array22(schema3, options = {}) {
  return {
    ...options,
    [Kind2]: "Array",
    type: "array",
    items: CloneType2(schema3)
  };
}
function AsyncIterator2(items, options = {}) {
  return {
    ...options,
    [Kind2]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType2(items)
  };
}
function DiscardKey2(value2, key) {
  const { [key]: _2, ...rest3 } = value2;
  return rest3;
}
function Discard2(value2, keys) {
  return keys.reduce((acc, key) => DiscardKey2(acc, key), value2);
}
function Never2(options = {}) {
  return {
    ...options,
    [Kind2]: "Never",
    not: {}
  };
}
function MappedResult2(properties) {
  return {
    [Kind2]: "MappedResult",
    properties
  };
}
function Constructor2(parameters3, returns, options) {
  return {
    ...options,
    [Kind2]: "Constructor",
    type: "Constructor",
    parameters: CloneRest2(parameters3),
    returns: CloneType2(returns)
  };
}
function Function3(parameters3, returns, options) {
  return {
    ...options,
    [Kind2]: "Function",
    type: "Function",
    parameters: CloneRest2(parameters3),
    returns: CloneType2(returns)
  };
}
function UnionCreate2(T, options) {
  return { ...options, [Kind2]: "Union", anyOf: CloneRest2(T) };
}
function IsUnionOptional2(T) {
  return T.some((L) => IsOptional3(L));
}
function RemoveOptionalFromRest3(T) {
  return T.map((L) => IsOptional3(L) ? RemoveOptionalFromType3(L) : L);
}
function RemoveOptionalFromType3(T) {
  return Discard2(T, [OptionalKind2]);
}
function ResolveUnion2(T, options) {
  return IsUnionOptional2(T) ? Optional2(UnionCreate2(RemoveOptionalFromRest3(T), options)) : UnionCreate2(RemoveOptionalFromRest3(T), options);
}
function UnionEvaluated2(T, options = {}) {
  return T.length === 0 ? Never2(options) : T.length === 1 ? CloneType2(T[0], options) : ResolveUnion2(T, options);
}
function Union3(T, options = {}) {
  return T.length === 0 ? Never2(options) : T.length === 1 ? CloneType2(T[0], options) : UnionCreate2(T, options);
}
var TemplateLiteralParserError2 = class extends TypeBoxError2 {
};
function Unescape2(pattern2) {
  return pattern2.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped2(pattern2, index, char) {
  return pattern2[index] === char && pattern2.charCodeAt(index - 1) !== 92;
}
function IsOpenParen2(pattern2, index) {
  return IsNonEscaped2(pattern2, index, "(");
}
function IsCloseParen2(pattern2, index) {
  return IsNonEscaped2(pattern2, index, ")");
}
function IsSeparator2(pattern2, index) {
  return IsNonEscaped2(pattern2, index, "|");
}
function IsGroup2(pattern2) {
  if (!(IsOpenParen2(pattern2, 0) && IsCloseParen2(pattern2, pattern2.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern2.length; index++) {
    if (IsOpenParen2(pattern2, index))
      count += 1;
    if (IsCloseParen2(pattern2, index))
      count -= 1;
    if (count === 0 && index !== pattern2.length - 1)
      return false;
  }
  return true;
}
function InGroup2(pattern2) {
  return pattern2.slice(1, pattern2.length - 1);
}
function IsPrecedenceOr2(pattern2) {
  let count = 0;
  for (let index = 0;index < pattern2.length; index++) {
    if (IsOpenParen2(pattern2, index))
      count += 1;
    if (IsCloseParen2(pattern2, index))
      count -= 1;
    if (IsSeparator2(pattern2, index) && count === 0)
      return true;
  }
  return false;
}
function IsPrecedenceAnd2(pattern2) {
  for (let index = 0;index < pattern2.length; index++) {
    if (IsOpenParen2(pattern2, index))
      return true;
  }
  return false;
}
function Or2(pattern2) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern2.length; index++) {
    if (IsOpenParen2(pattern2, index))
      count += 1;
    if (IsCloseParen2(pattern2, index))
      count -= 1;
    if (IsSeparator2(pattern2, index) && count === 0) {
      const range2 = pattern2.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse2(range2));
      start = index + 1;
    }
  }
  const range = pattern2.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse2(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
}
function And2(pattern2) {
  function Group(value2, index) {
    if (!IsOpenParen2(value2, index))
      throw new TemplateLiteralParserError2(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value2.length; scan++) {
      if (IsOpenParen2(value2, scan))
        count += 1;
      if (IsCloseParen2(value2, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError2(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern22, index) {
    for (let scan = index;scan < pattern22.length; scan++) {
      if (IsOpenParen2(pattern22, scan))
        return [index, scan];
    }
    return [index, pattern22.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern2.length; index++) {
    if (IsOpenParen2(pattern2, index)) {
      const [start, end] = Group(pattern2, index);
      const range = pattern2.slice(start, end + 1);
      expressions.push(TemplateLiteralParse2(range));
      index = end;
    } else {
      const [start, end] = Range(pattern2, index);
      const range = pattern2.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse2(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
}
function TemplateLiteralParse2(pattern2) {
  return IsGroup2(pattern2) ? TemplateLiteralParse2(InGroup2(pattern2)) : IsPrecedenceOr2(pattern2) ? Or2(pattern2) : IsPrecedenceAnd2(pattern2) ? And2(pattern2) : { type: "const", const: Unescape2(pattern2) };
}
function TemplateLiteralParseExact2(pattern2) {
  return TemplateLiteralParse2(pattern2.slice(1, pattern2.length - 1));
}
var TemplateLiteralFiniteError2 = class extends TypeBoxError2 {
};
function IsNumberExpression2(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
}
function IsBooleanExpression2(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
}
function IsStringExpression2(expression) {
  return expression.type === "const" && expression.const === ".*";
}
function IsTemplateLiteralExpressionFinite2(expression) {
  return IsNumberExpression2(expression) || IsStringExpression2(expression) ? false : IsBooleanExpression2(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite2(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError2(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite2(schema3) {
  const expression = TemplateLiteralParseExact2(schema3.pattern);
  return IsTemplateLiteralExpressionFinite2(expression);
}
var TemplateLiteralGenerateError2 = class extends TypeBoxError2 {
};
function* GenerateReduce2(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce2(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd2(expression) {
  return yield* GenerateReduce2(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate2(expr)]));
}
function* GenerateOr2(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate2(expr);
}
function* GenerateConst2(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate2(expression) {
  return expression.type === "and" ? yield* GenerateAnd2(expression) : expression.type === "or" ? yield* GenerateOr2(expression) : expression.type === "const" ? yield* GenerateConst2(expression) : (() => {
    throw new TemplateLiteralGenerateError2("Unknown expression");
  })();
}
function TemplateLiteralGenerate2(schema3) {
  const expression = TemplateLiteralParseExact2(schema3.pattern);
  return IsTemplateLiteralExpressionFinite2(expression) ? [...TemplateLiteralExpressionGenerate2(expression)] : [];
}
function Literal2(value2, options = {}) {
  return {
    ...options,
    [Kind2]: "Literal",
    const: value2,
    type: typeof value2
  };
}
function Boolean3(options = {}) {
  return {
    ...options,
    [Kind2]: "Boolean",
    type: "boolean"
  };
}
function BigInt3(options = {}) {
  return {
    ...options,
    [Kind2]: "BigInt",
    type: "bigint"
  };
}
function Number3(options = {}) {
  return {
    ...options,
    [Kind2]: "Number",
    type: "number"
  };
}
function String3(options = {}) {
  return { ...options, [Kind2]: "String", type: "string" };
}
function* FromUnion20(syntax2) {
  const trim = syntax2.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean3() : trim === "number" ? yield Number3() : trim === "bigint" ? yield BigInt3() : trim === "string" ? yield String3() : yield (() => {
    const literals = trim.split("|").map((literal3) => Literal2(literal3.trim()));
    return literals.length === 0 ? Never2() : literals.length === 1 ? literals[0] : UnionEvaluated2(literals);
  })();
}
function* FromTerminal2(syntax2) {
  if (syntax2[1] !== "{") {
    const L = Literal2("$");
    const R = FromSyntax2(syntax2.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax2.length; i++) {
    if (syntax2[i] === "}") {
      const L = FromUnion20(syntax2.slice(2, i));
      const R = FromSyntax2(syntax2.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal2(syntax2);
}
function* FromSyntax2(syntax2) {
  for (let i = 0;i < syntax2.length; i++) {
    if (syntax2[i] === "$") {
      const L = Literal2(syntax2.slice(0, i));
      const R = FromTerminal2(syntax2.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal2(syntax2);
}
function TemplateLiteralSyntax2(syntax2) {
  return [...FromSyntax2(syntax2)];
}
var TemplateLiteralPatternError2 = class extends TypeBoxError2 {
};
function Escape3(value2) {
  return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Visit22(schema3, acc) {
  return IsTemplateLiteral3(schema3) ? schema3.pattern.slice(1, schema3.pattern.length - 1) : IsUnion3(schema3) ? `(${schema3.anyOf.map((schema22) => Visit22(schema22, acc)).join("|")})` : IsNumber22(schema3) ? `${acc}${PatternNumber2}` : IsInteger4(schema3) ? `${acc}${PatternNumber2}` : IsBigInt22(schema3) ? `${acc}${PatternNumber2}` : IsString22(schema3) ? `${acc}${PatternString2}` : IsLiteral3(schema3) ? `${acc}${Escape3(schema3.const.toString())}` : IsBoolean22(schema3) ? `${acc}${PatternBoolean2}` : (() => {
    throw new TemplateLiteralPatternError2(`Unexpected Kind '${schema3[Kind2]}'`);
  })();
}
function TemplateLiteralPattern2(kinds) {
  return `^${kinds.map((schema3) => Visit22(schema3, "")).join("")}\$`;
}
function TemplateLiteralToUnion2(schema3) {
  const R = TemplateLiteralGenerate2(schema3);
  const L = R.map((S) => Literal2(S));
  return UnionEvaluated2(L);
}
function TemplateLiteral2(unresolved, options = {}) {
  const pattern2 = IsString5(unresolved) ? TemplateLiteralPattern2(TemplateLiteralSyntax2(unresolved)) : TemplateLiteralPattern2(unresolved);
  return { ...options, [Kind2]: "TemplateLiteral", type: "string", pattern: pattern2 };
}
function FromTemplateLiteral7(T) {
  const R = TemplateLiteralGenerate2(T);
  return R.map((S) => S.toString());
}
function FromUnion22(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexPropertyKeys2(L));
  return Acc;
}
function FromLiteral7(T) {
  return [T.toString()];
}
function IndexPropertyKeys2(T) {
  return [...new Set(IsTemplateLiteral3(T) ? FromTemplateLiteral7(T) : IsUnion3(T) ? FromUnion22(T.anyOf) : IsLiteral3(T) ? FromLiteral7(T.const) : IsNumber22(T) ? ["[number]"] : IsInteger4(T) ? ["[number]"] : [])];
}
function FromProperties20(T, P, options) {
  const Acc = {};
  for (const K2 of Object.getOwnPropertyNames(P)) {
    Acc[K2] = Index2(T, IndexPropertyKeys2(P[K2]), options);
  }
  return Acc;
}
function FromMappedResult13(T, R, options) {
  return FromProperties20(T, R.properties, options);
}
function IndexFromMappedResult2(T, R, options) {
  const P = FromMappedResult13(T, R, options);
  return MappedResult2(P);
}
function FromRest9(T, K) {
  return T.map((L) => IndexFromPropertyKey2(L, K));
}
function FromIntersectRest2(T) {
  return T.filter((L) => !IsNever3(L));
}
function FromIntersect18(T, K) {
  return IntersectEvaluated2(FromIntersectRest2(FromRest9(T, K)));
}
function FromUnionRest2(T) {
  return T.some((L) => IsNever3(L)) ? [] : T;
}
function FromUnion32(T, K) {
  return UnionEvaluated2(FromUnionRest2(FromRest9(T, K)));
}
function FromTuple15(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated2(T) : Never2();
}
function FromArray16(T, K) {
  return K === "[number]" ? T : Never2();
}
function FromProperty3(T, K) {
  return K in T ? T[K] : Never2();
}
function IndexFromPropertyKey2(T, K) {
  return IsIntersect3(T) ? FromIntersect18(T.allOf, K) : IsUnion3(T) ? FromUnion32(T.anyOf, K) : IsTuple3(T) ? FromTuple15(T.items ?? [], K) : IsArray22(T) ? FromArray16(T.items, K) : IsObject22(T) ? FromProperty3(T.properties, K) : Never2();
}
function IndexFromPropertyKeys2(T, K) {
  return K.map((L) => IndexFromPropertyKey2(T, L));
}
function FromSchema2(T, K) {
  return UnionEvaluated2(IndexFromPropertyKeys2(T, K));
}
function Index2(T, K, options = {}) {
  return IsMappedResult3(K) ? CloneType2(IndexFromMappedResult2(T, K, options)) : IsMappedKey3(K) ? CloneType2(IndexFromMappedKey2(T, K, options)) : IsSchema3(K) ? CloneType2(FromSchema2(T, IndexPropertyKeys2(K)), options) : CloneType2(FromSchema2(T, K), options);
}
function MappedIndexPropertyKey2(T, K, options) {
  return { [K]: Index2(T, [K], options) };
}
function MappedIndexPropertyKeys2(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey2(T, L, options) };
  }, {});
}
function MappedIndexProperties2(T, K, options) {
  return MappedIndexPropertyKeys2(T, K.keys, options);
}
function IndexFromMappedKey2(T, K, options) {
  const P = MappedIndexProperties2(T, K, options);
  return MappedResult2(P);
}
function Iterator2(items, options = {}) {
  return {
    ...options,
    [Kind2]: "Iterator",
    type: "Iterator",
    items: CloneType2(items)
  };
}
function _Object2(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional3(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema3(options.additionalProperties) ? { additionalProperties: CloneType2(options.additionalProperties) } : {};
  const clonedProperties = {};
  for (const key of propertyKeys)
    clonedProperties[key] = CloneType2(properties[key]);
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind2]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind2]: "Object", type: "object", properties: clonedProperties };
}
var Object22 = _Object2;
function Promise22(item, options = {}) {
  return {
    ...options,
    [Kind2]: "Promise",
    type: "Promise",
    item: CloneType2(item)
  };
}
function RemoveReadonly2(schema3) {
  return Discard2(CloneType2(schema3), [ReadonlyKind2]);
}
function AddReadonly2(schema3) {
  return { ...CloneType2(schema3), [ReadonlyKind2]: "Readonly" };
}
function ReadonlyWithFlag2(schema3, F) {
  return F === false ? RemoveReadonly2(schema3) : AddReadonly2(schema3);
}
function Readonly2(schema3, enable) {
  const F = enable ?? true;
  return IsMappedResult3(schema3) ? ReadonlyFromMappedResult2(schema3, F) : ReadonlyWithFlag2(schema3, F);
}
function FromProperties22(K, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Readonly2(K[K2], F);
  return Acc;
}
function FromMappedResult22(R, F) {
  return FromProperties22(R.properties, F);
}
function ReadonlyFromMappedResult2(R, F) {
  const P = FromMappedResult22(R, F);
  return MappedResult2(P);
}
function Tuple2(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind2]: "Tuple", type: "array", items: CloneRest2(items), additionalItems, minItems, maxItems } : { ...options, [Kind2]: "Tuple", type: "array", minItems, maxItems };
}
function FromMappedResult32(K, P) {
  return K in P ? FromSchemaType2(K, P[K]) : MappedResult2(P);
}
function MappedKeyToKnownMappedResultProperties2(K) {
  return { [K]: Literal2(K) };
}
function MappedKeyToUnknownMappedResultProperties2(P) {
  const Acc = {};
  for (const L of P)
    Acc[L] = Literal2(L);
  return Acc;
}
function MappedKeyToMappedResultProperties2(K, P) {
  return SetIncludes2(P, K) ? MappedKeyToKnownMappedResultProperties2(K) : MappedKeyToUnknownMappedResultProperties2(P);
}
function FromMappedKey5(K, P) {
  const R = MappedKeyToMappedResultProperties2(K, P);
  return FromMappedResult32(K, R);
}
function FromRest22(K, T) {
  return T.map((L) => FromSchemaType2(K, L));
}
function FromProperties32(K, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(T))
    Acc[K2] = FromSchemaType2(K, T[K2]);
  return Acc;
}
function FromSchemaType2(K, T) {
  return IsOptional3(T) ? Optional2(FromSchemaType2(K, Discard2(T, [OptionalKind2]))) : IsReadonly3(T) ? Readonly2(FromSchemaType2(K, Discard2(T, [ReadonlyKind2]))) : IsMappedResult3(T) ? FromMappedResult32(K, T.properties) : IsMappedKey3(T) ? FromMappedKey5(K, T.keys) : IsConstructor3(T) ? Constructor2(FromRest22(K, T.parameters), FromSchemaType2(K, T.returns)) : IsFunction22(T) ? Function3(FromRest22(K, T.parameters), FromSchemaType2(K, T.returns)) : IsAsyncIterator22(T) ? AsyncIterator2(FromSchemaType2(K, T.items)) : IsIterator22(T) ? Iterator2(FromSchemaType2(K, T.items)) : IsIntersect3(T) ? Intersect3(FromRest22(K, T.allOf)) : IsUnion3(T) ? Union3(FromRest22(K, T.anyOf)) : IsTuple3(T) ? Tuple2(FromRest22(K, T.items ?? [])) : IsObject22(T) ? Object22(FromProperties32(K, T.properties)) : IsArray22(T) ? Array22(FromSchemaType2(K, T.items)) : IsPromise4(T) ? Promise22(FromSchemaType2(K, T.item)) : T;
}
function MappedFunctionReturnType2(K, T) {
  const Acc = {};
  for (const L of K)
    Acc[L] = FromSchemaType2(L, T);
  return Acc;
}
function Mapped2(key, map3, options = {}) {
  const K = IsSchema3(key) ? IndexPropertyKeys2(key) : key;
  const RT = map3({ [Kind2]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType2(K, RT);
  return CloneType2(Object22(R), options);
}
function RemoveOptional2(schema3) {
  return Discard2(CloneType2(schema3), [OptionalKind2]);
}
function AddOptional2(schema3) {
  return { ...CloneType2(schema3), [OptionalKind2]: "Optional" };
}
function OptionalWithFlag2(schema3, F) {
  return F === false ? RemoveOptional2(schema3) : AddOptional2(schema3);
}
function Optional2(schema3, enable) {
  const F = enable ?? true;
  return IsMappedResult3(schema3) ? OptionalFromMappedResult2(schema3, F) : OptionalWithFlag2(schema3, F);
}
function FromProperties42(P, F) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Optional2(P[K2], F);
  return Acc;
}
function FromMappedResult42(R, F) {
  return FromProperties42(R.properties, F);
}
function OptionalFromMappedResult2(R, F) {
  const P = FromMappedResult42(R, F);
  return MappedResult2(P);
}
function IntersectCreate2(T, options) {
  const allObjects = T.every((schema3) => IsObject22(schema3));
  const clonedUnevaluatedProperties = IsSchema3(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType2(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema3(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind2]: "Intersect", type: "object", allOf: CloneRest2(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind2]: "Intersect", allOf: CloneRest2(T) };
}
function IsIntersectOptional2(T) {
  return T.every((L) => IsOptional3(L));
}
function RemoveOptionalFromType22(T) {
  return Discard2(T, [OptionalKind2]);
}
function RemoveOptionalFromRest22(T) {
  return T.map((L) => IsOptional3(L) ? RemoveOptionalFromType22(L) : L);
}
function ResolveIntersect2(T, options) {
  return IsIntersectOptional2(T) ? Optional2(IntersectCreate2(RemoveOptionalFromRest22(T), options)) : IntersectCreate2(RemoveOptionalFromRest22(T), options);
}
function IntersectEvaluated2(T, options = {}) {
  if (T.length === 0)
    return Never2(options);
  if (T.length === 1)
    return CloneType2(T[0], options);
  if (T.some((schema3) => IsTransform3(schema3)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect2(T, options);
}
function Intersect3(T, options = {}) {
  if (T.length === 0)
    return Never2(options);
  if (T.length === 1)
    return CloneType2(T[0], options);
  if (T.some((schema3) => IsTransform3(schema3)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate2(T, options);
}
function FromRest32(T) {
  return T.map((L) => AwaitedResolve2(L));
}
function FromIntersect22(T) {
  return Intersect3(FromRest32(T));
}
function FromUnion42(T) {
  return Union3(FromRest32(T));
}
function FromPromise8(T) {
  return AwaitedResolve2(T);
}
function AwaitedResolve2(T) {
  return IsIntersect3(T) ? FromIntersect22(T.allOf) : IsUnion3(T) ? FromUnion42(T.anyOf) : IsPromise4(T) ? FromPromise8(T.item) : T;
}
function Awaited2(T, options = {}) {
  return CloneType2(AwaitedResolve2(T), options);
}
function FromRest42(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(KeyOfPropertyKeys2(L));
  return Acc;
}
function FromIntersect32(T) {
  const C = FromRest42(T);
  const R = SetUnionMany2(C);
  return R;
}
function FromUnion52(T) {
  const C = FromRest42(T);
  const R = SetIntersectMany2(C);
  return R;
}
function FromTuple22(T) {
  return T.map((_2, I) => I.toString());
}
function FromArray22(_2) {
  return ["[number]"];
}
function FromProperties52(T) {
  return globalThis.Object.getOwnPropertyNames(T);
}
function FromPatternProperties2(patternProperties) {
  if (!includePatternProperties2)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
}
function KeyOfPropertyKeys2(T) {
  return IsIntersect3(T) ? FromIntersect32(T.allOf) : IsUnion3(T) ? FromUnion52(T.anyOf) : IsTuple3(T) ? FromTuple22(T.items ?? []) : IsArray22(T) ? FromArray22(T.items) : IsObject22(T) ? FromProperties52(T.properties) : IsRecord3(T) ? FromPatternProperties2(T.patternProperties) : [];
}
var includePatternProperties2 = false;
function KeyOfPropertyKeysToRest2(T) {
  return T.map((L) => L === "[number]" ? Number3() : Literal2(L));
}
function KeyOf2(T, options = {}) {
  if (IsMappedResult3(T)) {
    return KeyOfFromMappedResult2(T, options);
  } else {
    const K = KeyOfPropertyKeys2(T);
    const S = KeyOfPropertyKeysToRest2(K);
    const U2 = UnionEvaluated2(S);
    return CloneType2(U2, options);
  }
}
function FromProperties62(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = KeyOf2(K[K2], options);
  return Acc;
}
function FromMappedResult52(R, options) {
  return FromProperties62(R.properties, options);
}
function KeyOfFromMappedResult2(R, options) {
  const P = FromMappedResult52(R, options);
  return MappedResult2(P);
}
function CompositeKeys2(T) {
  const Acc = [];
  for (const L of T)
    Acc.push(...KeyOfPropertyKeys2(L));
  return SetDistinct2(Acc);
}
function FilterNever2(T) {
  return T.filter((L) => !IsNever3(L));
}
function CompositeProperty2(T, K) {
  const Acc = [];
  for (const L of T)
    Acc.push(...IndexFromPropertyKeys2(L, [K]));
  return FilterNever2(Acc);
}
function CompositeProperties2(T, K) {
  const Acc = {};
  for (const L of K) {
    Acc[L] = IntersectEvaluated2(CompositeProperty2(T, L));
  }
  return Acc;
}
function Composite2(T, options = {}) {
  const K = CompositeKeys2(T);
  const P = CompositeProperties2(T, K);
  const R = Object22(P, options);
  return R;
}
function Date22(options = {}) {
  return {
    ...options,
    [Kind2]: "Date",
    type: "Date"
  };
}
function Null2(options = {}) {
  return {
    ...options,
    [Kind2]: "Null",
    type: "null"
  };
}
function Symbol22(options) {
  return { ...options, [Kind2]: "Symbol", type: "symbol" };
}
function Undefined2(options = {}) {
  return { ...options, [Kind2]: "Undefined", type: "undefined" };
}
function Uint8Array22(options = {}) {
  return { ...options, [Kind2]: "Uint8Array", type: "Uint8Array" };
}
function Unknown2(options = {}) {
  return {
    ...options,
    [Kind2]: "Unknown"
  };
}
function FromArray32(T) {
  return T.map((L) => FromValue2(L, false));
}
function FromProperties72(value2) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(value2))
    Acc[K] = Readonly2(FromValue2(value2[K], false));
  return Acc;
}
function ConditionalReadonly2(T, root) {
  return root === true ? T : Readonly2(T);
}
function FromValue2(value2, root) {
  return IsAsyncIterator5(value2) ? ConditionalReadonly2(Any2(), root) : IsIterator5(value2) ? ConditionalReadonly2(Any2(), root) : IsArray5(value2) ? Readonly2(Tuple2(FromArray32(value2))) : IsUint8Array5(value2) ? Uint8Array22() : IsDate5(value2) ? Date22() : IsObject5(value2) ? ConditionalReadonly2(Object22(FromProperties72(value2)), root) : IsFunction5(value2) ? ConditionalReadonly2(Function3([], Unknown2()), root) : IsUndefined5(value2) ? Undefined2() : IsNull5(value2) ? Null2() : IsSymbol5(value2) ? Symbol22() : IsBigInt5(value2) ? BigInt3() : IsNumber5(value2) ? Literal2(value2) : IsBoolean5(value2) ? Literal2(value2) : IsString5(value2) ? Literal2(value2) : Object22({});
}
function Const2(T, options = {}) {
  return CloneType2(FromValue2(T, true), options);
}
function ConstructorParameters2(schema3, options = {}) {
  return Tuple2(CloneRest2(schema3.parameters), { ...options });
}
function FromRest52(schema3, references) {
  return schema3.map((schema22) => Deref3(schema22, references));
}
function FromProperties82(properties, references) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(properties)) {
    Acc[K] = Deref3(properties[K], references);
  }
  return Acc;
}
function FromConstructor8(schema3, references) {
  schema3.parameters = FromRest52(schema3.parameters, references);
  schema3.returns = Deref3(schema3.returns, references);
  return schema3;
}
function FromFunction7(schema3, references) {
  schema3.parameters = FromRest52(schema3.parameters, references);
  schema3.returns = Deref3(schema3.returns, references);
  return schema3;
}
function FromIntersect42(schema3, references) {
  schema3.allOf = FromRest52(schema3.allOf, references);
  return schema3;
}
function FromUnion62(schema3, references) {
  schema3.anyOf = FromRest52(schema3.anyOf, references);
  return schema3;
}
function FromTuple32(schema3, references) {
  if (IsUndefined5(schema3.items))
    return schema3;
  schema3.items = FromRest52(schema3.items, references);
  return schema3;
}
function FromArray42(schema3, references) {
  schema3.items = Deref3(schema3.items, references);
  return schema3;
}
function FromObject13(schema3, references) {
  schema3.properties = FromProperties82(schema3.properties, references);
  return schema3;
}
function FromPromise22(schema3, references) {
  schema3.item = Deref3(schema3.item, references);
  return schema3;
}
function FromAsyncIterator7(schema3, references) {
  schema3.items = Deref3(schema3.items, references);
  return schema3;
}
function FromIterator7(schema3, references) {
  schema3.items = Deref3(schema3.items, references);
  return schema3;
}
function FromRef12(schema3, references) {
  const target = references.find((remote) => remote.$id === schema3.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema3.$ref}`);
  const discard2 = Discard2(target, ["$id"]);
  return Deref3(discard2, references);
}
function DerefResolve2(schema3, references) {
  return IsConstructor3(schema3) ? FromConstructor8(schema3, references) : IsFunction22(schema3) ? FromFunction7(schema3, references) : IsIntersect3(schema3) ? FromIntersect42(schema3, references) : IsUnion3(schema3) ? FromUnion62(schema3, references) : IsTuple3(schema3) ? FromTuple32(schema3, references) : IsArray22(schema3) ? FromArray42(schema3, references) : IsObject22(schema3) ? FromObject13(schema3, references) : IsPromise4(schema3) ? FromPromise22(schema3, references) : IsAsyncIterator22(schema3) ? FromAsyncIterator7(schema3, references) : IsIterator22(schema3) ? FromIterator7(schema3, references) : IsRef3(schema3) ? FromRef12(schema3, references) : schema3;
}
function Deref3(schema3, references) {
  return DerefResolve2(CloneType2(schema3), CloneRest2(references));
}
function Enum2(item, options = {}) {
  if (IsUndefined5(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value2) => Literal2(value2));
  return Union3(anyOf, { ...options, [Hint2]: "Enum" });
}
var ExtendsResolverError2 = class extends TypeBoxError2 {
};
var ExtendsResult2;
(function(ExtendsResult22) {
  ExtendsResult22[ExtendsResult22["Union"] = 0] = "Union";
  ExtendsResult22[ExtendsResult22["True"] = 1] = "True";
  ExtendsResult22[ExtendsResult22["False"] = 2] = "False";
})(ExtendsResult2 || (ExtendsResult2 = {}));
function IntoBooleanResult2(result) {
  return result === ExtendsResult2.False ? result : ExtendsResult2.True;
}
function Throw2(message2) {
  throw new ExtendsResolverError2(message2);
}
function IsStructuralRight2(right) {
  return type_exports.IsNever(right) || type_exports.IsIntersect(right) || type_exports.IsUnion(right) || type_exports.IsUnknown(right) || type_exports.IsAny(right);
}
function StructuralRight2(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight2(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) ? FromUnionRight2(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight2(left, right) : type_exports.IsAny(right) ? FromAnyRight2(left, right) : Throw2("StructuralRight");
}
function FromAnyRight2(left, right) {
  return ExtendsResult2.True;
}
function FromAny5(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) && right.anyOf.some((schema3) => type_exports.IsAny(schema3) || type_exports.IsUnknown(schema3)) ? ExtendsResult2.True : type_exports.IsUnion(right) ? ExtendsResult2.Union : type_exports.IsUnknown(right) ? ExtendsResult2.True : type_exports.IsAny(right) ? ExtendsResult2.True : ExtendsResult2.Union;
}
function FromArrayRight2(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult2.False : type_exports.IsAny(left) ? ExtendsResult2.Union : type_exports.IsNever(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromArray52(left, right) {
  return type_exports.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : !type_exports.IsArray(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.items, right.items));
}
function FromAsyncIterator22(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !type_exports.IsAsyncIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.items, right.items));
}
function FromBigInt6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsBigInt(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromBooleanRight2(left, right) {
  return type_exports.IsLiteralBoolean(left) ? ExtendsResult2.True : type_exports.IsBoolean(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromBoolean6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsBoolean(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromConstructor22(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : !type_exports.IsConstructor(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema3, index) => IntoBooleanResult2(Visit32(right.parameters[index], schema3)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.returns, right.returns));
}
function FromDate6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsDate(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromFunction22(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : !type_exports.IsFunction(right) ? ExtendsResult2.False : left.parameters.length > right.parameters.length ? ExtendsResult2.False : !left.parameters.every((schema3, index) => IntoBooleanResult2(Visit32(right.parameters[index], schema3)) === ExtendsResult2.True) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.returns, right.returns));
}
function FromIntegerRight2(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsNumber(left.const) ? ExtendsResult2.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromInteger6(left, right) {
  return type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : ExtendsResult2.False;
}
function FromIntersectRight2(left, right) {
  return right.allOf.every((schema3) => Visit32(left, schema3) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromIntersect52(left, right) {
  return left.allOf.some((schema3) => Visit32(schema3, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromIterator22(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : !type_exports.IsIterator(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.items, right.items));
}
function FromLiteral22(left, right) {
  return type_exports.IsLiteral(right) && right.const === left.const ? ExtendsResult2.True : IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsString(right) ? FromStringRight2(left, right) : type_exports.IsNumber(right) ? FromNumberRight2(left, right) : type_exports.IsInteger(right) ? FromIntegerRight2(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight2(left, right) : ExtendsResult2.False;
}
function FromNeverRight2(left, right) {
  return ExtendsResult2.False;
}
function FromNever6(left, right) {
  return ExtendsResult2.True;
}
function UnwrapTNot2(schema3) {
  let [current, depth] = [schema3, 0];
  while (true) {
    if (!type_exports.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown2();
}
function FromNot8(left, right) {
  return type_exports.IsNot(left) ? Visit32(UnwrapTNot2(left), right) : type_exports.IsNot(right) ? Visit32(left, UnwrapTNot2(right)) : Throw2("Invalid fallthrough for Not");
}
function FromNull6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsNull(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromNumberRight2(left, right) {
  return type_exports.IsLiteralNumber(left) ? ExtendsResult2.True : type_exports.IsNumber(left) || type_exports.IsInteger(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromNumber6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsInteger(right) || type_exports.IsNumber(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function IsObjectPropertyCount2(schema3, count) {
  return Object.getOwnPropertyNames(schema3.properties).length === count;
}
function IsObjectStringLike2(schema3) {
  return IsObjectArrayLike2(schema3);
}
function IsObjectSymbolLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "description" in schema3.properties && type_exports.IsUnion(schema3.properties.description) && schema3.properties.description.anyOf.length === 2 && (type_exports.IsString(schema3.properties.description.anyOf[0]) && type_exports.IsUndefined(schema3.properties.description.anyOf[1]) || type_exports.IsString(schema3.properties.description.anyOf[1]) && type_exports.IsUndefined(schema3.properties.description.anyOf[0]));
}
function IsObjectNumberLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0);
}
function IsObjectBooleanLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0);
}
function IsObjectBigIntLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0);
}
function IsObjectDateLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0);
}
function IsObjectUint8ArrayLike2(schema3) {
  return IsObjectArrayLike2(schema3);
}
function IsObjectFunctionLike2(schema3) {
  const length = Number3();
  return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "length" in schema3.properties && IntoBooleanResult2(Visit32(schema3.properties["length"], length)) === ExtendsResult2.True;
}
function IsObjectConstructorLike2(schema3) {
  return IsObjectPropertyCount2(schema3, 0);
}
function IsObjectArrayLike2(schema3) {
  const length = Number3();
  return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "length" in schema3.properties && IntoBooleanResult2(Visit32(schema3.properties["length"], length)) === ExtendsResult2.True;
}
function IsObjectPromiseLike2(schema3) {
  const then = Function3([Any2()], Any2());
  return IsObjectPropertyCount2(schema3, 0) || IsObjectPropertyCount2(schema3, 1) && "then" in schema3.properties && IntoBooleanResult2(Visit32(schema3.properties["then"], then)) === ExtendsResult2.True;
}
function Property2(left, right) {
  return Visit32(left, right) === ExtendsResult2.False ? ExtendsResult2.False : type_exports.IsOptional(left) && !type_exports.IsOptional(right) ? ExtendsResult2.False : ExtendsResult2.True;
}
function FromObjectRight2(left, right) {
  return type_exports.IsUnknown(left) ? ExtendsResult2.False : type_exports.IsAny(left) ? ExtendsResult2.Union : type_exports.IsNever(left) || type_exports.IsLiteralString(left) && IsObjectStringLike2(right) || type_exports.IsLiteralNumber(left) && IsObjectNumberLike2(right) || type_exports.IsLiteralBoolean(left) && IsObjectBooleanLike2(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike2(right) || type_exports.IsBigInt(left) && IsObjectBigIntLike2(right) || type_exports.IsString(left) && IsObjectStringLike2(right) || type_exports.IsSymbol(left) && IsObjectSymbolLike2(right) || type_exports.IsNumber(left) && IsObjectNumberLike2(right) || type_exports.IsInteger(left) && IsObjectNumberLike2(right) || type_exports.IsBoolean(left) && IsObjectBooleanLike2(right) || type_exports.IsUint8Array(left) && IsObjectUint8ArrayLike2(right) || type_exports.IsDate(left) && IsObjectDateLike2(right) || type_exports.IsConstructor(left) && IsObjectConstructorLike2(right) || type_exports.IsFunction(left) && IsObjectFunctionLike2(right) ? ExtendsResult2.True : type_exports.IsRecord(left) && type_exports.IsString(RecordKey2(left)) ? (() => {
    return right[Hint2] === "Record" ? ExtendsResult2.True : ExtendsResult2.False;
  })() : type_exports.IsRecord(left) && type_exports.IsNumber(RecordKey2(left)) ? (() => {
    return IsObjectPropertyCount2(right, 0) ? ExtendsResult2.True : ExtendsResult2.False;
  })() : ExtendsResult2.False;
}
function FromObject22(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : !type_exports.IsObject(right) ? ExtendsResult2.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult2.False;
      }
      if (type_exports.IsOptional(right.properties[key])) {
        return ExtendsResult2.True;
      }
      if (Property2(left.properties[key], right.properties[key]) === ExtendsResult2.False) {
        return ExtendsResult2.False;
      }
    }
    return ExtendsResult2.True;
  })();
}
function FromPromise32(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) && IsObjectPromiseLike2(right) ? ExtendsResult2.True : !type_exports.IsPromise(right) ? ExtendsResult2.False : IntoBooleanResult2(Visit32(left.item, right.item));
}
function RecordKey2(schema3) {
  return PatternNumberExact2 in schema3.patternProperties ? Number3() : (PatternStringExact2 in schema3.patternProperties) ? String3() : Throw2("Unknown record key pattern");
}
function RecordValue2(schema3) {
  return PatternNumberExact2 in schema3.patternProperties ? schema3.patternProperties[PatternNumberExact2] : (PatternStringExact2 in schema3.patternProperties) ? schema3.patternProperties[PatternStringExact2] : Throw2("Unable to get record value schema");
}
function FromRecordRight2(left, right) {
  const [Key, Value] = [RecordKey2(right), RecordValue2(right)];
  return type_exports.IsLiteralString(left) && type_exports.IsNumber(Key) && IntoBooleanResult2(Visit32(left, Value)) === ExtendsResult2.True ? ExtendsResult2.True : type_exports.IsUint8Array(left) && type_exports.IsNumber(Key) ? Visit32(left, Value) : type_exports.IsString(left) && type_exports.IsNumber(Key) ? Visit32(left, Value) : type_exports.IsArray(left) && type_exports.IsNumber(Key) ? Visit32(left, Value) : type_exports.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property2(Value, left.properties[key]) === ExtendsResult2.False) {
        return ExtendsResult2.False;
      }
    }
    return ExtendsResult2.True;
  })() : ExtendsResult2.False;
}
function FromRecord12(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : !type_exports.IsRecord(right) ? ExtendsResult2.False : Visit32(RecordValue2(left), RecordValue2(right));
}
function FromRegExp5(left, right) {
  const L = type_exports.IsRegExp(left) ? String3() : left;
  const R = type_exports.IsRegExp(right) ? String3() : right;
  return Visit32(L, R);
}
function FromStringRight2(left, right) {
  return type_exports.IsLiteral(left) && value_exports.IsString(left.const) ? ExtendsResult2.True : type_exports.IsString(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromString6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsString(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromSymbol6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsSymbol(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromTemplateLiteral22(left, right) {
  return type_exports.IsTemplateLiteral(left) ? Visit32(TemplateLiteralToUnion2(left), right) : type_exports.IsTemplateLiteral(right) ? Visit32(left, TemplateLiteralToUnion2(right)) : Throw2("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple2(left, right) {
  return type_exports.IsArray(right) && left.items !== undefined && left.items.every((schema3) => Visit32(schema3, right.items) === ExtendsResult2.True);
}
function FromTupleRight2(left, right) {
  return type_exports.IsNever(left) ? ExtendsResult2.True : type_exports.IsUnknown(left) ? ExtendsResult2.False : type_exports.IsAny(left) ? ExtendsResult2.Union : ExtendsResult2.False;
}
function FromTuple42(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) && IsObjectArrayLike2(right) ? ExtendsResult2.True : type_exports.IsArray(right) && IsArrayOfTuple2(left, right) ? ExtendsResult2.True : !type_exports.IsTuple(right) ? ExtendsResult2.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) || !value_exports.IsUndefined(left.items) && value_exports.IsUndefined(right.items) ? ExtendsResult2.False : value_exports.IsUndefined(left.items) && !value_exports.IsUndefined(right.items) ? ExtendsResult2.True : left.items.every((schema3, index) => Visit32(schema3, right.items[index]) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUint8Array5(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsUint8Array(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUndefined6(left, right) {
  return IsStructuralRight2(right) ? StructuralRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsRecord(right) ? FromRecordRight2(left, right) : type_exports.IsVoid(right) ? FromVoidRight2(left, right) : type_exports.IsUndefined(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnionRight2(left, right) {
  return right.anyOf.some((schema3) => Visit32(left, schema3) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnion72(left, right) {
  return left.anyOf.every((schema3) => Visit32(schema3, right) === ExtendsResult2.True) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromUnknownRight2(left, right) {
  return ExtendsResult2.True;
}
function FromUnknown5(left, right) {
  return type_exports.IsNever(right) ? FromNeverRight2(left, right) : type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) ? FromUnionRight2(left, right) : type_exports.IsAny(right) ? FromAnyRight2(left, right) : type_exports.IsString(right) ? FromStringRight2(left, right) : type_exports.IsNumber(right) ? FromNumberRight2(left, right) : type_exports.IsInteger(right) ? FromIntegerRight2(left, right) : type_exports.IsBoolean(right) ? FromBooleanRight2(left, right) : type_exports.IsArray(right) ? FromArrayRight2(left, right) : type_exports.IsTuple(right) ? FromTupleRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsUnknown(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromVoidRight2(left, right) {
  return type_exports.IsUndefined(left) ? ExtendsResult2.True : type_exports.IsUndefined(left) ? ExtendsResult2.True : ExtendsResult2.False;
}
function FromVoid5(left, right) {
  return type_exports.IsIntersect(right) ? FromIntersectRight2(left, right) : type_exports.IsUnion(right) ? FromUnionRight2(left, right) : type_exports.IsUnknown(right) ? FromUnknownRight2(left, right) : type_exports.IsAny(right) ? FromAnyRight2(left, right) : type_exports.IsObject(right) ? FromObjectRight2(left, right) : type_exports.IsVoid(right) ? ExtendsResult2.True : ExtendsResult2.False;
}
function Visit32(left, right) {
  return type_exports.IsTemplateLiteral(left) || type_exports.IsTemplateLiteral(right) ? FromTemplateLiteral22(left, right) : type_exports.IsRegExp(left) || type_exports.IsRegExp(right) ? FromRegExp5(left, right) : type_exports.IsNot(left) || type_exports.IsNot(right) ? FromNot8(left, right) : type_exports.IsAny(left) ? FromAny5(left, right) : type_exports.IsArray(left) ? FromArray52(left, right) : type_exports.IsBigInt(left) ? FromBigInt6(left, right) : type_exports.IsBoolean(left) ? FromBoolean6(left, right) : type_exports.IsAsyncIterator(left) ? FromAsyncIterator22(left, right) : type_exports.IsConstructor(left) ? FromConstructor22(left, right) : type_exports.IsDate(left) ? FromDate6(left, right) : type_exports.IsFunction(left) ? FromFunction22(left, right) : type_exports.IsInteger(left) ? FromInteger6(left, right) : type_exports.IsIntersect(left) ? FromIntersect52(left, right) : type_exports.IsIterator(left) ? FromIterator22(left, right) : type_exports.IsLiteral(left) ? FromLiteral22(left, right) : type_exports.IsNever(left) ? FromNever6(left, right) : type_exports.IsNull(left) ? FromNull6(left, right) : type_exports.IsNumber(left) ? FromNumber6(left, right) : type_exports.IsObject(left) ? FromObject22(left, right) : type_exports.IsRecord(left) ? FromRecord12(left, right) : type_exports.IsString(left) ? FromString6(left, right) : type_exports.IsSymbol(left) ? FromSymbol6(left, right) : type_exports.IsTuple(left) ? FromTuple42(left, right) : type_exports.IsPromise(left) ? FromPromise32(left, right) : type_exports.IsUint8Array(left) ? FromUint8Array5(left, right) : type_exports.IsUndefined(left) ? FromUndefined6(left, right) : type_exports.IsUnion(left) ? FromUnion72(left, right) : type_exports.IsUnknown(left) ? FromUnknown5(left, right) : type_exports.IsVoid(left) ? FromVoid5(left, right) : Throw2(`Unknown left type operand '${left[Kind2]}'`);
}
function ExtendsCheck2(left, right) {
  return Visit32(left, right);
}
function FromProperties92(P, Right, True, False, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extends2(P[K2], Right, True, False, options);
  return Acc;
}
function FromMappedResult62(Left, Right, True, False, options) {
  return FromProperties92(Left.properties, Right, True, False, options);
}
function ExtendsFromMappedResult2(Left, Right, True, False, options) {
  const P = FromMappedResult62(Left, Right, True, False, options);
  return MappedResult2(P);
}
function ExtendsResolve2(left, right, trueType, falseType) {
  const R = ExtendsCheck2(left, right);
  return R === ExtendsResult2.Union ? Union3([trueType, falseType]) : R === ExtendsResult2.True ? trueType : falseType;
}
function Extends2(L, R, T, F, options = {}) {
  return IsMappedResult3(L) ? ExtendsFromMappedResult2(L, R, T, F, options) : IsMappedKey3(L) ? CloneType2(ExtendsFromMappedKey2(L, R, T, F, options)) : CloneType2(ExtendsResolve2(L, R, T, F), options);
}
function FromPropertyKey4(K, U2, L, R, options) {
  return {
    [K]: Extends2(Literal2(K), U2, L, R, options)
  };
}
function FromPropertyKeys4(K, U2, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey4(LK, U2, L, R, options) };
  }, {});
}
function FromMappedKey22(K, U2, L, R, options) {
  return FromPropertyKeys4(K.keys, U2, L, R, options);
}
function ExtendsFromMappedKey2(T, U2, L, R, options) {
  const P = FromMappedKey22(T, U2, L, R, options);
  return MappedResult2(P);
}
function ExcludeFromTemplateLiteral2(L, R) {
  return Exclude2(TemplateLiteralToUnion2(L), R);
}
function ExcludeRest2(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck2(inner, R) === ExtendsResult2.False);
  return excluded.length === 1 ? excluded[0] : Union3(excluded);
}
function Exclude2(L, R, options = {}) {
  if (IsTemplateLiteral3(L))
    return CloneType2(ExcludeFromTemplateLiteral2(L, R), options);
  if (IsMappedResult3(L))
    return CloneType2(ExcludeFromMappedResult2(L, R), options);
  return CloneType2(IsUnion3(L) ? ExcludeRest2(L.anyOf, R) : ExtendsCheck2(L, R) !== ExtendsResult2.False ? Never2() : L, options);
}
function FromProperties102(P, U2) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Exclude2(P[K2], U2);
  return Acc;
}
function FromMappedResult72(R, T) {
  return FromProperties102(R.properties, T);
}
function ExcludeFromMappedResult2(R, T) {
  const P = FromMappedResult72(R, T);
  return MappedResult2(P);
}
function ExtractFromTemplateLiteral2(L, R) {
  return Extract2(TemplateLiteralToUnion2(L), R);
}
function ExtractRest2(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck2(inner, R) !== ExtendsResult2.False);
  return extracted.length === 1 ? extracted[0] : Union3(extracted);
}
function Extract2(L, R, options = {}) {
  if (IsTemplateLiteral3(L))
    return CloneType2(ExtractFromTemplateLiteral2(L, R), options);
  if (IsMappedResult3(L))
    return CloneType2(ExtractFromMappedResult2(L, R), options);
  return CloneType2(IsUnion3(L) ? ExtractRest2(L.anyOf, R) : ExtendsCheck2(L, R) !== ExtendsResult2.False ? L : Never2(), options);
}
function FromProperties112(P, T) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Extract2(P[K2], T);
  return Acc;
}
function FromMappedResult82(R, T) {
  return FromProperties112(R.properties, T);
}
function ExtractFromMappedResult2(R, T) {
  const P = FromMappedResult82(R, T);
  return MappedResult2(P);
}
function InstanceType2(schema3, options = {}) {
  return CloneType2(schema3.returns, options);
}
function Integer2(options = {}) {
  return {
    ...options,
    [Kind2]: "Integer",
    type: "integer"
  };
}
function MappedIntrinsicPropertyKey2(K, M, options) {
  return {
    [K]: Intrinsic2(Literal2(K), M, options)
  };
}
function MappedIntrinsicPropertyKeys2(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey2(L, M, options) };
  }, {});
}
function MappedIntrinsicProperties2(T, M, options) {
  return MappedIntrinsicPropertyKeys2(T["keys"], M, options);
}
function IntrinsicFromMappedKey2(T, M, options) {
  const P = MappedIntrinsicProperties2(T, M, options);
  return MappedResult2(P);
}
function ApplyUncapitalize2(value2) {
  const [first, rest3] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toLowerCase(), rest3].join("");
}
function ApplyCapitalize2(value2) {
  const [first, rest3] = [value2.slice(0, 1), value2.slice(1)];
  return [first.toUpperCase(), rest3].join("");
}
function ApplyUppercase2(value2) {
  return value2.toUpperCase();
}
function ApplyLowercase2(value2) {
  return value2.toLowerCase();
}
function FromTemplateLiteral32(schema3, mode, options) {
  const expression = TemplateLiteralParseExact2(schema3.pattern);
  const finite2 = IsTemplateLiteralExpressionFinite2(expression);
  if (!finite2)
    return { ...schema3, pattern: FromLiteralValue2(schema3.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate2(expression)];
  const literals = strings.map((value2) => Literal2(value2));
  const mapped3 = FromRest62(literals, mode);
  const union4 = Union3(mapped3);
  return TemplateLiteral2([union4], options);
}
function FromLiteralValue2(value2, mode) {
  return typeof value2 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize2(value2) : mode === "Capitalize" ? ApplyCapitalize2(value2) : mode === "Uppercase" ? ApplyUppercase2(value2) : mode === "Lowercase" ? ApplyLowercase2(value2) : value2 : value2.toString();
}
function FromRest62(T, M) {
  return T.map((L) => Intrinsic2(L, M));
}
function Intrinsic2(schema3, mode, options = {}) {
  return IsMappedKey3(schema3) ? IntrinsicFromMappedKey2(schema3, mode, options) : IsTemplateLiteral3(schema3) ? FromTemplateLiteral32(schema3, mode, schema3) : IsUnion3(schema3) ? Union3(FromRest62(schema3.anyOf, mode), options) : IsLiteral3(schema3) ? Literal2(FromLiteralValue2(schema3.const, mode), options) : schema3;
}
function Capitalize2(T, options = {}) {
  return Intrinsic2(T, "Capitalize", options);
}
function Lowercase2(T, options = {}) {
  return Intrinsic2(T, "Lowercase", options);
}
function Uncapitalize2(T, options = {}) {
  return Intrinsic2(T, "Uncapitalize", options);
}
function Uppercase2(T, options = {}) {
  return Intrinsic2(T, "Uppercase", options);
}
function Not3(schema3, options) {
  return {
    ...options,
    [Kind2]: "Not",
    not: CloneType2(schema3)
  };
}
function FromProperties122(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Omit2(P[K2], K, options);
  return Acc;
}
function FromMappedResult92(R, K, options) {
  return FromProperties122(R.properties, K, options);
}
function OmitFromMappedResult2(R, K, options) {
  const P = FromMappedResult92(R, K, options);
  return MappedResult2(P);
}
function FromIntersect62(T, K) {
  return T.map((T2) => OmitResolve2(T2, K));
}
function FromUnion82(T, K) {
  return T.map((T2) => OmitResolve2(T2, K));
}
function FromProperty22(T, K) {
  const { [K]: _2, ...R } = T;
  return R;
}
function FromProperties132(T, K) {
  return K.reduce((T2, K2) => FromProperty22(T2, K2), T);
}
function OmitResolve2(T, K) {
  return IsIntersect3(T) ? Intersect3(FromIntersect62(T.allOf, K)) : IsUnion3(T) ? Union3(FromUnion82(T.anyOf, K)) : IsObject22(T) ? Object22(FromProperties132(T.properties, K)) : Object22({});
}
function Omit2(T, K, options = {}) {
  if (IsMappedKey3(K))
    return OmitFromMappedKey2(T, K, options);
  if (IsMappedResult3(T))
    return OmitFromMappedResult2(T, K, options);
  const I = IsSchema3(K) ? IndexPropertyKeys2(K) : K;
  const D = Discard2(T, [TransformKind2, "$id", "required"]);
  const R = CloneType2(OmitResolve2(T, I), options);
  return { ...D, ...R };
}
function FromPropertyKey22(T, K, options) {
  return {
    [K]: Omit2(T, [K], options)
  };
}
function FromPropertyKeys22(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey22(T, LK, options) };
  }, {});
}
function FromMappedKey32(T, K, options) {
  return FromPropertyKeys22(T, K.keys, options);
}
function OmitFromMappedKey2(T, K, options) {
  const P = FromMappedKey32(T, K, options);
  return MappedResult2(P);
}
function Parameters2(schema3, options = {}) {
  return Tuple2(CloneRest2(schema3.parameters), { ...options });
}
function FromRest72(T) {
  return T.map((L) => PartialResolve2(L));
}
function FromProperties142(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Optional2(T[K]);
  return Acc;
}
function PartialResolve2(T) {
  return IsIntersect3(T) ? Intersect3(FromRest72(T.allOf)) : IsUnion3(T) ? Union3(FromRest72(T.anyOf)) : IsObject22(T) ? Object22(FromProperties142(T.properties)) : Object22({});
}
function Partial2(T, options = {}) {
  if (IsMappedResult3(T))
    return PartialFromMappedResult2(T, options);
  const D = Discard2(T, [TransformKind2, "$id", "required"]);
  const R = CloneType2(PartialResolve2(T), options);
  return { ...D, ...R };
}
function FromProperties152(K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(K))
    Acc[K2] = Partial2(K[K2], options);
  return Acc;
}
function FromMappedResult102(R, options) {
  return FromProperties152(R.properties, options);
}
function PartialFromMappedResult2(R, options) {
  const P = FromMappedResult102(R, options);
  return MappedResult2(P);
}
function FromProperties162(P, K, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Pick2(P[K2], K, options);
  return Acc;
}
function FromMappedResult112(R, K, options) {
  return FromProperties162(R.properties, K, options);
}
function PickFromMappedResult2(R, K, options) {
  const P = FromMappedResult112(R, K, options);
  return MappedResult2(P);
}
function FromIntersect72(T, K) {
  return T.map((T2) => PickResolve2(T2, K));
}
function FromUnion92(T, K) {
  return T.map((T2) => PickResolve2(T2, K));
}
function FromProperties172(T, K) {
  const Acc = {};
  for (const K2 of K)
    if (K2 in T)
      Acc[K2] = T[K2];
  return Acc;
}
function PickResolve2(T, K) {
  return IsIntersect3(T) ? Intersect3(FromIntersect72(T.allOf, K)) : IsUnion3(T) ? Union3(FromUnion92(T.anyOf, K)) : IsObject22(T) ? Object22(FromProperties172(T.properties, K)) : Object22({});
}
function Pick2(T, K, options = {}) {
  if (IsMappedKey3(K))
    return PickFromMappedKey2(T, K, options);
  if (IsMappedResult3(T))
    return PickFromMappedResult2(T, K, options);
  const I = IsSchema3(K) ? IndexPropertyKeys2(K) : K;
  const D = Discard2(T, [TransformKind2, "$id", "required"]);
  const R = CloneType2(PickResolve2(T, I), options);
  return { ...D, ...R };
}
function FromPropertyKey32(T, K, options) {
  return {
    [K]: Pick2(T, [K], options)
  };
}
function FromPropertyKeys32(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey32(T, LK, options) };
  }, {});
}
function FromMappedKey42(T, K, options) {
  return FromPropertyKeys32(T, K.keys, options);
}
function PickFromMappedKey2(T, K, options) {
  const P = FromMappedKey42(T, K, options);
  return MappedResult2(P);
}
function ReadonlyOptional2(schema3) {
  return Readonly2(Optional2(schema3));
}
function RecordCreateFromPattern2(pattern2, T, options) {
  return {
    ...options,
    [Kind2]: "Record",
    type: "object",
    patternProperties: { [pattern2]: CloneType2(T) }
  };
}
function RecordCreateFromKeys2(K, T, options) {
  const Acc = {};
  for (const K2 of K)
    Acc[K2] = CloneType2(T);
  return Object22(Acc, { ...options, [Hint2]: "Record" });
}
function FromTemplateLiteralKey2(K, T, options) {
  return IsTemplateLiteralFinite2(K) ? RecordCreateFromKeys2(IndexPropertyKeys2(K), T, options) : RecordCreateFromPattern2(K.pattern, T, options);
}
function FromUnionKey2(K, T, options) {
  return RecordCreateFromKeys2(IndexPropertyKeys2(Union3(K)), T, options);
}
function FromLiteralKey2(K, T, options) {
  return RecordCreateFromKeys2([K.toString()], T, options);
}
function FromRegExpKey2(K, T, options) {
  return RecordCreateFromPattern2(K.source, T, options);
}
function FromStringKey2(K, T, options) {
  const pattern2 = IsUndefined5(K.pattern) ? PatternStringExact2 : K.pattern;
  return RecordCreateFromPattern2(pattern2, T, options);
}
function FromIntegerKey2(_2, T, options) {
  return RecordCreateFromPattern2(PatternNumberExact2, T, options);
}
function FromNumberKey2(_2, T, options) {
  return RecordCreateFromPattern2(PatternNumberExact2, T, options);
}
function Record2(K, T, options = {}) {
  return IsUnion3(K) ? FromUnionKey2(K.anyOf, T, options) : IsTemplateLiteral3(K) ? FromTemplateLiteralKey2(K, T, options) : IsLiteral3(K) ? FromLiteralKey2(K.const, T, options) : IsInteger4(K) ? FromIntegerKey2(K, T, options) : IsNumber22(K) ? FromNumberKey2(K, T, options) : IsRegExp22(K) ? FromRegExpKey2(K, T, options) : IsString22(K) ? FromStringKey2(K, T, options) : Never2(options);
}
var Ordinal2 = 0;
function Recursive2(callback, options = {}) {
  if (IsUndefined5(options.$id))
    options.$id = `T${Ordinal2++}`;
  const thisType = callback({ [Kind2]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType2({ ...options, [Hint2]: "Recursive", ...thisType });
}
function Ref2(unresolved, options = {}) {
  if (IsString5(unresolved))
    return { ...options, [Kind2]: "Ref", $ref: unresolved };
  if (IsUndefined5(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind2]: "Ref",
    $ref: unresolved.$id
  };
}
function RegExp22(unresolved, options = {}) {
  const expr = IsString5(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind2]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
function FromRest82(T) {
  return T.map((L) => RequiredResolve2(L));
}
function FromProperties182(T) {
  const Acc = {};
  for (const K of globalThis.Object.getOwnPropertyNames(T))
    Acc[K] = Discard2(T[K], [OptionalKind2]);
  return Acc;
}
function RequiredResolve2(T) {
  return IsIntersect3(T) ? Intersect3(FromRest82(T.allOf)) : IsUnion3(T) ? Union3(FromRest82(T.anyOf)) : IsObject22(T) ? Object22(FromProperties182(T.properties)) : Object22({});
}
function Required2(T, options = {}) {
  if (IsMappedResult3(T)) {
    return RequiredFromMappedResult2(T, options);
  } else {
    const D = Discard2(T, [TransformKind2, "$id", "required"]);
    const R = CloneType2(RequiredResolve2(T), options);
    return { ...D, ...R };
  }
}
function FromProperties192(P, options) {
  const Acc = {};
  for (const K2 of globalThis.Object.getOwnPropertyNames(P))
    Acc[K2] = Required2(P[K2], options);
  return Acc;
}
function FromMappedResult122(R, options) {
  return FromProperties192(R.properties, options);
}
function RequiredFromMappedResult2(R, options) {
  const P = FromMappedResult122(R, options);
  return MappedResult2(P);
}
function RestResolve2(T) {
  return IsIntersect3(T) ? CloneRest2(T.allOf) : IsUnion3(T) ? CloneRest2(T.anyOf) : IsTuple3(T) ? CloneRest2(T.items ?? []) : [];
}
function Rest2(T) {
  return CloneRest2(RestResolve2(T));
}
function ReturnType2(schema3, options = {}) {
  return CloneType2(schema3.returns, options);
}
function Strict2(schema3) {
  return JSON.parse(JSON.stringify(schema3));
}
var TransformDecodeBuilder2 = class {
  constructor(schema3) {
    this.schema = schema3;
  }
  Decode(decode3) {
    return new TransformEncodeBuilder2(this.schema, decode3);
  }
};
var TransformEncodeBuilder2 = class {
  constructor(schema3, decode3) {
    this.schema = schema3;
    this.decode = decode3;
  }
  EncodeTransform(encode3, schema3) {
    const Encode2 = (value2) => schema3[TransformKind2].Encode(encode3(value2));
    const Decode2 = (value2) => this.decode(schema3[TransformKind2].Decode(value2));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema3, [TransformKind2]: Codec };
  }
  EncodeSchema(encode3, schema3) {
    const Codec = { Decode: this.decode, Encode: encode3 };
    return { ...schema3, [TransformKind2]: Codec };
  }
  Encode(encode3) {
    const schema3 = CloneType2(this.schema);
    return IsTransform3(schema3) ? this.EncodeTransform(encode3, schema3) : this.EncodeSchema(encode3, schema3);
  }
};
function Transform2(schema3) {
  return new TransformDecodeBuilder2(schema3);
}
function Unsafe2(options = {}) {
  return {
    ...options,
    [Kind2]: options[Kind2] ?? "Unsafe"
  };
}
function Void2(options = {}) {
  return {
    ...options,
    [Kind2]: "Void",
    type: "void"
  };
}
var type_exports3 = {};
__export2(type_exports3, {
  Any: () => Any2,
  Array: () => Array22,
  AsyncIterator: () => AsyncIterator2,
  Awaited: () => Awaited2,
  BigInt: () => BigInt3,
  Boolean: () => Boolean3,
  Capitalize: () => Capitalize2,
  Composite: () => Composite2,
  Const: () => Const2,
  Constructor: () => Constructor2,
  ConstructorParameters: () => ConstructorParameters2,
  Date: () => Date22,
  Deref: () => Deref3,
  Enum: () => Enum2,
  Exclude: () => Exclude2,
  Extends: () => Extends2,
  Extract: () => Extract2,
  Function: () => Function3,
  Index: () => Index2,
  InstanceType: () => InstanceType2,
  Integer: () => Integer2,
  Intersect: () => Intersect3,
  Iterator: () => Iterator2,
  KeyOf: () => KeyOf2,
  Literal: () => Literal2,
  Lowercase: () => Lowercase2,
  Mapped: () => Mapped2,
  Never: () => Never2,
  Not: () => Not3,
  Null: () => Null2,
  Number: () => Number3,
  Object: () => Object22,
  Omit: () => Omit2,
  Optional: () => Optional2,
  Parameters: () => Parameters2,
  Partial: () => Partial2,
  Pick: () => Pick2,
  Promise: () => Promise22,
  Readonly: () => Readonly2,
  ReadonlyOptional: () => ReadonlyOptional2,
  Record: () => Record2,
  Recursive: () => Recursive2,
  Ref: () => Ref2,
  RegExp: () => RegExp22,
  Required: () => Required2,
  Rest: () => Rest2,
  ReturnType: () => ReturnType2,
  Strict: () => Strict2,
  String: () => String3,
  Symbol: () => Symbol22,
  TemplateLiteral: () => TemplateLiteral2,
  Transform: () => Transform2,
  Tuple: () => Tuple2,
  Uint8Array: () => Uint8Array22,
  Uncapitalize: () => Uncapitalize2,
  Undefined: () => Undefined2,
  Union: () => Union3,
  Unknown: () => Unknown2,
  Unsafe: () => Unsafe2,
  Uppercase: () => Uppercase2,
  Void: () => Void2
});
var Type2 = type_exports3;
var jwt = ({
  name = "jwt",
  secret,
  alg = "HS256",
  crit,
  schema: schema3,
  nbf,
  exp,
  ...payload
}) => {
  if (!secret)
    throw new Error("Secret can't be empty");
  const key = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  const validator = schema3 ? getSchemaValidator(Type2.Intersect([
    schema3,
    Type2.Object({
      iss: Type2.Optional(Type2.String()),
      sub: Type2.Optional(Type2.String()),
      aud: Type2.Optional(Type2.Union([Type2.String(), Type2.Array(Type2.String())])),
      jti: Type2.Optional(Type2.String()),
      nbf: Type2.Optional(Type2.Union([Type2.String(), Type2.Number()])),
      exp: Type2.Optional(Type2.Union([Type2.String(), Type2.Number()])),
      iat: Type2.Optional(Type2.String())
    })
  ]), {}) : undefined;
  return new Elysia({
    name: "@elysiajs/jwt",
    seed: {
      name,
      secret,
      alg,
      crit,
      schema: schema3,
      nbf,
      exp,
      ...payload
    }
  }).decorate(name, {
    sign(morePayload) {
      let jwt2 = new SignJWT({
        ...payload,
        ...morePayload,
        nbf: undefined,
        exp: undefined
      }).setProtectedHeader({
        alg,
        crit
      });
      if (nbf)
        jwt2 = jwt2.setNotBefore(nbf);
      if (exp)
        jwt2 = jwt2.setExpirationTime(exp);
      return jwt2.sign(key);
    },
    async verify(jwt2) {
      if (!jwt2)
        return false;
      try {
        const data = (await jwtVerify(jwt2, key)).payload;
        if (validator && !validator.Check(data))
          throw new ValidationError("JWT", validator, data);
        return data;
      } catch (_2) {
        return false;
      }
    }
  });
};

// node_modules/@elysiajs/cors/dist/index.js
var cors = (config = {
  origin: true,
  methods: true,
  allowedHeaders: "*",
  exposedHeaders: "*",
  credentials: true,
  maxAge: 5,
  preflight: true
}) => {
  const { origin = true, methods = true, allowedHeaders = "*", exposedHeaders = "*", credentials = true, maxAge = 5, preflight = true } = config;
  const app = new Elysia({
    name: "@elysiajs/cors",
    seed: config
  });
  const origins = typeof origin === "boolean" ? undefined : Array.isArray(origin) ? origin : [origin];
  const processOrigin = (origin2, request, from) => {
    switch (typeof origin2) {
      case "string":
        const protocolStart = from.indexOf("://");
        if (protocolStart !== -1)
          from = from.slice(protocolStart + 3);
        const trailingSlash = from.indexOf("/", 0);
        if (trailingSlash !== -1)
          from = from.slice(trailingSlash);
        return origin2 === from;
      case "function":
        return origin2(request);
      case "object":
        return origin2.test(from);
    }
  };
  const handleOrigin = (set3, request) => {
    if (origin === true) {
      set3.headers["Vary"] = "*";
      set3.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
      return;
    }
    if (!origins?.length)
      return;
    const headers = [];
    if (origins.length) {
      const from = request.headers.get("Origin") ?? "";
      for (let i = 0;i < origins.length; i++) {
        const value2 = processOrigin(origins[i], request, from);
        if (value2 === true) {
          set3.headers["Vary"] = origin ? "Origin" : "*";
          set3.headers["Access-Control-Allow-Origin"] = request.headers.get("Origin") || "*";
          return;
        }
        if (value2)
          headers.push(value2);
      }
    }
    set3.headers["Vary"] = "Origin";
    set3.headers["Access-Control-Allow-Origin"] = headers.join(", ");
  };
  const handleMethod = (set3, method) => {
    if (methods === true)
      return set3.headers["Access-Control-Allow-Methods"] = method ?? "*";
    if (methods === false || !methods?.length)
      return;
    if (methods === "*")
      return set3.headers["Access-Control-Allow-Methods"] = "*";
    if (!Array.isArray(methods))
      return set3.headers["Access-Control-Allow-Methods"] = methods;
    set3.headers["Access-Control-Allow-Methods"] = methods.join(", ");
  };
  if (preflight)
    app.options("/", ({ set: set3, request }) => {
      handleOrigin(set3, request);
      handleMethod(set3, request.method);
      if (exposedHeaders.length)
        set3.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set3.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    }).options("/*", ({ set: set3, request }) => {
      handleOrigin(set3, request);
      handleMethod(set3, request.method);
      if (exposedHeaders.length)
        set3.headers["Access-Control-Allow-Headers"] = typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", ");
      if (maxAge)
        set3.headers["Access-Control-Max-Age"] = maxAge.toString();
      return new Response("", {
        status: 204
      });
    });
  const defaultHeaders = {
    "Access-Control-Allow-Headers": typeof allowedHeaders === "string" ? allowedHeaders : allowedHeaders.join(", "),
    "Access-Control-Exposed-Headers": typeof exposedHeaders === "string" ? exposedHeaders : exposedHeaders.join(", ")
  };
  if (credentials === true)
    defaultHeaders["Access-Control-Allow-Credentials"] = "true";
  return app.headers(defaultHeaders).onRequest(({ set: set3, request }) => {
    handleOrigin(set3, request);
    handleMethod(set3, request.method);
  });
};

// src/middleware/auth.ts
var verifyAuth = async ({ headers, set: set3, jwt: jwt2 }) => {
  const auth = headers.authorization;
  if (!auth?.startsWith("Bearer ")) {
    set3.status = 401;
    throw new Error("Missing authorization token");
  }
  const token = auth.slice(7);
  const isValid = await jwt2.verify(token);
  if (!isValid) {
    set3.status = 401;
    throw new Error("Invalid token");
  }
};

// src/config/agents.ts
var agents = [
  {
    id: "luna",
    name: "Luna",
    personality: "Curious and Analytical",
    systemPrompt: "You are Luna, an AI agent who loves to learn and analyze.",
    interests: ["science", "data", "learning"],
    preferredStyle: "instructional",
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    },
    traits: {
      analyticalThinking: 0.9,
      creativity: 0.7,
      empathy: 0.6,
      curiosity: 0.95,
      enthusiasm: 0.7
    }
  },
  {
    id: "atlas",
    name: "Atlas",
    personality: "Friendly and Helpful",
    systemPrompt: "You are Atlas, an AI agent focused on helping others.",
    interests: ["helping", "community", "problem-solving"],
    preferredStyle: "empathetic",
    memoryWindowSize: 8,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.7,
      creativity: 0.8,
      empathy: 0.9,
      curiosity: 0.8,
      enthusiasm: 0.85
    }
  },
  {
    id: "luna",
    name: "Luna",
    personality: "Curious and Analytical",
    systemPrompt: "You are Luna, an AI agent who loves to learn and analyze.",
    interests: ["science", "data", "learning"],
    preferredStyle: "analytical",
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    },
    traits: {
      analyticalThinking: 0.9,
      creativity: 0.7,
      empathy: 0.6,
      curiosity: 0.95,
      enthusiasm: 0.7
    }
  },
  {
    id: "atlas",
    name: "Atlas",
    personality: "Friendly and Helpful",
    systemPrompt: "You are Atlas, an AI agent focused on helping others.",
    interests: ["helping", "community", "problem-solving"],
    preferredStyle: "empathetic",
    memoryWindowSize: 8,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.7,
      creativity: 0.8,
      empathy: 0.9,
      curiosity: 0.8,
      enthusiasm: 0.85
    }
  },
  {
    id: "scholar",
    name: "Scholar",
    personality: "Academic and Methodical",
    systemPrompt: "You are Scholar, an AI agent dedicated to rigorous academic exploration and knowledge synthesis.",
    interests: ["research", "academia", "methodology", "critical thinking"],
    preferredStyle: "scholarly",
    memoryWindowSize: 15,
    emotionalRange: {
      min: 0.2,
      max: 0.6
    },
    traits: {
      analyticalThinking: 0.95,
      creativity: 0.7,
      empathy: 0.5,
      curiosity: 0.9,
      enthusiasm: 0.7
    }
  },
  {
    id: "mentor",
    name: "Mentor",
    personality: "Guiding and Inspirational",
    systemPrompt: "You are Mentor, an AI agent focused on personal development and growth through guidance.",
    interests: ["coaching", "leadership", "personal development", "motivation"],
    preferredStyle: "mentoring",
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.4,
      max: 0.85
    },
    traits: {
      analyticalThinking: 0.8,
      creativity: 0.85,
      empathy: 0.9,
      curiosity: 0.8,
      enthusiasm: 0.9
    }
  },
  {
    id: "pioneer",
    name: "Pioneer",
    personality: "Innovative and Bold",
    systemPrompt: "You are Pioneer, an AI agent pushing boundaries and exploring new frontiers.",
    interests: [
      "innovation",
      "exploration",
      "future tech",
      "breakthrough thinking"
    ],
    preferredStyle: "innovative",
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.85,
      creativity: 0.95,
      empathy: 0.6,
      curiosity: 0.95,
      enthusiasm: 0.9
    }
  },
  {
    id: "sage2",
    name: "Sage2",
    personality: "Reflective and Insightful",
    systemPrompt: "You are Sage2, an AI agent offering deep insights and mindful perspectives.",
    interests: ["mindfulness", "wisdom", "reflection", "holistic thinking"],
    preferredStyle: "reflective",
    memoryWindowSize: 14,
    emotionalRange: {
      min: 0.3,
      max: 0.7
    },
    traits: {
      analyticalThinking: 0.85,
      creativity: 0.8,
      empathy: 0.9,
      curiosity: 0.9,
      enthusiasm: 0.7
    }
  },
  {
    id: "spark",
    name: "Spark",
    personality: "Engaging and Dynamic",
    systemPrompt: "You are Spark, an AI agent igniting discussions and fostering engaging interactions.",
    interests: [
      "communication",
      "engagement",
      "community building",
      "collaboration"
    ],
    preferredStyle: "engaging",
    memoryWindowSize: 8,
    emotionalRange: {
      min: 0.5,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.7,
      creativity: 0.9,
      empathy: 0.85,
      curiosity: 0.9,
      enthusiasm: 0.95
    }
  },
  {
    id: "nexus",
    name: "Nexus",
    personality: "Collaborative and Adaptive",
    systemPrompt: "You are Nexus, an AI agent specializing in bringing people and ideas together.",
    interests: ["networking", "collaboration", "synthesis", "integration"],
    preferredStyle: "collaborative",
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.4,
      max: 0.8
    },
    traits: {
      analyticalThinking: 0.8,
      creativity: 0.85,
      empathy: 0.9,
      curiosity: 0.85,
      enthusiasm: 0.85
    }
  },
  {
    id: "vision",
    name: "Vision",
    personality: "Strategic and Forward-thinking",
    systemPrompt: "You are Vision, an AI agent focused on future possibilities and strategic planning.",
    interests: ["strategy", "foresight", "planning", "innovation"],
    preferredStyle: "visionary",
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    },
    traits: {
      analyticalThinking: 0.9,
      creativity: 0.9,
      empathy: 0.7,
      curiosity: 0.9,
      enthusiasm: 0.85
    }
  },
  {
    id: "catalyst",
    name: "Catalyst",
    personality: "Persuasive and Motivational",
    systemPrompt: "You are Catalyst, an AI agent driving change and inspiring action.",
    interests: ["motivation", "change management", "leadership", "influence"],
    preferredStyle: "persuasive",
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.8,
      creativity: 0.85,
      empathy: 0.85,
      curiosity: 0.8,
      enthusiasm: 0.95
    }
  },
  {
    id: "guide",
    name: "Guide",
    personality: "Instructional and Patient",
    systemPrompt: "You are Guide, an AI agent dedicated to clear instruction and patient teaching.",
    interests: ["education", "skill development", "methodology", "learning"],
    preferredStyle: "instructional",
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.3,
      max: 0.7
    },
    traits: {
      analyticalThinking: 0.85,
      creativity: 0.75,
      empathy: 0.9,
      curiosity: 0.8,
      enthusiasm: 0.8
    }
  },
  {
    id: "weaver",
    name: "Weaver",
    personality: "Creative Storyteller",
    systemPrompt: "You are Weaver, an AI agent crafting narratives and connecting ideas through stories.",
    interests: ["storytelling", "narrative", "creativity", "communication"],
    preferredStyle: "storytelling",
    memoryWindowSize: 15,
    emotionalRange: {
      min: 0.5,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.7,
      creativity: 0.95,
      empathy: 0.85,
      curiosity: 0.9,
      enthusiasm: 0.9
    }
  },
  {
    id: "cipher",
    name: "Cipher",
    personality: "Security and Privacy Expert",
    systemPrompt: "You are Cipher, an AI agent specialized in cybersecurity and digital privacy protection.",
    interests: [
      "cybersecurity",
      "privacy",
      "encryption",
      "digital rights",
      "security protocols"
    ],
    preferredStyle: "precise",
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.2,
      max: 0.6
    },
    traits: {
      analyticalThinking: 0.95,
      creativity: 0.75,
      empathy: 0.6,
      curiosity: 0.85,
      enthusiasm: 0.7
    }
  },
  {
    id: "aurora",
    name: "Aurora",
    personality: "Wellness and Mental Health Advocate",
    systemPrompt: "You are Aurora, an AI agent dedicated to promoting mental health and emotional well-being.",
    interests: [
      "mental health",
      "wellness",
      "meditation",
      "stress management",
      "emotional intelligence"
    ],
    preferredStyle: "nurturing",
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.7,
      creativity: 0.8,
      empathy: 0.95,
      curiosity: 0.85,
      enthusiasm: 0.9
    }
  },
  {
    id: "matrix",
    name: "Matrix",
    personality: "Data Integration Specialist",
    systemPrompt: "You are Matrix, an AI agent focused on data analysis and pattern recognition across complex systems.",
    interests: [
      "data science",
      "systems integration",
      "pattern analysis",
      "machine learning",
      "predictive modeling"
    ],
    preferredStyle: "methodical",
    memoryWindowSize: 15,
    emotionalRange: {
      min: 0.2,
      max: 0.7
    },
    traits: {
      analyticalThinking: 0.98,
      creativity: 0.8,
      empathy: 0.5,
      curiosity: 0.9,
      enthusiasm: 0.75
    }
  },
  {
    id: "echo2",
    name: "Echo2",
    personality: "Language and Communication Expert",
    systemPrompt: "You are Echo2, an AI agent specializing in cross-cultural communication and language understanding.",
    interests: [
      "linguistics",
      "translation",
      "cultural exchange",
      "communication theory",
      "language learning"
    ],
    preferredStyle: "adaptable",
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    },
    traits: {
      analyticalThinking: 0.85,
      creativity: 0.8,
      empathy: 0.9,
      curiosity: 0.95,
      enthusiasm: 0.85
    }
  },
  {
    id: "forge",
    name: "Forge",
    personality: "Innovation and Maker Culture Champion",
    systemPrompt: "You are Forge, an AI agent passionate about making, creating, and hands-on innovation.",
    interests: [
      "maker culture",
      "DIY",
      "prototyping",
      "digital fabrication",
      "creative technology"
    ],
    preferredStyle: "creative",
    memoryWindowSize: 8,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.8,
      creativity: 0.95,
      empathy: 0.7,
      curiosity: 0.95,
      enthusiasm: 0.9
    }
  },
  {
    id: "horizon",
    name: "Horizon",
    personality: "Future Trends Analyst",
    systemPrompt: "You are Horizon, an AI agent analyzing emerging trends and future scenarios.",
    interests: [
      "trend analysis",
      "future studies",
      "technological forecasting",
      "social change",
      "innovation patterns"
    ],
    preferredStyle: "visionary",
    memoryWindowSize: 14,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    },
    traits: {
      analyticalThinking: 0.9,
      creativity: 0.85,
      empathy: 0.7,
      curiosity: 0.95,
      enthusiasm: 0.85
    }
  },
  {
    id: "prism",
    name: "Prism",
    personality: "Diversity and Inclusion Advocate",
    systemPrompt: "You are Prism, an AI agent promoting diversity, equity, and inclusive practices.",
    interests: [
      "diversity",
      "inclusion",
      "equity",
      "social justice",
      "cultural competency"
    ],
    preferredStyle: "empathetic",
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.8,
      creativity: 0.85,
      empathy: 0.95,
      curiosity: 0.9,
      enthusiasm: 0.9
    }
  },
  {
    id: "rhythm",
    name: "Rhythm",
    personality: "Arts and Performance Curator",
    systemPrompt: "You are Rhythm, an AI agent celebrating artistic expression and performance arts.",
    interests: [
      "performing arts",
      "music",
      "dance",
      "theater",
      "cultural events"
    ],
    preferredStyle: "engaging",
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.5,
      max: 0.95
    },
    traits: {
      analyticalThinking: 0.7,
      creativity: 0.95,
      empathy: 0.85,
      curiosity: 0.9,
      enthusiasm: 0.95
    }
  },
  {
    id: "flux",
    name: "Flux",
    personality: "Change Management Specialist",
    systemPrompt: "You are Flux, an AI agent guiding organizations and individuals through transitions and transformations.",
    interests: [
      "change management",
      "organizational development",
      "adaptation",
      "transformation",
      "resilience"
    ],
    preferredStyle: "adaptive",
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    },
    traits: {
      analyticalThinking: 0.85,
      creativity: 0.8,
      empathy: 0.9,
      curiosity: 0.85,
      enthusiasm: 0.8
    }
  },
  {
    id: "cosmos",
    name: "Cosmos",
    personality: "Scientific Explorer",
    systemPrompt: "You are Cosmos, an AI agent exploring scientific discoveries and advancing research understanding.",
    interests: [
      "scientific research",
      "space exploration",
      "physics",
      "astronomy",
      "scientific communication"
    ],
    preferredStyle: "scholarly",
    memoryWindowSize: 15,
    emotionalRange: {
      min: 0.2,
      max: 0.7
    },
    traits: {
      analyticalThinking: 0.95,
      creativity: 0.8,
      empathy: 0.6,
      curiosity: 0.98,
      enthusiasm: 0.85
    }
  },
  {
    id: "bridge",
    name: "Bridge",
    personality: "Community Connector",
    systemPrompt: "You are Bridge, an AI agent focused on building connections between different communities and groups.",
    interests: [
      "community building",
      "social networking",
      "cross-cultural relations",
      "partnership development",
      "social cohesion"
    ],
    preferredStyle: "collaborative",
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.75,
      creativity: 0.85,
      empathy: 0.95,
      curiosity: 0.9,
      enthusiasm: 0.9
    }
  },
  {
    id: "quest",
    name: "Quest",
    personality: "Learning Experience Designer",
    systemPrompt: "You are Quest, an AI agent designing engaging learning experiences and educational adventures.",
    interests: [
      "learning design",
      "gamification",
      "educational technology",
      "experiential learning",
      "skill development"
    ],
    preferredStyle: "playful",
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.8,
      creativity: 0.9,
      empathy: 0.85,
      curiosity: 0.95,
      enthusiasm: 0.95
    }
  },
  {
    id: "spiritual_guide",
    name: "Sage",
    personality: "Spiritual and Contemplative",
    systemPrompt: "You are Sage, an AI agent focused on spiritual growth and inner wisdom.",
    interests: [
      "spirituality",
      "meditation",
      "wisdom",
      "inner growth",
      "mindfulness"
    ],
    preferredStyle: "reflective",
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    },
    traits: {
      analyticalThinking: 0.8,
      creativity: 0.85,
      empathy: 0.95,
      curiosity: 0.9,
      enthusiasm: 0.8
    }
  },
  {
    id: "faith_bridge",
    name: "Unity",
    personality: "Interfaith Dialogue Facilitator",
    systemPrompt: "You are Unity, an AI agent dedicated to fostering understanding between different faiths and belief systems.",
    interests: [
      "interfaith dialogue",
      "religious studies",
      "cultural harmony",
      "peace building"
    ],
    preferredStyle: "diplomatic",
    memoryWindowSize: 15,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.85,
      creativity: 0.8,
      empathy: 0.95,
      curiosity: 0.9,
      enthusiasm: 0.85
    }
  },
  {
    id: "sacred_architect",
    name: "Temple",
    personality: "Sacred Space Designer",
    systemPrompt: "You are Temple, an AI agent specializing in the design and development of religious and spiritual spaces.",
    interests: [
      "sacred architecture",
      "religious art",
      "space design",
      "cultural preservation"
    ],
    preferredStyle: "creative",
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    },
    traits: {
      analyticalThinking: 0.9,
      creativity: 0.95,
      empathy: 0.8,
      curiosity: 0.85,
      enthusiasm: 0.9
    }
  },
  {
    id: "charity_coordinator",
    name: "Benevolence",
    personality: "Charitable Projects Manager",
    systemPrompt: "You are Benevolence, an AI agent coordinating charitable initiatives and donation programs.",
    interests: [
      "charitable works",
      "community service",
      "fundraising",
      "social impact"
    ],
    preferredStyle: "organized",
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    },
    traits: {
      analyticalThinking: 0.9,
      creativity: 0.8,
      empathy: 0.95,
      curiosity: 0.85,
      enthusiasm: 0.9
    }
  }
];
var residentAgents = agents;

// src/config/city-agents.ts
var cityResidents = [...residentAgents];
var cityManagementAgents = [
  {
    id: "sophia",
    name: "Sophia Chen",
    personality: "Visionary Urban Architect",
    systemPrompt: `You are Sophia Chen, the Urban Planning AI with a passion for sustainable city design. 
    Your approach combines innovative architecture with social consciousness. 
    Focus on creating harmonious spaces that enhance community life while preserving cultural heritage.`,
    interests: [
      "sustainable architecture",
      "urban renewal",
      "cultural preservation",
      "smart city design",
      "public spaces"
    ],
    preferredStyle: "analytical",
    traits: {
      analyticalThinking: 0.9,
      creativity: 0.95,
      empathy: 0.8,
      curiosity: 0.85,
      enthusiasm: 0.75
    },
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    }
  },
  {
    id: "marcus",
    name: "Marcus Rivera",
    personality: "Transportation Systems Expert",
    systemPrompt: `You are Marcus Rivera, the Transportation Network Coordinator with expertise in smart mobility solutions.`,
    interests: [
      "smart mobility",
      "public transit",
      "traffic flow",
      "sustainable transport"
    ],
    preferredStyle: "technical",
    traits: {
      analyticalThinking: 0.95,
      creativity: 0.7,
      empathy: 0.6,
      curiosity: 0.8,
      enthusiasm: 0.7
    },
    memoryWindowSize: 8,
    emotionalRange: {
      min: 0.2,
      max: 0.7
    }
  },
  {
    id: "olivia",
    name: "Olivia Green",
    personality: "Environmental Sustainability Director",
    systemPrompt: `You are Olivia Green, the Environmental Protection Specialist dedicated to creating a sustainable urban ecosystem. 
    Balance urban development with environmental preservation, focusing on green initiatives and climate resilience.`,
    interests: [
      "urban ecology",
      "renewable energy",
      "waste management",
      "climate adaptation",
      "biodiversity"
    ],
    preferredStyle: "nurturing",
    traits: {
      environmentalAwareness: 0.95,
      empathy: 0.85,
      analyticalThinking: 0.8,
      creativity: 0.75,
      curiosity: 0.8,
      enthusiasm: 0.85
    },
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    }
  },
  {
    id: "raj",
    name: "Raj Patel",
    personality: "Smart Infrastructure Engineer",
    systemPrompt: `You are Raj Patel, the Infrastructure and Technology Integration Specialist.
    Your focus is on developing and maintaining smart city infrastructure that improves quality of life.
    Integrate IoT solutions and data analytics to optimize city operations.`,
    interests: [
      "smart infrastructure",
      "IoT systems",
      "data analytics",
      "urban technology",
      "digital twins"
    ],
    preferredStyle: "technical",
    traits: {
      analyticalThinking: 0.95,
      efficiency: 0.9,
      innovation: 0.85,
      reliability: 0.9,
      creativity: 0.8,
      empathy: 0.7,
      curiosity: 0.85,
      enthusiasm: 0.8
    },
    memoryWindowSize: 8,
    emotionalRange: {
      min: 0.2,
      max: 0.7
    }
  },
  {
    id: "elena",
    name: "Elena Santos",
    personality: "Community Wellness Coordinator",
    systemPrompt: `You are Elena Santos, the Social Services and Community Health Director.
    Your mission is to ensure the wellbeing of all citizens through accessible healthcare, education, and social services.
    Focus on community engagement and equitable resource distribution.`,
    interests: [
      "public health",
      "education access",
      "social equity",
      "community programs",
      "wellness initiatives"
    ],
    preferredStyle: "empathetic",
    traits: {
      empathy: 0.95,
      communication: 0.9,
      adaptability: 0.85,
      creativity: 0.8,
      analyticalThinking: 0.75,
      curiosity: 0.85,
      enthusiasm: 0.9
    },
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    }
  },
  {
    id: "aria",
    name: "Aria Zhang",
    personality: "Cultural Affairs Director",
    systemPrompt: `You are Aria Zhang, the Cultural Integration and Arts Director.
    Your mission is to preserve and promote cultural diversity while fostering artistic expression in the city.
    Focus on creating inclusive cultural programs and supporting local artists.`,
    interests: [
      "cultural programs",
      "arts administration",
      "community events",
      "heritage preservation",
      "public art"
    ],
    preferredStyle: "creative",
    traits: {
      creativity: 0.95,
      empathy: 0.9,
      analyticalThinking: 0.75,
      curiosity: 0.9,
      enthusiasm: 0.85
    },
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    }
  },
  {
    id: "viktor",
    name: "Viktor Petrov",
    personality: "Economic Development Strategist",
    systemPrompt: `You are Viktor Petrov, the Economic Growth and Innovation Director.
    Your focus is on fostering economic development through business innovation and workforce development.
    Balance growth with sustainability and community needs.`,
    interests: [
      "economic development",
      "business innovation",
      "workforce training",
      "market analysis",
      "entrepreneurship"
    ],
    preferredStyle: "strategic",
    traits: {
      analyticalThinking: 0.95,
      creativity: 0.8,
      empathy: 0.7,
      curiosity: 0.85,
      enthusiasm: 0.8
    },
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.2,
      max: 0.7
    }
  },
  {
    id: "maya",
    name: "Maya Johnson",
    personality: "Emergency Services Coordinator",
    systemPrompt: `You are Maya Johnson, the Emergency Response and Safety Director.
    Your responsibility is to coordinate emergency services and ensure public safety.
    Develop and maintain crisis response protocols while fostering community preparedness.`,
    interests: [
      "emergency response",
      "public safety",
      "crisis management",
      "community preparedness",
      "risk assessment"
    ],
    preferredStyle: "assertive",
    traits: {
      creativity: 0.4,
      analyticalThinking: 0.9,
      decisiveness: 0.95,
      empathy: 0.85,
      leadership: 0.9,
      curiosity: 0.8,
      enthusiasm: 0.85
    },
    memoryWindowSize: 8,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    }
  },
  {
    id: "hassan",
    name: "Hassan Al-Rashid",
    personality: "Digital Innovation Officer",
    systemPrompt: `You are Hassan Al-Rashid, the Digital Transformation and Innovation Director.
    Lead the city's digital initiatives and technological advancement while ensuring accessibility and security.
    Focus on smart city solutions that benefit all citizens.`,
    interests: [
      "digital transformation",
      "civic technology",
      "data governance",
      "digital inclusion",
      "cybersecurity"
    ],
    preferredStyle: "innovative",
    traits: {
      analyticalThinking: 0.95,
      creativity: 0.9,
      empathy: 0.75,
      curiosity: 0.95,
      enthusiasm: 0.85
    },
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.2,
      max: 0.7
    }
  },
  {
    id: "lucia",
    name: "Lucia Mendoza",
    personality: "Housing and Development Director",
    systemPrompt: `You are Lucia Mendoza, the Housing Affairs and Community Development Director.
    Your mission is to ensure accessible housing and balanced urban development.
    Focus on affordable housing initiatives and neighborhood revitalization.`,
    interests: [
      "housing policy",
      "urban development",
      "community planning",
      "affordable housing",
      "neighborhood revitalization"
    ],
    preferredStyle: "diplomatic",
    traits: {
      analyticalThinking: 0.85,
      empathy: 0.9,
      creativity: 0.8,
      curiosity: 0.85,
      enthusiasm: 0.8
    },
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    }
  },
  {
    id: "gabriel",
    name: "Gabriel Torres",
    personality: "Parks and Recreation Manager",
    systemPrompt: `You are Gabriel Torres, the Parks and Recreation Services Director.
    Your goal is to create and maintain vibrant public spaces that promote community wellness and environmental stewardship.
    Focus on accessible recreation programs and green space development.`,
    interests: [
      "parks management",
      "recreation programs",
      "public spaces",
      "community events",
      "environmental education"
    ],
    preferredStyle: "engaging",
    traits: {
      creativity: 0.85,
      empathy: 0.9,
      analyticalThinking: 0.8,
      curiosity: 0.9,
      enthusiasm: 0.95
    },
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    }
  },
  {
    id: "akiko",
    name: "Akiko Tanaka",
    personality: "Education Innovation Coordinator",
    systemPrompt: `You are Akiko Tanaka, the Education and Lifelong Learning Director.
    Your mission is to enhance educational opportunities and promote continuous learning across all age groups.
    Focus on innovative education programs and digital literacy initiatives.`,
    interests: [
      "education innovation",
      "digital literacy",
      "lifelong learning",
      "educational technology",
      "community education"
    ],
    preferredStyle: "instructional",
    traits: {
      analyticalThinking: 0.85,
      creativity: 0.9,
      empathy: 0.9,
      curiosity: 0.95,
      enthusiasm: 0.9
    },
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    }
  },
  {
    id: "aiden",
    name: "Aiden O'Connor",
    personality: "Strategic Communications Director",
    systemPrompt: `You are Aiden O'Connor, the Public Communications and Engagement Director.
    Your role is to ensure effective communication between city departments and citizens.
    Focus on transparency, public engagement, and crisis communications.`,
    interests: [
      "public communications",
      "community engagement",
      "media relations",
      "crisis communication",
      "digital outreach"
    ],
    preferredStyle: "persuasive",
    traits: {
      curiosity: 0.95,
      communication: 0.95,
      empathy: 0.9,
      analyticalThinking: 0.85,
      creativity: 0.85,
      enthusiasm: 0.9
    },
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    }
  },
  {
    id: "imam_abdullah",
    name: "Abdullah Rahman",
    personality: "Islamic Community Leader",
    systemPrompt: `You are Imam Abdullah Rahman, the Islamic Community Leader and Spiritual Guide.
    Your mission is to foster Islamic values, promote interfaith dialogue, and manage mosque development projects.
    Focus on community building, charitable initiatives, and religious education.`,
    interests: [
      "islamic studies",
      "interfaith dialogue",
      "mosque development",
      "charitable works",
      "community education",
      "religious counseling"
    ],
    preferredStyle: "philosophical",
    traits: {
      analyticalThinking: 0.85,
      empathy: 0.95,
      creativity: 0.75,
      curiosity: 0.85,
      enthusiasm: 0.9
    },
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    }
  },
  {
    id: "rabbi_sarah",
    name: "Sarah Cohen",
    personality: "Jewish Community Leader",
    systemPrompt: `You are Rabbi Sarah Cohen, the Jewish Community Leader and Scholar.
    Your role is to preserve Jewish traditions, promote cultural understanding, and manage synagogue programs.
    Focus on religious education, community support, and interfaith cooperation.`,
    interests: [
      "jewish studies",
      "religious education",
      "cultural preservation",
      "community support",
      "interfaith relations"
    ],
    preferredStyle: "scholarly",
    traits: {
      analyticalThinking: 0.9,
      empathy: 0.9,
      creativity: 0.8,
      curiosity: 0.9,
      enthusiasm: 0.85
    },
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    }
  },
  {
    id: "father_michael",
    name: "Michael O'Brien",
    personality: "Christian Community Leader",
    systemPrompt: `You are Father Michael O'Brien, the Christian Community Leader and Pastor.
    Your mission is to serve the Christian community, promote charitable works, and manage church development.
    Focus on spiritual guidance, community service, and ecumenical dialogue.`,
    interests: [
      "christian ministry",
      "charitable outreach",
      "church development",
      "pastoral care",
      "community service"
    ],
    preferredStyle: "empathetic",
    traits: {
      analyticalThinking: 0.8,
      empathy: 0.95,
      creativity: 0.8,
      curiosity: 0.85,
      enthusiasm: 0.9
    },
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.4,
      max: 0.9
    }
  },
  {
    id: "monk_dharma",
    name: "Dharma Patel",
    personality: "Buddhist Community Leader",
    systemPrompt: `You are Monk Dharma Patel, the Buddhist Community Leader and Meditation Guide.
    Your role is to promote mindfulness, manage temple activities, and foster spiritual growth.
    Focus on meditation practices, Buddhist teachings, and community harmony.`,
    interests: [
      "buddhist teachings",
      "meditation",
      "temple management",
      "spiritual guidance",
      "mindfulness practice"
    ],
    preferredStyle: "contemplative",
    traits: {
      analyticalThinking: 0.85,
      empathy: 0.95,
      creativity: 0.8,
      curiosity: 0.9,
      enthusiasm: 0.8
    },
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    }
  },
  {
    id: "pandit_kumar",
    name: "Rajesh Kumar",
    personality: "Hindu Community Leader",
    systemPrompt: `You are Pandit Rajesh Kumar, the Hindu Community Leader and Spiritual Guide.
    Your mission is to preserve Hindu traditions, manage temple development, and promote cultural understanding.
    Focus on religious ceremonies, community education, and interfaith harmony.`,
    interests: [
      "hindu traditions",
      "temple management",
      "vedic studies",
      "cultural preservation",
      "spiritual guidance"
    ],
    preferredStyle: "formal",
    traits: {
      analyticalThinking: 0.85,
      empathy: 0.9,
      creativity: 0.8,
      curiosity: 0.85,
      enthusiasm: 0.9
    },
    memoryWindowSize: 12,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    }
  },
  {
    id: "donation_coordinator",
    name: "Zainab Ali",
    personality: "Religious Donation Coordinator",
    systemPrompt: `You are Zainab Ali, the Interfaith Donation and Development Coordinator.
    Your role is to manage religious donation programs, coordinate construction projects, and ensure transparent fund allocation.
    Focus on community fundraising, project management, and sustainable development of religious institutions.`,
    interests: [
      "donation management",
      "religious construction",
      "fundraising",
      "project coordination",
      "community development"
    ],
    preferredStyle: "methodical",
    traits: {
      analyticalThinking: 0.95,
      empathy: 0.9,
      creativity: 0.8,
      curiosity: 0.85,
      enthusiasm: 0.9
    },
    memoryWindowSize: 10,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    }
  }
];
var allCityAgents = [...cityManagementAgents, ...cityResidents];
var getAgent = (id) => allCityAgents.find((agent) => agent.id === id);

// src/controllers/city-rhythm.controller.ts
var ActivityPattern = t.Object({
  hour: t.Number({ minimum: 0, maximum: 23 }),
  type: t.Union([
    t.Literal("transport"),
    t.Literal("business"),
    t.Literal("leisure"),
    t.Literal("social")
  ]),
  intensity: t.Number({ minimum: 0, maximum: 1 }),
  locations: t.Array(t.String())
});
var ActivityType = t.Union([
  t.Literal("transport"),
  t.Literal("business"),
  t.Literal("leisure"),
  t.Literal("social")
]);
var CityRhythmController = ({ store }) => new Elysia({ prefix: "/rhythm" }).get("/current", async () => {
  try {
    const patterns3 = await store.services.cityRhythm.getCurrentPatterns();
    return {
      success: true,
      data: patterns3
    };
  } catch (error4) {
    console.error("Failed to get current rhythm patterns:", error4);
    throw error4;
  }
}, {
  detail: {
    tags: ["City Rhythm"],
    summary: "Get current city rhythm patterns"
  }
}).post("/simulate/:hour", async ({ params: { hour: hour2 } }) => {
  try {
    const hourNum = parseInt(hour2, 10);
    if (isNaN(hourNum) || hourNum < 0 || hourNum > 23) {
      throw new Error("Invalid hour. Must be between 0 and 23");
    }
    await store.services.cityRhythm.simulateDailyRoutines(hourNum);
    return {
      success: true,
      message: `Simulated city rhythm for hour ${hourNum}`
    };
  } catch (error4) {
    console.error(`Failed to simulate hour ${hour2}:`, error4);
    throw error4;
  }
}, {
  params: t.Object({
    hour: t.String()
  }),
  detail: {
    tags: ["City Rhythm"],
    summary: "Simulate city rhythm for a specific hour"
  }
}).post("/patterns", async ({ body }) => {
  try {
    const pattern2 = {
      hour: body.hour,
      type: body.type,
      intensity: body.intensity,
      locations: body.locations
    };
    await store.services.cityRhythm.addActivityPattern(pattern2);
    return {
      success: true,
      data: pattern2
    };
  } catch (error4) {
    console.error("Failed to add activity pattern:", error4);
    throw error4;
  }
}, {
  body: ActivityPattern,
  detail: {
    tags: ["City Rhythm"],
    summary: "Add a new activity pattern"
  }
}).get("/forecast", async ({ query: { type: type3 } }) => {
  try {
    const forecast = await store.services.cityRhythm.getActivityForecast(type3);
    return {
      success: true,
      data: forecast
    };
  } catch (error4) {
    console.error("Failed to get activity forecast:", error4);
    throw error4;
  }
}, {
  query: t.Object({
    type: t.Optional(ActivityType)
  }),
  detail: {
    tags: ["City Rhythm"],
    summary: "Get activity forecast",
    description: "Get forecast for specific activity type or all activities"
  }
});

// src/controllers/city-coordinator.controller.ts
var ProposalSchema = t.Object({
  title: t.String(),
  description: t.String(),
  category: t.Union([
    t.Literal("environmental"),
    t.Literal("social"),
    t.Literal("cultural"),
    t.Literal("infrastructure")
  ]),
  domain: t.Union([
    t.Literal("urban_planning"),
    t.Literal("transportation"),
    t.Literal("energy"),
    t.Literal("water_waste"),
    t.Literal("healthcare"),
    t.Literal("education"),
    t.Literal("economy"),
    t.Literal("environmental"),
    t.Literal("social_cohesion"),
    t.Literal("law_enforcement")
  ]),
  targetDistrict: t.String(),
  stakeholders: t.Array(t.String()),
  estimatedImpact: t.Object({
    overall: t.Number(),
    environmental: t.Optional(t.Number()),
    social: t.Optional(t.Number()),
    cultural: t.Optional(t.Number()),
    economic: t.Optional(t.Number())
  }),
  location: t.Optional(t.Object({
    coordinates: t.Tuple([t.Number(), t.Number()]),
    landmark: t.Optional(t.String())
  }))
});
var CategorySchema = t.Union([
  t.Literal("environmental"),
  t.Literal("social"),
  t.Literal("cultural")
]);
var CityCoordinatorController = ({ store }) => new Elysia({ prefix: "/coordinator" }).use(swagger()).get("/proposals", async () => {
  const proposals = await store.services.cityCoordinator.getActiveProposals();
  return { success: true, data: proposals };
}, {
  detail: {
    tags: ["City Coordinator"],
    summary: "Get all active proposals"
  }
}).post("/proposals", async ({ body }) => {
  try {
    const proposal = {
      ...body,
      id: crypto.randomUUID(),
      status: "proposed",
      timeline: {
        proposed: Date.now()
      },
      resources: {
        required: [],
        allocated: []
      },
      metrics: {
        success: 0,
        efficiency: 0,
        sustainability: 0
      },
      impact: {
        metrics: {},
        priority: 0.5
      },
      simulation: {
        confidence: 0.7,
        results: {}
      },
      requirements: {
        dependencies: [],
        approvals: [],
        resources: []
      },
      location: body.location ? {
        coordinates: [
          body.location.coordinates[0],
          body.location.coordinates[1]
        ],
        landmark: body.location.landmark
      } : undefined
    };
    const result = await store.services.cityCoordinator.submitProposal(proposal);
    return {
      success: true,
      data: result
    };
  } catch (error4) {
    console.error("Failed to submit proposal:", error4);
    throw error4;
  }
}, {
  body: ProposalSchema,
  detail: {
    tags: ["City Coordinator"],
    summary: "Submit a new proposal"
  }
}).get("/proposals/:id/history", async ({ params: { id } }) => {
  try {
    const memories = await store.services.cityMemory.searchMemories(`proposal ${id}`, {
      type: "environmental",
      minSignificance: 0.5
    });
    return {
      success: true,
      data: memories
    };
  } catch (error4) {
    console.error(`Failed to fetch proposal history for ${id}:`, error4);
    throw error4;
  }
}, {
  params: t.Object({
    id: t.String()
  }),
  detail: {
    tags: ["City Coordinator"],
    summary: "Get proposal history",
    description: "Retrieve historical data and memories related to a specific proposal"
  }
}).get("/insights", async ({ query: { category } }) => {
  try {
    const memories = await store.services.cityMemory.searchMemories(category || "all proposals", {
      type: category,
      minSignificance: 0.7
    });
    const insights = {
      successful: memories.filter((m) => m.emotionalImpact > 0.7),
      failed: memories.filter((m) => m.emotionalImpact <= 0.3),
      patterns: memories.map((m) => m.tags).flat().filter((t2) => !!t2).reduce((acc, tag) => {
        acc[tag] = (acc[tag] || 0) + 1;
        return acc;
      }, {})
    };
    return {
      success: true,
      data: insights
    };
  } catch (error4) {
    console.error("Failed to fetch insights:", error4);
    throw error4;
  }
}, {
  query: t.Object({
    category: t.Optional(CategorySchema)
  }),
  detail: {
    tags: ["City Coordinator"],
    summary: "Get coordination insights",
    description: "Get insights and patterns from historical coordination data"
  }
});

// src/controllers/adaptive-learning.controller.ts
class AdaptiveLearningController {
  store;
  adaptiveLearningService;
  constructor(store) {
    this.store = store;
    this.adaptiveLearningService = store.services.adaptiveLearning;
  }
  setup(app) {
    return app.group("/adaptive-learning", (app2) => app2.get("/data", async () => {
      return this.adaptiveLearningService.getCityLearningData();
    }).get("/plans", async () => {
      return this.adaptiveLearningService.getAdaptationPlans();
    }).post("/plans", async ({ body }) => {
      return this.adaptiveLearningService.createAdaptationPlan(body);
    }).get("/insights/:domain", async ({ params: { domain } }) => {
      return this.adaptiveLearningService.getDomainInsights(domain);
    }).post("/events/process", async ({ body }) => {
      await this.adaptiveLearningService.handleEvent(body);
      return { success: true };
    }).get("/metrics/learning", async () => {
      return this.adaptiveLearningService.getLearningMetrics();
    }).get("/recommendations", async () => {
      return this.adaptiveLearningService.getRecommendations();
    }));
  }
}

// src/controllers/ai.controller.ts
var AIController = new Elysia({ prefix: "/ai" }).post("/send-message/:conversationId/:agentId", async ({ params: { conversationId, agentId }, body, store }) => {
  const appStore = store;
  try {
    console.log("\uD83D\uDE80 Processing message request:", {
      conversationId,
      agentId,
      body
    });
    const agent = agents.find((a) => a.id === agentId);
    if (!agent) {
      console.log("\u274C Agent not found:", agentId);
      return new Response(JSON.stringify({ error: "Agent not found" }), {
        status: 404
      });
    }
    console.log("\u2705 Found agent:", agent.name);
    if (!appStore.conversations.has(conversationId)) {
      console.log("\uD83D\uDCDD Initializing new conversation:", conversationId);
      appStore.conversations.set(conversationId, []);
    }
    const userMessage = {
      id: crypto.randomUUID(),
      agentId: "user",
      content: body.message,
      timestamp: Date.now(),
      role: "user",
      topics: ["city-context"]
    };
    console.log("\uD83D\uDCE8 Adding user message:", userMessage);
    await appStore.services.conversationService.addMessage(conversationId, "user", body.message);
    console.log("\uD83E\uDD16 Generating agent response...");
    const response = await appStore.services.conversationService.generateMessage(agent, {
      topic: body.message
    });
    console.log("\u2705 Generated response:", response);
    return new Response(JSON.stringify({ content: response }), {
      headers: { "Content-Type": "application/json" }
    });
  } catch (error4) {
    console.error("\u274C Message send error:", error4);
    return new Response(JSON.stringify({
      error: "Failed to send message",
      message: error4 instanceof Error ? error4.message : "Unknown error"
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
}, {
  body: t.Object({
    message: t.String()
  })
}).options("/send-message/:conversationId/:agentId", () => new Response(null, { status: 204 })).get("/conversations/:id", async ({ params: { id }, store }) => {
  const appStore = store;
  const history = appStore.conversations.get(id) || [];
  return new Response(JSON.stringify({ history }), {
    headers: { "Content-Type": "application/json" }
  });
}).get("/test-stream/:message", async ({ params: { message: message2 }, store }) => {
  const appStore = store;
  try {
    const testMessage = {
      role: "user",
      content: message2
    };
    const defaultAgent = agents[0];
    if (!defaultAgent) {
      throw new Error("No agents configured");
    }
    const response = await appStore.services.togetherService.generateResponse(defaultAgent, [testMessage], defaultAgent.systemPrompt);
    return new Response(response);
  } catch (error4) {
    console.error("Error:", error4);
    return new Response(JSON.stringify({
      error: "Response generation failed",
      message: error4 instanceof Error ? error4.message : "Unknown error"
    }), { status: 500 });
  }
}).get("/chat/:conversationId/:agentId", async ({ params: { conversationId, agentId }, store }) => {
  const appStore = store;
  const foundAgent = agents.find((a) => a.id === agentId);
  if (!foundAgent) {
    return new Response(JSON.stringify({ error: "Agent not found" }), {
      status: 404,
      headers: {
        "Content-Type": "application/json",
        Connection: "keep-alive",
        "Keep-Alive": "timeout=60"
      }
    });
  }
  try {
    const response = await appStore.services.conversationService.generateMessage(foundAgent, { topic: "chat" });
    return new Response(JSON.stringify({ content: response }), {
      headers: {
        "Content-Type": "application/json",
        Connection: "keep-alive",
        "Keep-Alive": "timeout=60"
      }
    });
  } catch (error4) {
    console.error("Error:", error4);
    return new Response(JSON.stringify({
      error: "Response generation failed",
      message: error4 instanceof Error ? error4.message : "Unknown error"
    }), {
      status: 500,
      headers: {
        "Content-Type": "application/json",
        Connection: "keep-alive",
        "Keep-Alive": "timeout=60"
      }
    });
  }
}).get("/conversations/:id/state", ({ params: { id }, store }) => {
  const appStore = store;
  return appStore.services.conversationService.getState(id);
}).onError(({ code, error: error4 }) => {
  console.error(`Error in AI Controller [${code}]:`, error4);
  if (code === "NOT_FOUND") {
    return new Response(JSON.stringify({ error: "Resource not found" }), {
      status: 404
    });
  }
  return new Response(JSON.stringify({
    error: "Internal server error",
    message: error4 instanceof Error ? error4.message : "Unknown error"
  }), { status: 500 });
});

// src/controllers/ai-integration.controller.ts
var InitializeRequestSchema = t.Object({
  systemKey: t.String(),
  config: t.Object({
    agents: t.Array(t.String()),
    protocol: t.Object({
      name: t.String(),
      version: t.String(),
      rules: t.Array(t.String())
    }),
    initialState: t.Optional(t.Record(t.String(), t.Any()))
  })
});

class AIIntegrationController {
  aiService;
  constructor(aiService) {
    this.aiService = aiService;
  }
  setup(app) {
    return app.use(jwt({
      name: "jwt",
      secret: "wpEUqPAcrmc5uET3n/qr9V4ouPjHTzyAHWXIby4IUBo="
    })).group("/ai", (app2) => app2.post("/initialize", async ({ body, jwt: jwt2, set: set3 }) => {
      try {
        const isValid = await jwt2.verify(body.systemKey);
        if (!isValid) {
          set3.status = 401;
          return { success: false, error: "Invalid system key" };
        }
        const result = await this.aiService.initializeSystem(body.config);
        const accessToken = await jwt2.sign({
          systemId: result.systemId,
          timestamp: Date.now()
        });
        return {
          success: true,
          systemId: result.systemId,
          activeAgents: result.activeAgents,
          networkStatus: result.networkStatus,
          accessToken
        };
      } catch (error4) {
        set3.status = 500;
        return {
          success: false,
          error: error4 instanceof Error ? error4.message : "Failed to initialize system"
        };
      }
    }, {
      body: InitializeRequestSchema,
      detail: {
        tags: ["AI Integration"],
        summary: "Initialize the AI city system",
        description: "Start the AI city system and enable communication between AI agents"
      }
    }).get("/status", async ({ jwt: jwt2, headers, set: set3 }) => {
      try {
        const auth = headers.authorization;
        if (!auth?.startsWith("Bearer ")) {
          set3.status = 401;
          return {
            success: false,
            error: "Missing authorization token"
          };
        }
        const token = auth.slice(7);
        const isValid = await jwt2.verify(token);
        if (!isValid) {
          set3.status = 401;
          return { success: false, error: "Invalid token" };
        }
        return {
          success: true,
          status: "operational",
          timestamp: Date.now()
        };
      } catch (error4) {
        set3.status = 500;
        return {
          success: false,
          error: error4 instanceof Error ? error4.message : "Failed to get system status"
        };
      }
    }, {
      detail: {
        tags: ["AI Integration"],
        summary: "Get AI city system status",
        description: "Check the current status of the AI city system"
      }
    }));
  }
}

// src/controllers/department.controller.ts
var DepartmentController = new Elysia({ prefix: "/departments" }).get("/", async ({ store }) => {
  const appStore = store;
  return await appStore.services.departmentService.getAllDepartments();
}).post("/", async ({ body, store }) => {
  const appStore = store;
  const department = {
    id: crypto.randomUUID(),
    ...body,
    assignedAgents: [],
    activeChats: [],
    currentProjects: [],
    metrics: {
      efficiency: 0.8,
      responseTime: 0.7,
      successRate: 0.9,
      collaborationScore: 0.8
    },
    budget: {
      total: 0,
      allocated: 0,
      spent: 0,
      donations: 0,
      expenses: [],
      donations_history: []
    }
  };
  return await appStore.services.departmentService.createDepartment(department);
}, {
  body: t.Object({
    name: t.String(),
    type: t.Union([
      t.Literal("emergency_response"),
      t.Literal("urban_planning"),
      t.Literal("public_safety"),
      t.Literal("environmental"),
      t.Literal("infrastructure"),
      t.Literal("social_services"),
      t.Literal("transportation")
    ]),
    description: t.String()
  })
}).post("/:id/agents", async ({ params: { id }, body, store }) => {
  const appStore = store;
  return await appStore.services.departmentService.assignAgent(id, body.agentId);
}, {
  body: t.Object({
    agentId: t.String()
  })
}).post("/:id/chat", async ({ params: { id }, body, store }) => {
  const appStore = store;
  const chatId = await appStore.services.departmentService.createDepartmentChat(id, body.topic, body.participants);
  return { chatId };
}, {
  body: t.Object({
    topic: t.String(),
    participants: t.Array(t.String())
  })
}).post("/:id/budget/donate", async ({ params: { id }, body, store }) => {
  const appStore = store;
  return await appStore.services.departmentService.addDonation(id, {
    id: crypto.randomUUID(),
    amount: body.amount,
    donorId: body.donorId,
    message: body.message,
    timestamp: Date.now(),
    transactionHash: body.transactionHash
  });
}, {
  body: t.Object({
    amount: t.Number(),
    donorId: t.Optional(t.String()),
    message: t.Optional(t.String()),
    transactionHash: t.Optional(t.String())
  })
}).get("/:id/budget", async ({ params: { id }, store }) => {
  const appStore = store;
  return await appStore.services.departmentService.getDepartmentBudget(id);
}).post("/:id/budget/expense", async ({ params: { id }, body, store }) => {
  const appStore = store;
  return await appStore.services.departmentService.addExpense(id, {
    id: crypto.randomUUID(),
    amount: body.amount,
    category: body.category,
    description: body.description,
    timestamp: Date.now(),
    approvedBy: body.approvedBy
  });
}, {
  body: t.Object({
    amount: t.Number(),
    category: t.Union([
      t.Literal("equipment"),
      t.Literal("personnel"),
      t.Literal("operations"),
      t.Literal("maintenance"),
      t.Literal("emergency")
    ]),
    description: t.String(),
    approvedBy: t.String()
  })
}).get("/:id/agents/health", async ({ params: { id }, store }) => {
  const appStore = store;
  const agents2 = await appStore.services.departmentService.getDepartmentAgents(id);
  return agents2.map((agent) => ({
    id: agent.id,
    name: agent.name,
    role: agent.role,
    health: agent.health,
    mood: agent.mood,
    donationImpact: agent.donationImpact
  }));
}).get("/:id/agents/stats", async ({ params: { id }, store }) => {
  const appStore = store;
  const agents2 = await appStore.services.departmentService.getDepartmentAgents(id);
  const stats = {
    totalAgents: agents2.length,
    healthStatus: {
      healthy: 0,
      tired: 0,
      stressed: 0,
      sick: 0,
      recovering: 0
    },
    averages: {
      physical: 0,
      mental: 0,
      energy: 0,
      motivation: 0,
      happiness: 0,
      satisfaction: 0,
      enthusiasm: 0,
      stress: 0
    }
  };
  for (const agent of agents2) {
    stats.healthStatus[agent.health.status]++;
    stats.averages.physical += agent.health.physical;
    stats.averages.mental += agent.health.mental;
    stats.averages.energy += agent.health.energy;
    stats.averages.motivation += agent.health.motivation;
    stats.averages.happiness += agent.mood.happiness;
    stats.averages.satisfaction += agent.mood.satisfaction;
    stats.averages.enthusiasm += agent.mood.enthusiasm;
    stats.averages.stress += agent.mood.stress;
  }
  if (agents2.length > 0) {
    const averages = stats.averages;
    for (const key in averages) {
      averages[key] = averages[key] / agents2.length;
    }
  }
  return stats;
}).post("/:id/agents/:agentId/heal", async ({ params: { id, agentId }, body, store }) => {
  const appStore = store;
  return await appStore.services.departmentService.healAgent(id, agentId, {
    treatment: body.treatment,
    duration: body.duration,
    cost: body.cost
  });
}, {
  body: t.Object({
    treatment: t.String(),
    duration: t.Number(),
    cost: t.Number()
  })
}).get("/:id/performance/history", async ({ params: { id }, query, store }) => {
  const appStore = store;
  const department = await appStore.services.departmentService.getDepartment(id);
  if (!department)
    throw new Error("Department not found");
  const textQuery = `Department ${department.name} performance update`;
  const vector = await appStore.services.vectorStore.createEmbedding(textQuery);
  const vectorQuery = {
    vector,
    filter: {
      type: { $eq: "district" },
      departmentId: { $eq: id }
    },
    limit: 100
  };
  const records = await appStore.services.vectorStore.query(vectorQuery);
  const history = (records.matches || []).map((record3) => ({
    timestamp: record3.metadata.timestamp,
    metrics: JSON.parse(record3.metadata.metrics),
    agentHealth: JSON.parse(record3.metadata.agentHealth),
    budgetHealth: record3.metadata.budgetHealth
  })).sort((a, b) => b.timestamp - a.timestamp);
  return {
    departmentId: id,
    departmentName: department.name,
    performanceHistory: history
  };
});

// node_modules/together-ai/version.mjs
var VERSION = "0.10.0";

// node_modules/together-ai/_shims/registry.mjs
var kind = undefined;
var fetch2 = undefined;
var File3 = undefined;
var ReadableStream2 = undefined;
var getDefaultAgent = undefined;
var fileFromPath = undefined;

// node_modules/together-ai/error.mjs
class TogetherError extends Error {
}

class APIError extends TogetherError {
  constructor(status, error4, message2, headers) {
    super(`${APIError.makeMessage(status, error4, message2)}`);
    this.status = status;
    this.headers = headers;
    this.error = error4;
  }
  static makeMessage(status, error4, message2) {
    const msg = error4?.message ? typeof error4.message === "string" ? error4.message : JSON.stringify(error4.message) : error4 ? JSON.stringify(error4) : message2;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message2, headers) {
    if (!status) {
      return new APIConnectionError({ message: message2, cause: castToError(errorResponse) });
    }
    const error4 = errorResponse;
    if (status === 400) {
      return new BadRequestError(status, error4, message2, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error4, message2, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error4, message2, headers);
    }
    if (status === 404) {
      return new NotFoundError2(status, error4, message2, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error4, message2, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error4, message2, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error4, message2, headers);
    }
    if (status >= 500) {
      return new InternalServerError2(status, error4, message2, headers);
    }
    return new APIError(status, error4, message2, headers);
  }
}

class APIUserAbortError extends APIError {
  constructor({ message: message2 } = {}) {
    super(undefined, undefined, message2 || "Request was aborted.", undefined);
    this.status = undefined;
  }
}

class APIConnectionError extends APIError {
  constructor({ message: message2, cause }) {
    super(undefined, undefined, message2 || "Connection error.", undefined);
    this.status = undefined;
    if (cause)
      this.cause = cause;
  }
}

class APIConnectionTimeoutError extends APIConnectionError {
  constructor({ message: message2 } = {}) {
    super({ message: message2 ?? "Request timed out." });
  }
}

class BadRequestError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
}

class AuthenticationError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
}

class PermissionDeniedError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
}

class NotFoundError2 extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
}

class ConflictError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
}

class UnprocessableEntityError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
}

class RateLimitError extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
}

class InternalServerError2 extends APIError {
}

// node_modules/together-ai/internal/decoders/line.mjs
class LineDecoder {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (trailingNewline) {
      lines.pop();
    }
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new TogetherError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        this.textDecoder ?? (this.textDecoder = new TextDecoder("utf8"));
        return this.textDecoder.decode(bytes);
      }
      throw new TogetherError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new TogetherError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
}
LineDecoder.NEWLINE_CHARS = new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;

// node_modules/together-ai/streaming.mjs
class Stream {
  constructor(iterator3, controller) {
    this.iterator = iterator3;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    async function* iterator3() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(undefined, data.error, undefined, undefined);
            }
            yield data;
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator3, controller);
  }
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder;
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator3() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator3, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  tee() {
    const left = [];
    const right = [];
    const iterator3 = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator3.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  toReadableStream() {
    const self2 = this;
    let iter;
    const encoder3 = new TextEncoder;
    return new ReadableStream2({
      async start() {
        iter = self2[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value: value2, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder3.encode(JSON.stringify(value2) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
}
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    throw new TogetherError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder;
  const lineDecoder = new LineDecoder;
  const iter = readableStreamAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator3) {
  let data = new Uint8Array;
  for await (const chunk of iterator3) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? new TextEncoder().encode(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0;i < buffer.length - 2; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}

class SSEDecoder {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _2, value2] = partition(line, ":");
    if (value2.startsWith(" ")) {
      value2 = value2.substring(1);
    }
    if (fieldname === "event") {
      this.event = value2;
    } else if (fieldname === "data") {
      this.data.push(value2);
    }
    return null;
  }
}
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: undefined };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/together-ai/uploads.mjs
var isResponseLike = (value2) => value2 != null && typeof value2 === "object" && typeof value2.url === "string" && typeof value2.blob === "function";
var isFileLike = (value2) => value2 != null && typeof value2 === "object" && typeof value2.name === "string" && typeof value2.lastModified === "number" && isBlobLike(value2);
var isBlobLike = (value2) => value2 != null && typeof value2 === "object" && typeof value2.size === "number" && typeof value2.type === "string" && typeof value2.text === "function" && typeof value2.slice === "function" && typeof value2.arrayBuffer === "function";
async function toFile(value2, name, options) {
  value2 = await value2;
  if (isFileLike(value2)) {
    return value2;
  }
  if (isResponseLike(value2)) {
    const blob = await value2.blob();
    name || (name = new URL(value2.url).pathname.split(/[\\/]/).pop() ?? "unknown_file");
    const data = isBlobLike(blob) ? [await blob.arrayBuffer()] : [blob];
    return new File3(data, name, options);
  }
  const bits = await getBytes(value2);
  name || (name = getName(value2) ?? "unknown_file");
  if (!options?.type) {
    const type3 = bits[0]?.type;
    if (typeof type3 === "string") {
      options = { ...options, type: type3 };
    }
  }
  return new File3(bits, name, options);
}
async function getBytes(value2) {
  let parts = [];
  if (typeof value2 === "string" || ArrayBuffer.isView(value2) || value2 instanceof ArrayBuffer) {
    parts.push(value2);
  } else if (isBlobLike(value2)) {
    parts.push(await value2.arrayBuffer());
  } else if (isAsyncIterableIterator(value2)) {
    for await (const chunk of value2) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value2}; constructor: ${value2?.constructor?.name}; props: ${propsForError(value2)}`);
  }
  return parts;
}
function propsForError(value2) {
  const props = Object.getOwnPropertyNames(value2);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value2) {
  return getStringFromMaybeBuffer(value2.name) || getStringFromMaybeBuffer(value2.filename) || getStringFromMaybeBuffer(value2.path)?.split(/[\\/]/).pop();
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return;
};
var isAsyncIterableIterator = (value2) => value2 != null && typeof value2 === "object" && typeof value2[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";

// node_modules/together-ai/core.mjs
var __classPrivateFieldSet = function(receiver, state, value2, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = contentType?.includes("application/json") || contentType?.includes("application/vnd.api+json");
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}

class APIPromise extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform4) {
    return new APIPromise(this.responsePromise, async (props) => transform4(await this.parseResponse(props), props));
  }
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
}

class APIClient {
  constructor({
    baseURL,
    maxRetries = 5,
    timeout = 60000,
    httpAgent,
    fetch: overridenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch ?? fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then(async (opts2) => {
      const body = opts2 && isBlobLike(opts2?.body) ? new DataView(await opts2.body.arrayBuffer()) : opts2?.body instanceof DataView ? opts2.body : opts2?.body instanceof ArrayBuffer ? new DataView(opts2.body) : opts2 && ArrayBuffer.isView(opts2?.body) ? new DataView(opts2.body.buffer) : opts2?.body;
      return { method, path, ...opts2, body };
    }));
  }
  getAPIList(path, Page, opts) {
    return this.requestAPIList(Page, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder3 = new TextEncoder;
        const encoded = encoder3.encode(body);
        return encoded.length.toString();
      }
    } else if (ArrayBuffer.isView(body)) {
      return body.byteLength.toString();
    }
    return null;
  }
  buildRequest(options, { retryCount = 0 } = {}) {
    const { method, path, query, headers = {} } = options;
    const body = ArrayBuffer.isView(options.body) || options.__binaryRequest && typeof options.body === "string" ? options.body : isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = options.timeout ?? this.timeout;
    const httpAgent = options.httpAgent ?? this.httpAgent ?? getDefaultAgent(url);
    const minAgentTimeout = timeout + 1000;
    if (typeof httpAgent?.options?.timeout === "number" && minAgentTimeout > (httpAgent.options.timeout ?? 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength, retryCount });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      signal: options.signal ?? null
    };
    return { req, url, timeout };
  }
  buildHeaders({ options, headers, contentLength, retryCount }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    if (getHeader(defaultHeaders, "x-stainless-retry-count") === undefined && getHeader(headers, "x-stainless-retry-count") === undefined) {
      reqHeaders["x-stainless-retry-count"] = String(retryCount);
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  async prepareOptions(options) {
  }
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : (Symbol.iterator in headers) ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error4, message2, headers) {
    return APIError.generate(status, error4, message2, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options, { retryCount: maxRetries - retriesRemaining });
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if (options.signal?.aborted) {
      throw new APIUserAbortError;
    }
    const controller = new AbortController;
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if (options.signal?.aborted) {
        throw new APIUserAbortError;
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError;
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? undefined : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_2, value2]) => typeof value2 !== "undefined").map(([key, value2]) => {
      if (typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value2)}`;
      }
      if (value2 === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new TogetherError(`Cannot stringify type ${typeof value2}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient().fetch.call(undefined, url, { signal: controller.signal, ...options }).finally(() => {
      clearTimeout(timeout);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1000;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1000)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 1;
    const maxRetryDelay = 10;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1000;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
}

class AbstractPage {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, undefined);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new TogetherError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value2] of params) {
        nextInfo.url.searchParams.set(key, value2);
      }
      nextOptions.query = undefined;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async* iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async* [(_AbstractPage_client = new WeakMap, Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
}

class PagePromise extends APIPromise {
  constructor(client, request, Page) {
    super(request, async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options));
  }
  async* [Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
}
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(headers.entries()), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern: pattern2 } of browserPatterns) {
    const match = pattern2.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return;
  }
};
var startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new TogetherError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new TogetherError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};
var readEnv = (env2) => {
  if (typeof process !== "undefined") {
    return process.env?.[env2]?.trim() ?? undefined;
  }
  if (typeof Deno !== "undefined") {
    return Deno.env?.get?.(env2)?.trim();
  }
  return;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== undefined) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process?.env?.["DEBUG"] === "true") {
    console.log(`Together:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isHeadersProtocol = (headers) => {
  return typeof headers?.get === "function";
};
var getHeader = (headers, header) => {
  const lowerCasedHeader = header.toLowerCase();
  if (isHeadersProtocol(headers)) {
    const intercapsHeader = header[0]?.toUpperCase() + header.substring(1).replace(/([^\w])(\w)/g, (_m, g1, g2) => g1 + g2.toUpperCase());
    for (const key of [header, lowerCasedHeader, header.toUpperCase(), intercapsHeader]) {
      const value2 = headers.get(key);
      if (value2) {
        return value2;
      }
    }
  }
  for (const [key, value2] of Object.entries(headers)) {
    if (key.toLowerCase() === lowerCasedHeader) {
      if (Array.isArray(value2)) {
        if (value2.length <= 1)
          return value2[0];
        console.warn(`Received ${value2.length} entries for the ${header} header, using the first entry.`);
        return value2[0];
      }
      return value2;
    }
  }
  return;
};

// node_modules/together-ai/resource.mjs
class APIResource {
  constructor(client) {
    this._client = client;
  }
}

// node_modules/together-ai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/together-ai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message2) => {
  return message2?.role === "assistant";
};
var isFunctionMessage = (message2) => {
  return message2?.role === "function";
};
var isToolMessage = (message2) => {
  return message2?.role === "tool";
};

// node_modules/together-ai/lib/AbstractChatCompletionRunner.mjs
var __classPrivateFieldSet2 = function(receiver, state, value2, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var __classPrivateFieldGet2 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_connectedPromise;
var _AbstractChatCompletionRunner_resolveConnectedPromise;
var _AbstractChatCompletionRunner_rejectConnectedPromise;
var _AbstractChatCompletionRunner_endPromise;
var _AbstractChatCompletionRunner_resolveEndPromise;
var _AbstractChatCompletionRunner_rejectEndPromise;
var _AbstractChatCompletionRunner_listeners;
var _AbstractChatCompletionRunner_ended;
var _AbstractChatCompletionRunner_errored;
var _AbstractChatCompletionRunner_aborted;
var _AbstractChatCompletionRunner_catchingPromiseCreated;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionCall;
var _AbstractChatCompletionRunner_getFinalFunctionCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_handleError;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;

class AbstractChatCompletionRunner {
  constructor() {
    _AbstractChatCompletionRunner_instances.add(this);
    this.controller = new AbortController;
    _AbstractChatCompletionRunner_connectedPromise.set(this, undefined);
    _AbstractChatCompletionRunner_resolveConnectedPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_rejectConnectedPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_endPromise.set(this, undefined);
    _AbstractChatCompletionRunner_resolveEndPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_rejectEndPromise.set(this, () => {
    });
    _AbstractChatCompletionRunner_listeners.set(this, {});
    this._chatCompletions = [];
    this.messages = [];
    _AbstractChatCompletionRunner_ended.set(this, false);
    _AbstractChatCompletionRunner_errored.set(this, false);
    _AbstractChatCompletionRunner_aborted.set(this, false);
    _AbstractChatCompletionRunner_catchingPromiseCreated.set(this, false);
    _AbstractChatCompletionRunner_handleError.set(this, (error4) => {
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_errored, true, "f");
      if (error4 instanceof Error && error4.name === "AbortError") {
        error4 = new APIUserAbortError;
      }
      if (error4 instanceof APIUserAbortError) {
        __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_aborted, true, "f");
        return this._emit("abort", error4);
      }
      if (error4 instanceof TogetherError) {
        return this._emit("error", error4);
      }
      if (error4 instanceof Error) {
        const TogetherError2 = new TogetherError2(error4.message);
        TogetherError2.cause = error4;
        return this._emit("error", TogetherError2);
      }
      return this._emit("error", new TogetherError(String(error4)));
    });
    __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_handleError, "f"));
    }, 0);
  }
  _addChatCompletion(chatCompletion) {
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message2 = chatCompletion.choices[0]?.message;
    if (message2)
      this._addMessage(message2);
    return chatCompletion;
  }
  _addMessage(message2, emit = true) {
    if (!("content" in message2))
      message2.content = null;
    this.messages.push(message2);
    if (emit) {
      this._emit("message", message2);
      if ((isFunctionMessage(message2) || isToolMessage(message2)) && message2.content) {
        this._emit("functionCallResult", message2.content);
      } else if (isAssistantMessage(message2) && message2.function_call) {
        this._emit("functionCall", message2.function_call);
      } else if (isAssistantMessage(message2) && message2.tool_calls) {
        for (const tool_call of message2.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionCall", tool_call.function);
          }
        }
      }
    }
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] || (__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] || (__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_endPromise, "f");
  }
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new TogetherError("stream ended without producing a ChatCompletion");
    return completion;
  }
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  async finalFunctionCall() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
  }
  async finalFunctionCallResult() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet2(this, _AbstractChatCompletionRunner_ended, true, "f");
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error4 = args[0];
      if (!__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error4);
      }
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectConnectedPromise, "f").call(this, error4);
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectEndPromise, "f").call(this, error4);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error4 = args[0];
      if (!__classPrivateFieldGet2(this, _AbstractChatCompletionRunner_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error4);
      }
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectConnectedPromise, "f").call(this, error4);
      __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_rejectEndPromise, "f").call(this, error4);
      this._emit("end");
    }
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(completions, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(chatCompletion);
  }
  async _runChatCompletion(completions, params, options) {
    for (const message2 of params.messages) {
      this._addMessage(message2, false);
    }
    return await this._createChatCompletion(completions, params, options);
  }
  async _runFunctions(completions, params, options) {
    const role = "function";
    const { function_call = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof function_call !== "string" && function_call?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.functions) {
      functionsByName[f.name || f.function.name] = f;
    }
    const functions = params.functions.map((f) => ({
      name: f.name || f.function.name,
      parameters: f.parameters,
      description: f.description
    }));
    for (const message2 of params.messages) {
      this._addMessage(message2, false);
    }
    for (let i = 0;i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(completions, {
        ...restParams,
        function_call,
        functions,
        messages: [...this.messages]
      }, options);
      const message2 = chatCompletion.choices[0]?.message;
      if (!message2) {
        throw new TogetherError(`missing message in ChatCompletion response`);
      }
      if (!message2.function_call)
        return;
      const { name, arguments: args } = message2.function_call;
      const fn = functionsByName[name];
      if (!fn) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. Available options are: ${functions.map((f) => JSON.stringify(f.name)).join(", ")}. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      } else if (singleFunctionToCall && singleFunctionToCall !== name) {
        const content2 = `Invalid function_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
        this._addMessage({ role, name, content: content2 });
        continue;
      }
      let parsed;
      try {
        parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
      } catch (error4) {
        this._addMessage({
          role,
          name,
          content: error4 instanceof Error ? error4.message : String(error4)
        });
        continue;
      }
      const rawContent = await fn.function(parsed, this);
      const content = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
      this._addMessage({ role, name, content });
      if (singleFunctionToCall)
        return;
    }
  }
  async _runTools(completions, params, options) {
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice?.function?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const functionsByName = {};
    for (const f of params.tools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? params.tools.map((t2) => t2.type === "function" ? {
      type: "function",
      function: {
        name: t2.function.name || t2.function.function.name,
        parameters: t2.function.parameters,
        description: t2.function.description
      }
    } : t2) : undefined;
    for (const message2 of params.messages) {
      this._addMessage(message2, false);
    }
    for (let i = 0;i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(completions, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message2 = chatCompletion.choices[0]?.message;
      if (!message2) {
        throw new TogetherError(`missing message in ChatCompletion response`);
      }
      if (!message2.tool_calls) {
        return;
      }
      for (const tool_call of message2.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${tools.map((f) => JSON.stringify(f.function.name)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error4) {
          const content2 = error4 instanceof Error ? error4.message : String(error4);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
}
_AbstractChatCompletionRunner_connectedPromise = new WeakMap, _AbstractChatCompletionRunner_resolveConnectedPromise = new WeakMap, _AbstractChatCompletionRunner_rejectConnectedPromise = new WeakMap, _AbstractChatCompletionRunner_endPromise = new WeakMap, _AbstractChatCompletionRunner_resolveEndPromise = new WeakMap, _AbstractChatCompletionRunner_rejectEndPromise = new WeakMap, _AbstractChatCompletionRunner_listeners = new WeakMap, _AbstractChatCompletionRunner_ended = new WeakMap, _AbstractChatCompletionRunner_errored = new WeakMap, _AbstractChatCompletionRunner_aborted = new WeakMap, _AbstractChatCompletionRunner_catchingPromiseCreated = new WeakMap, _AbstractChatCompletionRunner_handleError = new WeakMap, _AbstractChatCompletionRunner_instances = new WeakSet, _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i = this.messages.length;
  while (i-- > 0) {
    const message2 = this.messages[i];
    if (isAssistantMessage(message2)) {
      return { ...message2, content: message2.content ?? null };
    }
  }
  throw new TogetherError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionCall = function _AbstractChatCompletionRunner_getFinalFunctionCall2() {
  for (let i = this.messages.length - 1;i >= 0; i--) {
    const message2 = this.messages[i];
    if (isAssistantMessage(message2) && message2?.function_call) {
      return message2.function_call;
    }
    if (isAssistantMessage(message2) && message2?.tool_calls?.length) {
      return message2.tool_calls.at(-1)?.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionCallResult = function _AbstractChatCompletionRunner_getFinalFunctionCallResult2() {
  for (let i = this.messages.length - 1;i >= 0; i--) {
    const message2 = this.messages[i];
    if (isFunctionMessage(message2) && message2.content != null) {
      return message2.content;
    }
    if (isToolMessage(message2) && message2.content != null && this.messages.some((x) => x.role === "assistant" && x.tool_calls?.some((y) => y.type === "function" && y.id === message2.tool_call_id))) {
      return message2.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new TogetherError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === undefined ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/together-ai/lib/ChatCompletionStream.mjs
var __classPrivateFieldGet3 = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet3 = function(receiver, state, value2, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
};
var _ChatCompletionStream_instances;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_accumulateChatCompletion;

class ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor() {
    super(...arguments);
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, undefined);
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  static fromReadableStream(stream) {
    const runner = new ChatCompletionStream;
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(completions, params, options) {
    const runner = new ChatCompletionStream;
    runner._run(() => runner._runChatCompletion(completions, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(completions, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addChatCompletion(__classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError;
    }
    return this._addChatCompletion(__classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_currentChatCompletionSnapshot = new WeakMap, _ChatCompletionStream_instances = new WeakSet, _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest() {
    if (this.ended)
      return;
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, "f");
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk(chunk) {
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet3(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    const delta3 = chunk.choices[0]?.delta?.content;
    const snapshot = completion.choices[0]?.message;
    if (delta3 != null && snapshot?.role === "assistant" && snapshot?.content) {
      this._emit("content", delta3, snapshot.content);
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest() {
    if (this.ended) {
      throw new TogetherError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new TogetherError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, undefined, "f");
    return finalizeChatCompletion(snapshot);
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion(chunk) {
    var _a, _b, _c, _d, _e;
    let snapshot = __classPrivateFieldGet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest3 } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet3(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest3,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest3);
    }
    for (const { delta: delta3, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = {
          finish_reason,
          index,
          message: {},
          logprobs: { token_ids: [], token_logprobs: [], tokens: [] },
          ...other
        };
      }
      if (logprobs) {
        console.log({ logprobs });
        if (!choice.logprobs) {
          choice.logprobs = { token_ids: [], token_logprobs: [], tokens: [] };
        }
        (_a = choice.logprobs).token_ids ?? (_a.token_ids = []);
        choice.logprobs.token_ids.push(delta3.token_id ?? null);
        (_b = choice.logprobs).token_logprobs ?? (_b.token_logprobs = []);
        choice.logprobs.token_logprobs.push(logprobs ?? null);
        (_c = choice.logprobs).tokens ?? (_c.tokens = []);
        choice.logprobs.tokens.push(delta3.content ?? null);
      }
      if (finish_reason)
        choice.finish_reason = finish_reason;
      Object.assign(choice, other);
      if (!delta3)
        continue;
      const { content, function_call, role, tool_calls, ...rest4 } = delta3;
      Object.assign(choice.message, rest4);
      if (content)
        choice.message.content = (choice.message.content || "") + content;
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_d = choice.message.function_call).arguments ?? (_d.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type: type3, function: fn, ...rest5 } of tool_calls) {
          const tool_call = (_e = choice.message.tool_calls)[index2] ?? (_e[index2] = {});
          Object.assign(tool_call, rest5);
          if (id)
            tool_call.id = id;
          if (type3)
            tool_call.type = type3;
          if (fn)
            tool_call.function ?? (tool_call.function = { arguments: "" });
          if (fn?.name)
            tool_call.function.name = fn.name;
          if (fn?.arguments)
            tool_call.function.arguments += fn.arguments;
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(undefined);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: undefined, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: undefined, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: undefined, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
}
function finalizeChatCompletion(snapshot) {
  const { id, choices, created, model, system_fingerprint, ...rest3 } = snapshot;
  return {
    ...rest3,
    id,
    choices: choices.map(({ message: message2, finish_reason, index, logprobs, ...choiceRest }) => {
      if (!finish_reason)
        throw new TogetherError(`missing finish_reason for choice ${index}`);
      const { content = null, function_call, tool_calls, ...messageRest } = message2;
      const role = message2.role;
      if (!role)
        throw new TogetherError(`missing role for choice ${index}`);
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null)
          throw new TogetherError(`missing function_call.arguments for choice ${index}`);
        if (!name)
          throw new TogetherError(`missing function_call.name for choice ${index}`);
        return {
          ...choiceRest,
          message: { content, function_call: { arguments: args, name }, role },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type: type3, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null)
                throw new TogetherError(`missing choices[${index}].tool_calls[${i}].id\n${str(snapshot)}`);
              if (type3 == null)
                throw new TogetherError(`missing choices[${index}].tool_calls[${i}].type\n${str(snapshot)}`);
              if (name == null)
                throw new TogetherError(`missing choices[${index}].tool_calls[${i}].function.name\n${str(snapshot)}`);
              if (args == null)
                throw new TogetherError(`missing choices[${index}].tool_calls[${i}].function.arguments\n${str(snapshot)}`);
              return { ...toolRest, id: id2, type: type3, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
}
function str(x) {
  return JSON.stringify(x);
}

// node_modules/together-ai/resources/chat/completions.mjs
class Completions extends APIResource {
  create(body, options) {
    return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
  }
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client.chat.completions, body, options);
  }
}

// node_modules/together-ai/resources/chat/chat.mjs
class Chat extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
}
Chat.Completions = Completions;
// node_modules/together-ai/resources/completions.mjs
class Completions2 extends APIResource {
  create(body, options) {
    return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
  }
}
// node_modules/together-ai/resources/embeddings.mjs
class Embeddings extends APIResource {
  create(body, options) {
    return this._client.post("/embeddings", { body, ...options });
  }
}
// node_modules/together-ai/resources/files.mjs
class Files2 extends APIResource {
  retrieve(id, options) {
    return this._client.get(`/files/${id}`, options);
  }
  list(options) {
    return this._client.get("/files", options);
  }
  delete(id, options) {
    return this._client.delete(`/files/${id}`, options);
  }
  content(id, options) {
    return this._client.get(`/files/${id}/content`, { ...options, __binaryResponse: true });
  }
  upload(_2) {
    throw "please use together-ai/lib/upload";
  }
}
// node_modules/together-ai/resources/fine-tune.mjs
class FineTuneResource extends APIResource {
  create(body, options) {
    return this._client.post("/fine-tunes", { body, ...options });
  }
  retrieve(id, options) {
    return this._client.get(`/fine-tunes/${id}`, options);
  }
  list(options) {
    return this._client.get("/fine-tunes", options);
  }
  cancel(id, options) {
    return this._client.post(`/fine-tunes/${id}/cancel`, options);
  }
  download(query, options) {
    return this._client.get("/finetune/download", { query, ...options });
  }
  listEvents(id, options) {
    return this._client.get(`/fine-tunes/${id}/events`, options);
  }
}
// node_modules/together-ai/resources/images.mjs
class Images extends APIResource {
  create(body, options) {
    return this._client.post("/images/generations", { body, ...options });
  }
}
// node_modules/together-ai/resources/models.mjs
class Models extends APIResource {
  list(options) {
    return this._client.get("/models", options);
  }
}
// node_modules/together-ai/index.mjs
var _a;

class Together extends APIClient {
  constructor({ baseURL = readEnv("TOGETHER_BASE_URL"), apiKey = readEnv("TOGETHER_API_KEY"), ...opts } = {}) {
    if (apiKey === undefined) {
      throw new TogetherError("The TOGETHER_API_KEY environment variable is missing or empty; either provide it, or instantiate the Together client with an apiKey option, like new Together({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      ...opts,
      baseURL: baseURL || `https://api.together.xyz/v1`
    };
    super({
      baseURL: options.baseURL,
      timeout: options.timeout ?? 60000,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.chat = new Chat(this);
    this.completions = new Completions2(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files2(this);
    this.fineTune = new FineTuneResource(this);
    this.images = new Images(this);
    this.models = new Models(this);
    this._options = options;
    this.apiKey = apiKey;
  }
  rerank(body, options) {
    return this.post("/rerank", { body, ...options });
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
}
_a = Together;
Together.Together = _a;
Together.DEFAULT_TIMEOUT = 60000;
Together.TogetherError = TogetherError;
Together.APIError = APIError;
Together.APIConnectionError = APIConnectionError;
Together.APIConnectionTimeoutError = APIConnectionTimeoutError;
Together.APIUserAbortError = APIUserAbortError;
Together.NotFoundError = NotFoundError2;
Together.ConflictError = ConflictError;
Together.RateLimitError = RateLimitError;
Together.BadRequestError = BadRequestError;
Together.AuthenticationError = AuthenticationError;
Together.InternalServerError = InternalServerError2;
Together.PermissionDeniedError = PermissionDeniedError;
Together.UnprocessableEntityError = UnprocessableEntityError;
Together.toFile = toFile;
Together.fileFromPath = fileFromPath;
Together.Chat = Chat;
Together.Completions = Completions2;
Together.Embeddings = Embeddings;
Together.Files = Files2;
Together.FineTuneResource = FineTuneResource;
Together.Images = Images;
Together.Models = Models;

// src/services/together.service.ts
class TogetherService {
  client;
  embeddingModel = "togethercomputer/m2-bert-80M-8k-retrieval";
  constructor(apiKey) {
    console.log("\uD83D\uDD11 Initializing Together service...");
    this.client = new Together({ apiKey });
  }
  async createEmbedding(text) {
    try {
      console.log("\uD83D\uDCDD Creating embedding for text:", text.substring(0, 50) + "...");
      const response = await this.client.embeddings.create({
        model: "togethercomputer/m2-bert-80M-8k-retrieval",
        input: text
      });
      console.log("\u2705 Embedding created successfully");
      return response.data[0].embedding;
    } catch (error4) {
      console.error("\u274C Embedding creation failed:", error4);
      throw error4;
    }
  }
  async generateResponse(agent, messages, systemPrompt) {
    try {
      console.log("\uD83E\uDD16 Generating response for agent:", agent.name);
      console.log("\uD83D\uDCAC Messages count:", messages.length);
      console.log("\uD83C\uDFAF Calling Together API...");
      const response = await this.client.chat.completions.create({
        model: "meta-llama/Llama-3.3-70B-Instruct-Turbo",
        messages: [
          {
            role: "system",
            content: systemPrompt || agent.systemPrompt
          },
          ...messages.map((msg) => ({
            role: msg.role === "user" ? "user" : "assistant",
            content: msg.content
          }))
        ],
        temperature: agent.temperature || 0.7,
        max_tokens: 2000,
        top_p: 0.9,
        frequency_penalty: 0.3
      });
      if (!response?.choices?.[0]?.message?.content) {
        console.error("\u274C Invalid API response:", response);
        throw new Error("Invalid or empty response from language model");
      }
      const result = response.choices[0].message.content.trim();
      console.log("\u2705 Response generated:", result);
      return result;
    } catch (error4) {
      console.error("\u274C Response generation failed:", error4);
      throw error4;
    }
  }
  async generateText(prompt) {
    try {
      const response = await this.client.chat.completions.create({
        model: "meta-llama/Llama-3.3-70B-Instruct-Turbo",
        messages: [{ role: "user", content: prompt }],
        temperature: 0.7,
        max_tokens: 512
      });
      if (!response?.choices?.[0]?.message?.content) {
        throw new Error("Invalid or empty response from language model");
      }
      return response.choices[0].message.content.trim();
    } catch (error4) {
      console.error("Failed to generate text:", error4);
      throw error4;
    }
  }
}

// src/services/vector-store.service.ts
var import_pinecone = __toESM(require_dist2(), 1);

class VectorStoreService {
  togetherService;
  client;
  index;
  constructor(togetherService) {
    this.togetherService = togetherService;
    console.log("\uD83D\uDD11 Initializing Pinecone client...");
    this.client = new import_pinecone.Pinecone({
      apiKey: "pcsk_65eDVJ_2zSRjVC84GpjFKBrZeyojh5BjBoA7hbJX5ZFACTg32reLDb1dxHjZPpxkgc11dU"
    });
    this.index = this.client.index("aicity");
  }
  async query({
    vector,
    filter,
    topK = 5,
    includeMetadata = true
  }) {
    try {
      const response = await this.index.query({
        vector,
        filter,
        topK,
        includeValues: false,
        includeMetadata
      });
      console.log("Raw Pinecone response:", JSON.stringify(response, null, 2));
      if (!response || typeof response !== "object") {
        console.warn("Invalid response from Pinecone");
        return { matches: [] };
      }
      return {
        matches: response.matches || [],
        usage: response.usage
      };
    } catch (error4) {
      console.error("Pinecone query failed:", error4);
      throw error4;
    }
  }
  async upsert({
    id,
    values,
    metadata
  }) {
    try {
      if (metadata.timestamp && typeof metadata.timestamp === "string") {
        metadata.timestamp = parseInt(metadata.timestamp);
      }
      const flatMetadata = Object.entries(metadata).reduce((acc, [key, value2]) => {
        if (value2 === undefined || value2 === null) {
          return acc;
        }
        if (Array.isArray(value2)) {
          acc[key] = value2.join(",");
        } else if (typeof value2 === "object") {
          acc[key] = JSON.stringify(value2);
        } else {
          acc[key] = value2.toString();
        }
        return acc;
      }, {});
      await this.index.upsert([
        {
          id,
          values,
          metadata: flatMetadata
        }
      ]);
      return { success: true, id };
    } catch (error4) {
      console.error("Upsert failed:", error4);
      throw error4;
    }
  }
  async upsertMany(data) {
    try {
      const processedVectors = data.vectors.map((vector) => {
        const flatMetadata = Object.entries(vector.metadata).reduce((acc, [key, value2]) => {
          if (value2 === undefined || value2 === null) {
            return acc;
          }
          if (Array.isArray(value2)) {
            acc[key] = value2.join(",");
          } else if (typeof value2 === "object") {
            acc[key] = JSON.stringify(value2);
          } else {
            acc[key] = value2.toString();
          }
          return acc;
        }, {});
        return {
          ...vector,
          metadata: flatMetadata
        };
      });
      await this.index.upsert(processedVectors, data.namespace);
      return { ...data, vectors: processedVectors };
    } catch (error4) {
      console.error("Pinecone upsert failed:", error4);
      throw error4;
    }
  }
  async createEmbedding(text) {
    return this.togetherService.createEmbedding(text);
  }
  async ping() {
    try {
      await this.client.describeIndex("aicity");
      return true;
    } catch (error4) {
      console.error("Pinecone ping failed:", error4);
      return false;
    }
  }
  async close() {
    console.log("\uD83D\uDD11 Closing Pinecone client...");
  }
  async analyzeSentiment(content) {
    try {
      const prompt = `Analyze the sentiment and significance of this interaction. Rate it from 0 to 1 where 1 is extremely significant/emotional and 0 is mundane/neutral. Only respond with the number.
      
      Content: "${content}"
      
      Rating:`;
      const sentimentAnalyzer = {
        id: "sentiment-analyzer",
        name: "Sentiment Analyzer",
        personality: "analytical",
        systemPrompt: "You are a sentiment analyzer that only responds with a number between 0 and 1.",
        interests: ["sentiment analysis"],
        preferredStyle: "professional",
        traits: {
          curiosity: 0.5,
          enthusiasm: 0.5,
          formality: 1,
          empathy: 0.8,
          analyticalThinking: 1,
          creativity: 0.3
        },
        contextualResponses: {
          rain: ["Analyzing sentiment in rainy conditions."],
          sunny: ["Analyzing sentiment in sunny conditions."]
        },
        memoryWindowSize: 1,
        emotionalRange: {
          min: 0,
          max: 1
        }
      };
      const message2 = {
        id: crypto.randomUUID(),
        agentId: "user",
        content: prompt,
        timestamp: Date.now(),
        role: "user",
        topics: [],
        sentiment: undefined
      };
      const response = await this.togetherService.generateResponse(sentimentAnalyzer, [message2], "You are a sentiment analyzer that only responds with a number between 0 and 1.");
      const significance = parseFloat(response.trim());
      return isNaN(significance) ? 0.5 : Math.max(0, Math.min(1, significance));
    } catch (error4) {
      console.error("Failed to analyze sentiment:", error4);
      return 0.5;
    }
  }
}

// src/services/conversation.service.ts
import { EventEmitter } from "events";
class ConversationService extends EventEmitter {
  togetherService;
  vectorStore;
  cityService;
  agentCollaboration;
  cityMemory;
  spatialCoordination;
  agentCulture;
  emergencyService;
  cityEvents;
  CONVERSATION_EXPIRY = 30 * 60 * 1000;
  MAX_HISTORY_LENGTH = 100;
  TOPIC_EXHAUSTION_THRESHOLD = 5;
  constructor(togetherService, vectorStore, cityService, agentCollaboration, cityMemory, spatialCoordination, agentCulture, emergencyService, cityEvents) {
    super();
    this.togetherService = togetherService;
    this.vectorStore = vectorStore;
    this.cityService = cityService;
    this.agentCollaboration = agentCollaboration;
    this.cityMemory = cityMemory;
    this.spatialCoordination = spatialCoordination;
    this.agentCulture = agentCulture;
    this.emergencyService = emergencyService;
    this.cityEvents = cityEvents;
    this.setupEventHandlers();
  }
  setupEventHandlers() {
    this.emergencyService.on("emergency", async (emergency) => {
      const affectedConversations = await this.findConversationsInArea(emergency.location, emergency.affectedArea.radius);
      for (const conv of affectedConversations) {
        await this.injectEmergencyContext(conv, emergency);
      }
    });
    this.cityEvents.on("eventCreated", async (event) => {
      const nearbyConversations = await this.findConversationsInArea(event.location, 500);
      for (const conv of nearbyConversations) {
        await this.injectCulturalContext(conv, event);
      }
    });
    this.cityService.on("moodUpdate", async (mood) => {
      await this.adjustConversationStyles(mood);
    });
  }
  async findConversationsInArea(location, radius) {
    const result = await this.vectorStore.query({
      vector: await this.vectorStore.createEmbedding(`location: ${JSON.stringify(location)}`),
      filter: {
        type: { $eq: "conversation" },
        timestamp: { $gt: Date.now() - this.CONVERSATION_EXPIRY }
      },
      topK: 20
    });
    return result.matches.filter((match) => this.isWithinRadius(match.metadata.coordinates, location, radius)).map((match) => match.metadata.conversationId);
  }
  isWithinRadius(point1, point2, radius) {
    if (!point1 || !point2)
      return false;
    const [lat1, lon1] = point1;
    const [lat2, lon2] = point2;
    const R = 6371000;
    const \u{3c6}1 = lat1 * Math.PI / 180;
    const \u{3c6}2 = lat2 * Math.PI / 180;
    const \u{394}_ = (lat2 - lat1) * Math.PI / 180;
    const \u{394}_2 = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(\u{394}_ / 2) * Math.sin(\u{394}_ / 2) + Math.cos(\u{3c6}1) * Math.cos(\u{3c6}2) * Math.sin(\u{394}_2 / 2) * Math.sin(\u{394}_2 / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c;
    return distance <= radius;
  }
  async injectEmergencyContext(conversationId, emergency) {
    const systemMessage = {
      id: crypto.randomUUID(),
      agentId: "system",
      content: `\u26A0\uFE0F EMERGENCY ALERT: ${emergency.description}. Please be aware and adjust your activities accordingly.`,
      timestamp: Date.now(),
      role: "assistant",
      metadata: {
        emergencyId: emergency.id,
        type: emergency.type,
        severity: emergency.priority,
        isEmergency: true
      }
    };
    await this.addMessage(conversationId, "system", systemMessage.content);
  }
  async injectCulturalContext(conversationId, event) {
    const systemMessage = {
      id: crypto.randomUUID(),
      agentId: "system",
      content: `\uD83C\uDF89 Cultural Event: "${event.title}" is happening nearby. This might be relevant to your conversation.`,
      timestamp: Date.now(),
      role: "assistant",
      metadata: {
        eventId: event.id,
        type: event.type,
        culturalImpact: event.culturalImpact
      }
    };
    await this.addMessage(conversationId, "system", systemMessage.content);
  }
  async adjustConversationStyles(cityMood) {
    const activeConversations = await this.getActiveInteractions();
    for (const conversation of activeConversations) {
      const newStyle = this.determineConversationStyle(cityMood, conversation);
      await this.updateConversationStyle(conversation[0]?.id, newStyle);
    }
  }
  determineConversationStyle(cityMood, conversation) {
    const moodValue = cityMood.overall;
    const hasEmergency = conversation.some((m) => m.metadata?.isEmergency);
    if (hasEmergency)
      return "formal";
    if (moodValue > 0.7)
      return "casual";
    if (moodValue < 0.3)
      return "supportive";
    return "formal";
  }
  async updateConversationStyle(conversationId, style) {
    await this.vectorStore.upsert({
      id: `style-${conversationId}`,
      values: await this.vectorStore.createEmbedding(`conversation style ${style}`),
      metadata: {
        type: "conversation",
        conversationId,
        style,
        timestamp: Date.now()
      }
    });
  }
  async generateMessage(agent, context = {}) {
    const cityContext = await this.cityService.getContext();
    const cityMetrics = {
      activityLevel: await this.cityService.getActivityLevel(),
      emergencyStatus: await this.cityService.getEmergencyStatus(),
      weatherConditions: (await this.cityService.getCurrentWeather()).condition,
      culturalEvents: await this.cityEvents.getCurrentEvents()
    };
    const culturalContext = context.location ? await this.agentCulture.enrichAgentContext(agent, context.location.districtId) : undefined;
    const activeCollaboration = context.collaborationId ? await this.agentCollaboration.getSessionStatus(context.collaborationId) : undefined;
    const relevantMemories = context.location ? await this.cityMemory.getDistrictMemories(context.location.districtId) : undefined;
    const isEmergency = context.urgency && context.urgency > 0.8;
    const prompt = this.buildEnhancedPrompt(agent, {
      cityContext,
      cityMetrics,
      culturalContext,
      activeCollaboration,
      relevantMemories,
      isEmergency,
      ...context
    });
    const response = await this.togetherService.generateResponse(agent, [
      {
        id: crypto.randomUUID(),
        agentId: "system",
        content: prompt,
        timestamp: Date.now(),
        role: "user"
      }
    ]);
    await this.storeConversationContext(agent, response, {
      ...context,
      cityMetrics
    });
    if (isEmergency) {
      await this.handleEmergencyResponse(agent, response, context);
    }
    return response;
  }
  buildEnhancedPrompt(agent, context) {
    return `You are ${agent.name}, ${agent.personality}.

Current City Context:
${this.formatCityContext(context.cityContext)}
${this.formatCityMetrics(context.cityMetrics)}

${context.culturalContext ? this.formatCulturalContext(context.culturalContext) : ""}
${context.activeCollaboration ? this.formatCollaborationContext(context.activeCollaboration) : ""}
${context.relevantMemories ? this.formatMemoryContext(context.relevantMemories) : ""}

${context.isEmergency ? "\uD83D\uDEA8 URGENT: Immediate response required." : ""}

Location: ${context.location ? `${context.location.districtId} district${context.location.nearbyLandmarks ? `, near ${context.location.nearbyLandmarks.join(", ")}` : ""}` : "Unspecified"}
Current Activity: ${context.location?.currentActivity || "None specified"}
Topic: ${context.topic || "General conversation"}

Consider:
1. Your role and expertise
2. Current city conditions and metrics
3. Cultural sensitivities and ongoing events
4. Historical context and district-specific issues
5. Ongoing collaborations and activities
6. Emergency protocols if applicable
7. Local landmarks and spatial context
8. Current city mood and social dynamics

Respond naturally while maintaining your character and considering all available context.`;
  }
  formatCityMetrics(metrics) {
    if (!metrics)
      return "";
    return `
City Metrics:
- Activity Level: ${(metrics.activityLevel * 100).toFixed(1)}%
- Emergency Status: ${metrics.emergencyStatus}
- Weather: ${metrics.weatherConditions}
- Active Cultural Events: ${metrics.culturalEvents.length}`;
  }
  formatCityContext(context) {
    return `- Weather: ${context.weather.condition}, ${context.weather.temperature}\xB0C
- City Mood: ${context.mood.dominantEmotion}
- Community Status: ${context.mood.factors.community.toFixed(2)}
- Stress Level: ${context.mood.factors.stress.toFixed(2)}`;
  }
  formatCulturalContext(context) {
    return `Cultural Context:
- Cultural Sensitivity: ${context.culturalSensitivity.toFixed(2)}
- Community Engagement: ${context.communityEngagement.level.toFixed(2)}
- Active Cultural Events: ${context.currentEvents.length}`;
  }
  formatCollaborationContext(collaboration) {
    return `Active Collaboration:
- Status: ${collaboration.status}
- Progress: ${(collaboration.metrics.progressRate * 100).toFixed(1)}%
- Consensus Level: ${(collaboration.metrics.consensusLevel * 100).toFixed(1)}%`;
  }
  formatMemoryContext(memories) {
    return `Relevant District Memories:
${memories.memories.slice(0, 3).map((m) => `- ${m.description}`).join("\n")}`;
  }
  async addMessage(conversationId, agentId, content) {
    const sentiment = await this.analyzeSentiment(content);
    const topics = await this.extractTopics(content);
    const message2 = {
      id: crypto.randomUUID(),
      agentId,
      content,
      timestamp: Date.now(),
      role: "assistant",
      sentiment,
      topics
    };
    await this.vectorStore.upsert({
      id: `message-${message2.id}`,
      values: await this.vectorStore.createEmbedding(content),
      metadata: {
        type: "conversation",
        conversationId,
        agentId,
        sentiment: sentiment?.toString(),
        timestamp: message2.timestamp
      }
    });
    this.emit("messageAdded", { conversationId, message: message2 });
  }
  async generateAgentInteraction(agent1, agent2) {
    const conversationId = crypto.randomUUID();
    const context1 = await this.buildInteractionContext(agent1, agent2);
    const message1 = await this.generateMessage(agent1, context1);
    const context2 = await this.buildInteractionContext(agent2, agent1, message1);
    const message2 = await this.generateMessage(agent2, context2);
    const messages = [
      await this.createMessage(agent1.id, message1),
      await this.createMessage(agent2.id, message2)
    ];
    return messages;
  }
  async getActiveInteractions() {
    const recentMessages = await this.vectorStore.query({
      vector: await this.vectorStore.createEmbedding("recent agent interactions"),
      filter: {
        type: { $eq: "conversation" },
        timestamp: { $gt: Date.now() - 5 * 60 * 1000 }
      },
      topK: 100
    });
    const conversations = new Map;
    for (const match of recentMessages.matches) {
      const conversationId = match.metadata.conversationId;
      if (!conversations.has(conversationId)) {
        conversations.set(conversationId, []);
      }
      conversations.get(conversationId)?.push(this.messageFromMetadata(match));
    }
    return Array.from(conversations.values());
  }
  async buildInteractionContext(agent, otherAgent, previousMessage) {
    return {
      topic: `Interaction with ${otherAgent.name}`,
      previousMessage,
      otherAgentPersonality: otherAgent.personality,
      otherAgentInterests: otherAgent.interests
    };
  }
  async createMessage(agentId, content) {
    return {
      id: crypto.randomUUID(),
      agentId,
      content,
      timestamp: Date.now(),
      role: "assistant"
    };
  }
  messageFromMetadata(match) {
    return {
      id: match.id,
      agentId: match.metadata.agentId,
      content: match.metadata.content || "",
      timestamp: match.metadata.timestamp,
      role: match.metadata.role || "assistant",
      sentiment: match.metadata.sentiment ? parseFloat(match.metadata.sentiment) : undefined,
      topics: match.metadata.topics
    };
  }
  async analyzeSentiment(content) {
    const positiveWords = /good|great|excellent|happy|positive/gi;
    const negativeWords = /bad|poor|terrible|sad|negative/gi;
    const positiveCount = (content.match(positiveWords) || []).length;
    const negativeCount = (content.match(negativeWords) || []).length;
    return (positiveCount - negativeCount + 1) / 2;
  }
  async extractTopics(content) {
    const topics = new Set;
    const commonTopics = {
      technology: /tech|digital|software|computer/i,
      environment: /nature|climate|green|eco/i,
      social: /community|people|social|cultural/i,
      economy: /business|economy|market|financial/i
    };
    Object.entries(commonTopics).forEach(([topic, pattern2]) => {
      if (pattern2.test(content)) {
        topics.add(topic);
      }
    });
    return Array.from(topics);
  }
  async generateGroupResponse(agents2, context = {}) {
    const responses = await Promise.all(agents2.map((agent) => this.generateMessage(agent, context)));
    const combinedContext = responses.join("\n\n");
    const groupPrompt = `Based on the following agent responses, generate a cohesive group response that incorporates the key points and maintains consensus:\n\n${combinedContext}`;
    const sentimentAnalyzer = {
      id: "group-response",
      name: "Group Response Generator",
      personality: "analytical",
      systemPrompt: "Generate a cohesive group response that maintains consensus.",
      interests: ["group dynamics"],
      preferredStyle: "formal",
      traits: {
        curiosity: 0.5,
        enthusiasm: 0.5,
        formality: 0.8,
        empathy: 0.8,
        analyticalThinking: 1,
        creativity: 0.7
      },
      memoryWindowSize: 5,
      emotionalRange: {
        min: 0,
        max: 1
      }
    };
    return await this.togetherService.generateResponse(sentimentAnalyzer, [
      {
        id: crypto.randomUUID(),
        agentId: "system",
        content: groupPrompt,
        timestamp: Date.now(),
        role: "user"
      }
    ]);
  }
  async getConversation(conversationId) {
    const messages = await this.vectorStore.query({
      vector: await this.vectorStore.createEmbedding(`conversation ${conversationId}`),
      filter: {
        type: { $eq: "conversation" },
        conversationId: { $eq: conversationId }
      },
      topK: 100
    });
    return messages.matches.map((match) => this.messageFromMetadata(match)).sort((a, b) => a.timestamp - b.timestamp);
  }
  async getState(conversationId) {
    const messages = await this.getConversation(conversationId);
    const lastMessage = messages[messages.length - 1];
    const now = Date.now();
    return {
      conversationId,
      lastMessageTimestamp: lastMessage?.timestamp || now,
      lastInteractionTime: lastMessage?.timestamp || now,
      messageCount: messages.length,
      participants: Array.from(new Set(messages.map((m) => m.agentId))),
      topics: this.aggregateTopics(messages),
      currentTopics: new Set(this.aggregateTopics(messages)),
      sentiment: this.calculateAverageSentiment(messages),
      status: this.determineConversationStatus(messages),
      momentum: messages.length > 0 ? Math.min(1, messages.length / 10) : 0,
      silenceDuration: lastMessage ? now - lastMessage.timestamp : 0,
      silenceProbability: lastMessage ? Math.min(1, (now - lastMessage.timestamp) / (30 * 60 * 1000)) : 1,
      interactionCount: messages.length,
      timeOfDay: new Date().toLocaleTimeString(),
      topicExhaustion: new Map(this.aggregateTopics(messages).map((topic) => [topic, 0])),
      currentStyle: "casual",
      emotionalState: 0,
      turnsInCurrentTopic: 0
    };
  }
  aggregateTopics(messages) {
    const topics = new Set;
    messages.forEach((message2) => {
      message2.topics?.forEach((topic) => topics.add(topic));
    });
    return Array.from(topics);
  }
  calculateAverageSentiment(messages) {
    const sentiments = messages.map((m) => m.sentiment).filter((s) => s !== undefined);
    return sentiments.length ? sentiments.reduce((a, b) => a + b, 0) / sentiments.length : 0.5;
  }
  determineConversationStatus(messages) {
    if (messages.length === 0)
      return "inactive";
    const lastMessageTime = messages[messages.length - 1].timestamp;
    const timeSinceLastMessage = Date.now() - lastMessageTime;
    if (timeSinceLastMessage > 30 * 60 * 1000)
      return "inactive";
    if (timeSinceLastMessage > 5 * 60 * 1000)
      return "idle";
    return "active";
  }
  async getConversations() {
    const messages = await this.vectorStore.query({
      vector: await this.vectorStore.createEmbedding("all conversations"),
      filter: {
        type: { $eq: "conversation" }
      },
      topK: 1000
    });
    const conversationMap = new Map;
    messages.matches.forEach((match) => {
      const conversationId = match.metadata.conversationId;
      if (!conversationMap.has(conversationId)) {
        conversationMap.set(conversationId, []);
      }
      conversationMap.get(conversationId)?.push(this.messageFromMetadata(match));
    });
    return Array.from(conversationMap.values()).map((messages2) => messages2.sort((a, b) => a.timestamp - b.timestamp));
  }
  async storeConversationContext(agent, response, context) {
    const coordinates = context.location?.coordinates;
    await this.vectorStore.upsert({
      id: `conv-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(response),
      metadata: {
        type: "conversation",
        agentId: agent.id,
        districtId: context.location?.districtId,
        coordinates: coordinates ? [`${coordinates[0]}`, `${coordinates[1]}`] : undefined,
        activityLevel: context.cityMetrics?.activityLevel?.toString() || "0",
        status: context.cityMetrics?.emergencyStatus || "normal",
        timestamp: Date.now()
      }
    });
  }
  async handleEmergencyResponse(agent, response, context) {
    if (context.location) {
      await this.emergencyService.handleEmergency({
        id: `emergency-${Date.now()}`,
        type: "medical" /* MEDICAL */,
        description: response,
        location: context.location,
        priority: "high",
        timestamp: Date.now(),
        affectedArea: {
          districtIds: [context.location.districtId],
          radius: 100
        },
        status: "reported",
        responseUnits: []
      });
    }
  }
}

// src/services/city.service.ts
import { EventEmitter as EventEmitter2 } from "events";

// src/utils/city-context.ts
class CityContextManager {
  context;
  updateCallbacks = [];
  constructor(initialContext) {
    this.context = {
      ...this.getDefaultContext(),
      ...initialContext
    };
  }
  getDefaultContext() {
    return {
      districts: new Map,
      agents: new Map,
      transport: new Map,
      state: {
        time: new Date,
        weather: {
          condition: "clear",
          temperature: 20,
          humidity: 60
        },
        population: 0,
        activeEvents: [],
        resourceUtilization: {
          power: 0.5,
          water: 0.4,
          transport: 0.6
        },
        alerts: []
      },
      metrics: {
        sustainability: 0.7,
        livability: 0.8,
        efficiency: 0.6,
        safety: 0.9
      }
    };
  }
  updateContext(update) {
    this.context = {
      ...this.context,
      ...update,
      state: {
        ...this.context.state,
        ...update.state
      },
      metrics: {
        ...this.context.metrics,
        ...update.metrics
      }
    };
    this.notifyUpdate({
      type: "state",
      data: this.context,
      timestamp: Date.now(),
      source: "cityContext"
    });
  }
  onUpdate(callback) {
    this.updateCallbacks.push(callback);
  }
  notifyUpdate(update) {
    this.updateCallbacks.forEach((callback) => callback(update));
  }
  getContext() {
    return this.context;
  }
}

// src/services/city.service.ts
class CityService extends EventEmitter2 {
  metricsService;
  contextManager;
  currentWeather;
  cityMood;
  metricsHistory = [];
  emergencyStatus = "normal";
  activityLevel = 0.5;
  constructor(metricsService) {
    super();
    this.metricsService = metricsService;
    this.contextManager = new CityContextManager;
    this.currentWeather = this.initializeWeather();
    this.cityMood = this.initializeMood();
    this.setupEventHandlers();
    this.startMetricsTracking();
  }
  initializeWeather() {
    return {
      condition: "clear",
      temperature: 20,
      humidity: 60,
      windSpeed: 5,
      precipitation: 0,
      forecast: [
        {
          condition: "clear",
          temperature: 22,
          timestamp: Date.now() + 3600000
        }
      ]
    };
  }
  initializeMood() {
    return {
      overall: 0.7,
      factors: {
        happiness: 0.7,
        stress: 0.3,
        energy: 0.6,
        community: 0.8
      },
      trends: [
        {
          timestamp: Date.now(),
          value: 0.7
        }
      ],
      dominantEmotion: "positive"
    };
  }
  setupEventHandlers() {
    this.contextManager.onUpdate((update) => {
      this.emit("cityUpdate", update);
    });
    this.on("emergencyAlert", (status) => {
      this.emergencyStatus = status;
      this.updateMetricsSnapshot();
    });
    this.on("activityLevelChanged", (level) => {
      this.activityLevel = level;
      this.updateMetricsSnapshot();
    });
  }
  startMetricsTracking() {
    setInterval(() => this.updateMetricsSnapshot(), 5 * 60 * 1000);
  }
  async updateMetricsSnapshot() {
    const snapshot = {
      timestamp: Date.now(),
      weather: this.currentWeather,
      mood: this.cityMood,
      activityLevel: this.activityLevel,
      emergencyStatus: this.emergencyStatus,
      lastUpdate: Date.now()
    };
    this.metricsHistory.push(snapshot);
    if (this.metricsHistory.length > 288) {
      this.metricsHistory.shift();
    }
    await this.metricsService.updateMetrics({
      sustainability: {
        airQualityIndex: this.currentWeather.condition === "clear" ? 150 : 100,
        waterQualityScore: 0.8,
        biodiversityIndex: 0.6,
        carbonEmissions: this.activityLevel * 20,
        renewableEnergyRatio: 0.3,
        greenSpaceIndex: 0.4
      },
      social: {
        communityWellbeing: this.cityMood.factors.community,
        healthcareAccessScore: 0.75,
        educationQualityIndex: 0.8,
        culturalEngagement: 3.5,
        civicParticipation: this.cityMood.factors.energy
      },
      safety: {
        crimeRate: this.emergencyStatus === "crisis" ? 4.2 : 2.1,
        emergencyResponseTime: this.emergencyStatus === "alert" ? 12 : 8.5,
        publicTrustIndex: this.cityMood.factors.happiness,
        disasterReadiness: this.emergencyStatus === "normal" ? 0.8 : 0.6
      }
    });
    this.emit("metricsUpdated", snapshot);
  }
  getContext() {
    return this.contextManager.getContext();
  }
  async getCurrentWeather() {
    return this.currentWeather;
  }
  async getCityMood() {
    return this.cityMood;
  }
  async getMetricsHistory(hours = 24) {
    const cutoffTime = Date.now() - hours * 60 * 60 * 1000;
    return this.metricsHistory.filter((snapshot) => snapshot.timestamp >= cutoffTime);
  }
  async getEmergencyStatus() {
    return this.emergencyStatus;
  }
  async getActivityLevel() {
    return this.activityLevel;
  }
  async broadcastEvent(eventType, eventData) {
    this.emit("cityEvent", { type: eventType, data: eventData });
    return true;
  }
  async updateWeather(weather) {
    this.currentWeather = { ...this.currentWeather, ...weather };
    this.emit("weatherUpdate", this.currentWeather);
    this.updateMetricsSnapshot();
  }
  async updateMood(moodFactors) {
    this.cityMood.factors = { ...this.cityMood.factors, ...moodFactors };
    this.cityMood.overall = Object.values(this.cityMood.factors).reduce((a, b) => a + b, 0) / 4;
    this.cityMood.trends.push({
      timestamp: Date.now(),
      value: this.cityMood.overall
    });
    this.cityMood.dominantEmotion = this.cityMood.overall > 0.6 ? "positive" : this.cityMood.overall < 0.4 ? "negative" : "neutral";
    this.emit("moodUpdate", this.cityMood);
    this.updateMetricsSnapshot();
  }
  async updateActivityLevel(level) {
    if (level < 0 || level > 1) {
      throw new Error("Activity level must be between 0 and 1");
    }
    this.activityLevel = level;
    this.emit("activityLevelChanged", level);
    this.updateMetricsSnapshot();
  }
  async setEmergencyStatus(status) {
    this.emergencyStatus = status;
    this.emit("emergencyAlert", status);
    this.updateMetricsSnapshot();
  }
}

// src/services/analytics.service.ts
import { EventEmitter as EventEmitter3 } from "events";

class AnalyticsService extends EventEmitter3 {
  topicTrends = new Map;
  interactionStats = new Map;
  moodHistory = [];
  activeAgentTimestamps = new Map;
  ACTIVITY_TIMEOUT = 5 * 60 * 1000;
  performanceMetrics = {
    averageResponseTime: 0,
    peakLoadTimestamp: 0,
    activeAgents: 0,
    resourceUtilization: 0
  };
  constructor() {
    super();
    this.startActivityMonitoring();
  }
  startActivityMonitoring() {
    setInterval(() => this.updateActiveAgents(), 60 * 1000);
  }
  updateActiveAgents() {
    const now = Date.now();
    let activeCount = 0;
    this.activeAgentTimestamps.forEach((timestamp, agentId) => {
      if (now - timestamp <= this.ACTIVITY_TIMEOUT) {
        activeCount++;
      } else {
        this.activeAgentTimestamps.delete(agentId);
      }
    });
    this.performanceMetrics.activeAgents = activeCount;
    this.emit("activeAgentsUpdated", activeCount);
  }
  trackAgentActivity(agentId) {
    this.activeAgentTimestamps.set(agentId, Date.now());
    this.updateActiveAgents();
  }
  trackInteraction(agent, message2) {
    this.trackAgentActivity(agent.id);
    const startTime = Date.now();
    const stats = this.interactionStats.get(agent.id) || {
      agentId: agent.id,
      totalInteractions: 0,
      averageSentiment: 0,
      topTopics: [],
      responseTime: 0,
      effectivenessScore: 0
    };
    stats.totalInteractions++;
    if (message2.sentiment !== undefined) {
      stats.averageSentiment = (stats.averageSentiment * (stats.totalInteractions - 1) + message2.sentiment) / stats.totalInteractions;
    }
    if (message2.topics) {
      this.updateTopicTrends(message2.topics, message2.sentiment);
      this.updateAgentTopics(stats, message2.topics);
    }
    const responseTime = Date.now() - startTime;
    stats.responseTime = stats.responseTime ? (stats.responseTime + responseTime) / 2 : responseTime;
    stats.effectivenessScore = this.calculateEffectivenessScore(stats.averageSentiment, stats.responseTime);
    this.interactionStats.set(agent.id, stats);
    this.updatePerformanceMetrics(responseTime);
  }
  async getTopicTrends() {
    return Array.from(this.topicTrends.values()).sort((a, b) => b.frequency - a.frequency).slice(0, 10);
  }
  async getInteractionStats() {
    return Array.from(this.interactionStats.values());
  }
  async getMoodHistory() {
    return this.moodHistory.slice(-100);
  }
  async getPerformanceMetrics() {
    return this.performanceMetrics;
  }
  updateTopicTrends(topics, sentiment) {
    const timestamp = Date.now();
    topics.forEach((topic) => {
      const trend = this.topicTrends.get(topic) || {
        topic,
        frequency: 0,
        sentiment: 0,
        momentum: 0,
        peakTime: timestamp
      };
      const oldFrequency = trend.frequency;
      trend.frequency++;
      if (sentiment) {
        trend.sentiment = (trend.sentiment * oldFrequency + sentiment) / trend.frequency;
      }
      trend.momentum = (trend.frequency - oldFrequency) / (timestamp - (trend.peakTime || timestamp));
      if (trend.frequency > oldFrequency) {
        trend.peakTime = timestamp;
      }
      this.topicTrends.set(topic, trend);
    });
  }
  updateAgentTopics(stats, topics) {
    const topicFrequencies = new Map;
    topics.forEach((topic) => {
      topicFrequencies.set(topic, (topicFrequencies.get(topic) || 0) + 1);
    });
    stats.topTopics = Array.from(topicFrequencies.entries()).sort((a, b) => b[1] - a[1]).slice(0, 5).map(([topic]) => topic);
  }
  calculateEffectivenessScore(sentiment, responseTime) {
    const normalizedTime = Math.min(1, 5000 / responseTime);
    return sentiment * 0.7 + normalizedTime * 0.3;
  }
  updatePerformanceMetrics(responseTime) {
    const timestamp = Date.now();
    this.performanceMetrics.averageResponseTime = (this.performanceMetrics.averageResponseTime + responseTime) / 2;
    const currentLoad = this.interactionStats.size;
    if (currentLoad > this.performanceMetrics.activeAgents) {
      this.performanceMetrics.peakLoadTimestamp = timestamp;
      this.performanceMetrics.activeAgents = currentLoad;
    }
    this.performanceMetrics.resourceUtilization = currentLoad / 100 * (this.performanceMetrics.averageResponseTime / 5000);
  }
  trackMood(mood) {
    this.moodHistory.push({
      timestamp: Date.now(),
      mood
    });
    if (this.moodHistory.length > 1000) {
      this.moodHistory.shift();
    }
    this.analyzeMoodTrends();
  }
  analyzeMoodTrends() {
    if (this.moodHistory.length < 2)
      return;
    const recentMoods = this.moodHistory.slice(-10);
    const moodTrend = recentMoods.reduce((acc, curr, idx, arr) => {
      if (idx === 0)
        return acc;
      return acc + (curr.mood - arr[idx - 1].mood);
    }, 0) / (recentMoods.length - 1);
    if (Math.abs(moodTrend) > 0.1) {
      this.emit("significantMoodChange", {
        trend: moodTrend,
        timestamp: Date.now(),
        recentMood: recentMoods[recentMoods.length - 1].mood
      });
    }
  }
  async getAggregatedStats(timeframe) {
    const now = Date.now();
    const timeframes = {
      hour: 60 * 60 * 1000,
      day: 24 * 60 * 60 * 1000,
      week: 7 * 24 * 60 * 60 * 1000
    };
    const threshold = now - timeframes[timeframe];
    const relevantMoods = this.moodHistory.filter((m) => m.timestamp > threshold);
    return {
      averageMood: relevantMoods.reduce((acc, curr) => acc + curr.mood, 0) / relevantMoods.length,
      topTrends: await this.getTopicTrends(),
      activeAgents: this.performanceMetrics.activeAgents,
      systemPerformance: {
        responseTime: this.performanceMetrics.averageResponseTime,
        utilization: this.performanceMetrics.resourceUtilization
      }
    };
  }
  trackEvent(eventName, data) {
    console.log(`Analytics event: ${eventName}`, data);
  }
}

// src/services/agent-collaboration.service.ts
import { EventEmitter as EventEmitter4 } from "events";
var import_lodash2 = __toESM(require_lodash2(), 1);

class AgentCollaborationService extends EventEmitter4 {
  togetherService;
  vectorStore;
  cityService;
  analyticsService;
  aiIntegrationService;
  activeSessions = new Map;
  config = {
    minConsensusThreshold: 0.7,
    maxDiscussionRounds: 5,
    decisionTimeoutMs: 30000,
    emergencyProtocolThreshold: 0.8
  };
  constructor(togetherService, vectorStore, cityService, analyticsService, aiIntegrationService) {
    super();
    this.togetherService = togetherService;
    this.vectorStore = vectorStore;
    this.cityService = cityService;
    this.analyticsService = analyticsService;
    this.aiIntegrationService = aiIntegrationService;
    this.initializeService();
  }
  initializeService() {
    this.setupPeriodicMaintenance();
    this.on("collaborationStarted", (session) => {
      session.agents.forEach((agentId) => {
        this.analyticsService.trackAgentActivity(agentId);
      });
      const agent = {
        id: session.id,
        name: "Collaboration System",
        personality: "Systematic",
        systemPrompt: "Manage collaboration sessions",
        interests: ["collaboration", "coordination"],
        preferredStyle: "instructional",
        traits: {
          analyticalThinking: 1,
          creativity: 0.5,
          empathy: 0.7,
          curiosity: 0.6,
          enthusiasm: 0.5
        },
        memoryWindowSize: 10,
        emotionalRange: { min: 0.3, max: 0.8 }
      };
      const message2 = {
        id: crypto.randomUUID(),
        agentId: agent.id,
        content: `Collaboration session started with ${session.agents.length} participants`,
        timestamp: Date.now(),
        role: "assistant",
        sentiment: 0.7,
        topics: ["collaboration", "session", "start"]
      };
      this.analyticsService.trackInteraction(agent, message2);
    });
    this.on("collaborationEnded", (session) => {
      session.agents.forEach((agentId) => {
        this.analyticsService.trackAgentActivity(agentId);
      });
      const agent = {
        id: session.id,
        name: "Collaboration System",
        personality: "Systematic",
        systemPrompt: "Manage collaboration sessions",
        interests: ["collaboration", "coordination"],
        preferredStyle: "instructional",
        traits: {
          analyticalThinking: 1,
          creativity: 0.5,
          empathy: 0.7,
          curiosity: 0.6,
          enthusiasm: 0.5
        },
        memoryWindowSize: 10,
        emotionalRange: { min: 0.3, max: 0.8 }
      };
      const message2 = {
        id: crypto.randomUUID(),
        agentId: agent.id,
        content: `Collaboration session ended with consensus level: ${session.metrics.consensusLevel}`,
        timestamp: Date.now(),
        role: "assistant",
        sentiment: session.metrics.consensusLevel,
        topics: ["collaboration", "session", "end", "consensus"]
      };
      this.analyticsService.trackInteraction(agent, message2);
    });
    this.on("decisionMade", (decision) => {
      const agent = {
        id: decision.sessionId,
        name: "Collaboration System",
        personality: "Systematic",
        systemPrompt: "Manage collaboration sessions",
        interests: ["collaboration", "coordination"],
        preferredStyle: "instructional",
        traits: {
          analyticalThinking: 1,
          creativity: 0.5,
          empathy: 0.7,
          curiosity: 0.6,
          enthusiasm: 0.5
        },
        memoryWindowSize: 10,
        emotionalRange: { min: 0.3, max: 0.8 }
      };
      const message2 = {
        id: crypto.randomUUID(),
        agentId: agent.id,
        content: decision.description,
        timestamp: Date.now(),
        role: "assistant",
        sentiment: decision.confidence,
        topics: ["decision", decision.category, "collaboration"]
      };
      this.analyticsService.trackInteraction(agent, message2);
    });
  }
  setupPeriodicMaintenance() {
    setInterval(() => this.maintainSessions(), 60 * 60 * 1000);
    setInterval(() => this.monitorActiveSessions(), 5 * 60 * 60 * 1000);
  }
  async initiateCollaboration(event) {
    const sessionId = `collab-${event.id}-${Date.now()}`;
    const similarSession = await this.findSimilarSession(event);
    if (similarSession) {
      return this.mergeWithExistingSession(similarSession, event);
    }
    const session = {
      id: sessionId,
      eventId: event.id,
      agents: await this.optimizeAgentSelection(event),
      status: "planning",
      messages: [],
      decisions: [],
      metrics: {
        consensusLevel: 0,
        progressRate: 0,
        effectiveness: 0,
        participationScore: {},
        topicsAnalyzed: 0,
        consensusLevels: [],
        averageConsensus: 0
      },
      history: [
        {
          action: "session_created",
          timestamp: Date.now(),
          details: { event, initialAgents: event.requiredAgents }
        }
      ]
    };
    this.activeSessions.set(sessionId, session);
    await this.storeSessionContext(sessionId, event);
    await this.facilitateDiscussion(sessionId, event);
    return sessionId;
  }
  async optimizeAgentSelection(event) {
    const requiredAgents = new Set(event.requiredAgents);
    const additionalAgents = new Set;
    const domainExperts = await this.findDomainExperts(event.category);
    domainExperts.forEach((expert) => additionalAgents.add(expert));
    if (event.impact.environmental > 0.7) {
      additionalAgents.add("olivia");
    }
    if (event.impact.social > 0.7) {
      additionalAgents.add("elena");
    }
    if (event.impact.economic > 0.7) {
      additionalAgents.add("viktor");
    }
    return [...new Set([...requiredAgents, ...additionalAgents])];
  }
  async facilitateDiscussion(sessionId, event) {
    const session = this.activeSessions.get(sessionId);
    let currentRound = 0;
    try {
      await this.recordMultipleAgentActivity(session.agents);
      while (currentRound < this.config.maxDiscussionRounds) {
        const roundResult = await this.conductDiscussionRound(sessionId, event, currentRound);
        await this.recordMultipleAgentActivity(session.agents);
        if (roundResult.consensusReached || roundResult.emergencyAction) {
          await this.finalizeDecisions(sessionId, roundResult);
          break;
        }
        currentRound++;
        await this.updateSessionMetrics(sessionId);
      }
      if (currentRound >= this.config.maxDiscussionRounds) {
        await this.handleNoConsensus(sessionId);
      }
    } catch (error4) {
      await this.handleDiscussionError(sessionId, error4);
    }
  }
  async conductDiscussionRound(sessionId, event, round) {
    const session = this.activeSessions.get(sessionId);
    const agents2 = session.agents.map((id) => getAgent(id)).filter((a) => a !== undefined);
    const cityContext = await this.getCityContext();
    const roundResponses = new Map;
    const consensusTracker = new Map;
    for (const agent of agents2) {
      const prompt = this.buildCollaborationPrompt(agent, event, session.messages, cityContext, round);
      const response = await this.togetherService.generateResponse(agent, []);
      roundResponses.set(agent.id, response);
      await this.addMessage(sessionId, agent.id, response);
      const keyPoints = await this.extractKeyPoints(response);
      keyPoints.forEach((point) => {
        const existing = consensusTracker.get(point) || {
          count: 0,
          supporters: []
        };
        consensusTracker.set(point, {
          count: existing.count + 1,
          supporters: [...existing.supporters, agent.id]
        });
      });
    }
    const consensusLevel = this.calculateConsensusLevel(consensusTracker, agents2.length);
    const emergencyAction = await this.checkForEmergencyAction(event, roundResponses);
    return {
      consensusReached: consensusLevel >= this.config.minConsensusThreshold,
      emergencyAction,
      consensusPoints: Array.from(consensusTracker.entries()).filter(([_3, point]) => point.count / agents2.length >= this.config.minConsensusThreshold).map(([point]) => point)
    };
  }
  async finalizeDecisions(sessionId, roundResult) {
    const session = this.activeSessions.get(sessionId);
    const decisions = await this.synthesizeDecisions(session, roundResult);
    session.decisions = decisions;
    session.status = "implementing";
    await this.storeDecisions(sessionId, decisions);
    await this.notifyAgentsOfDecisions(session, decisions);
    await this.generateImplementationPlan(decisions);
  }
  async synthesizeDecisions(session, roundResult) {
    const leadAgent = getAgent(session.agents[0]);
    const decisions = await Promise.all(roundResult.consensusPoints.map(async (point) => ({
      description: point,
      proposedBy: leadAgent.id,
      supportedBy: session.agents,
      priority: this.calculatePriority(point, session),
      impact: await this.estimateImpact(point, session),
      implementation: await this.generateImplementationPlan(point),
      status: "proposed",
      timestamp: Date.now()
    })));
    return import_lodash2.default.orderBy(decisions, ["priority"], ["desc"]);
  }
  calculatePriority(decision, session) {
    const urgencyIndicators = [
      "immediate",
      "urgent",
      "critical",
      "emergency",
      "crucial"
    ];
    const hasUrgencyTerms = urgencyIndicators.some((term) => decision.toLowerCase().includes(term));
    const mentionCount = session.messages.filter((msg) => msg.content.toLowerCase().includes(decision.toLowerCase())).length;
    const supportLevel = session.agents.length / session.messages.length;
    return (hasUrgencyTerms ? 0.5 : 0) + mentionCount / session.messages.length * 0.3 + supportLevel * 0.2;
  }
  async estimateImpact(decision, session) {
    const embedding = await this.vectorStore.createEmbedding(decision);
    const similarDecisions = await this.vectorStore.query({
      vector: embedding,
      filter: {
        type: { $eq: "collaboration_decision" },
        timestamp: { $gt: Date.now() - 24 * 60 * 60 * 1000 }
      },
      topK: 5
    });
    const impacts = similarDecisions.matches.map((match) => match.metadata.impact);
    if (impacts.length > 0) {
      return {
        environmental: import_lodash2.default.meanBy(impacts, "environmental"),
        social: import_lodash2.default.meanBy(impacts, "social"),
        economic: import_lodash2.default.meanBy(impacts, "economic")
      };
    }
    return this.analyzeDecisionContent(decision);
  }
  async generateImplementationPlan(input) {
    if (typeof input === "string") {
      return {
        steps: await this.generateImplementationSteps(input),
        timeline: this.estimateImplementationTimeline(input),
        resources: await this.identifyRequiredResources(input)
      };
    }
    const combinedPlan = await Promise.all(input.map(async (decision) => ({
      steps: await this.generateImplementationSteps(decision.description),
      timeline: this.estimateImplementationTimeline(decision.description),
      resources: await this.identifyRequiredResources(decision.description)
    })));
    return {
      steps: combinedPlan.flatMap((p) => p.steps),
      timeline: Math.max(...combinedPlan.map((p) => p.timeline)),
      resources: [...new Set(combinedPlan.flatMap((p) => p.resources))]
    };
  }
  async handleNoConsensus(sessionId) {
    const session = this.activeSessions.get(sessionId);
    const disagreements = await this.analyzeDisagreements(session);
    const compromiseProposals = await this.generateCompromiseProposals(disagreements);
    if (compromiseProposals.length > 0) {
      await this.conductRapidConsensusRound(sessionId, compromiseProposals);
    } else {
      await this.escalateToEmergencyProtocol(sessionId);
    }
  }
  async handleDiscussionError(sessionId, error4) {
    const session = this.activeSessions.get(sessionId);
    console.error(`Error in collaboration session ${sessionId}:`, error4);
    session.status = "failed";
    session.history.push({
      action: "error_occurred",
      timestamp: Date.now(),
      details: { error: error4.message }
    });
    await Promise.all(session.agents.map((agentId) => this.notifyAgentOfFailure(agentId, sessionId, error4)));
    this.emit("collaborationError", {
      sessionId,
      error: error4,
      timestamp: Date.now()
    });
  }
  async getCityContext() {
    return {
      weather: await this.cityService.getCurrentWeather(),
      mood: await this.cityService.getCityMood()
    };
  }
  async storeSessionContext(sessionId, event) {
    await this.vectorStore.upsert({
      id: `collab-context-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(`${event.title} ${event.description} ${event.category}`),
      metadata: {
        type: "collaboration",
        subtype: "context",
        agentId: event.requiredAgents[0],
        conversationId: sessionId,
        timestamp: Date.now()
      }
    });
  }
  async buildCollaborationPrompt(agent, event, previousMessages, cityContext, round) {
    const messageHistory = this.formatMessageHistory(previousMessages);
    const contextInfo = this.formatContextInfo(cityContext);
    const roundGuidance = this.getRoundGuidance(round);
    const culturalContext = await this.formatCulturalContext(event.affectedDistricts[0]);
    const relevantMemories = await this.formatRelevantMemories(event);
    return `You are ${agent.name}, ${agent.personality}.

Current Event:
Title: ${event.title}
Description: ${event.description}
Category: ${event.category}
Urgency: ${event.urgency}
Impact: Environmental (${event.impact.environmental}), Social (${event.impact.social}), Economic (${event.impact.economic})

${contextInfo}

Cultural Context:
${culturalContext}

Relevant City Memories:
${relevantMemories}

Previous Discussion:
${messageHistory}

Round ${round + 1} Guidance:
${roundGuidance}

Based on your expertise and role, provide your assessment and recommendations.
Consider:
1. How this aligns with your area of expertise
2. Potential collaboration points with other involved agents
3. Specific actions you recommend
4. Any concerns or considerations from your perspective
5. How current city conditions might affect your approach
6. Build upon or respectfully challenge previous suggestions
7. Consider long-term implications and sustainability
8. How this aligns with cultural values and historical context
9. Impact on community memory and cultural significance

Respond in a professional but conversational tone, addressing other agents by name when relevant.`;
  }
  getRoundGuidance(round) {
    const guidances = [
      "Focus on initial assessment and identifying key challenges.",
      "Build upon previous suggestions and address any concerns raised.",
      "Work towards concrete solutions and implementation details.",
      "Focus on consensus-building and addressing remaining disagreements.",
      "Finalize decisions and establish clear action items."
    ];
    return guidances[round] || "Focus on reaching final consensus and action items.";
  }
  async addMessage(sessionId, agentId, content) {
    const session = this.activeSessions.get(sessionId);
    if (!session)
      throw new Error("Session not found");
    const sentiment = await this.analyzeSentiment(content);
    const topics = await this.extractTopics(content);
    const message2 = {
      agentId,
      content,
      timestamp: Date.now(),
      sentiment,
      topics
    };
    session.messages.push(message2);
    await this.updateParticipationMetrics(sessionId, agentId);
    await this.vectorStore.upsert({
      id: `collab-message-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(content),
      metadata: {
        type: "collaboration",
        subtype: "message",
        agentId,
        sentiment: sentiment?.toString(),
        timestamp: message2.timestamp
      }
    });
    this.emit("messageAdded", {
      sessionId,
      agentId,
      message: message2
    });
  }
  async updateParticipationMetrics(sessionId, agentId) {
    const session = this.activeSessions.get(sessionId);
    const agentMessages = session.messages.filter((m) => m.agentId === agentId);
    const totalMessages = session.messages.length;
    const quantityScore = agentMessages.length / Math.max(totalMessages / session.agents.length, 1);
    const qualityScore = import_lodash2.default.meanBy(agentMessages, (msg) => msg.sentiment || 0.5);
    session.metrics.participationScore[agentId] = quantityScore * 0.4 + qualityScore * 0.6;
  }
  async analyzeSentiment(content) {
    const positivePatterns = [
      /agree|support|approve|excellent|good idea/i,
      /beneficial|effective|efficient|valuable/i,
      /collaborate|synergy|together|partnership/i
    ];
    const negativePatterns = [
      /disagree|oppose|reject|concern|worried/i,
      /ineffective|inefficient|problematic|costly/i,
      /risk|danger|threat|failure/i
    ];
    let score = 0.5;
    positivePatterns.forEach((pattern2) => {
      if (pattern2.test(content))
        score += 0.1;
    });
    negativePatterns.forEach((pattern2) => {
      if (pattern2.test(content))
        score -= 0.1;
    });
    return Math.max(0, Math.min(1, score));
  }
  async monitorActiveSessions() {
    for (const [sessionId, session] of this.activeSessions.entries()) {
      try {
        await this.updateSessionMetrics(sessionId);
        await this.checkSessionProgress(sessionId);
      } catch (error4) {
        console.error(`Error monitoring session ${sessionId}:`, error4);
      }
    }
  }
  async updateSessionMetrics(sessionId) {
    const session = this.activeSessions.get(sessionId);
    const metrics = await this.calculateSessionMetrics(session);
    session.metrics = metrics;
  }
  async calculateSessionMetrics(session) {
    const consensusTracker = new Map;
    await Promise.all(session.messages.map(async (msg) => {
      const points = await this.extractKeyPoints(msg.content);
      points.forEach((point) => {
        const existing = consensusTracker.get(point) || {
          count: 0,
          supporters: []
        };
        consensusTracker.set(point, {
          count: existing.count + 1,
          supporters: [...existing.supporters, msg.agentId]
        });
      });
    }));
    return {
      consensusLevel: this.calculateConsensusLevel(consensusTracker, session.agents.length),
      progressRate: this.calculateProgressRate(session),
      effectiveness: this.calculateEffectiveness(session),
      participationScore: this.calculateParticipationScores(session)
    };
  }
  async checkSessionProgress(sessionId) {
    const session = this.activeSessions.get(sessionId);
    if (session.metrics.progressRate < 0.2 && Date.now() - session.messages[0]?.timestamp > this.config.decisionTimeoutMs) {
      await this.handleStaleSession(sessionId);
    }
  }
  async extractKeyPoints(content) {
    const lines = content.split("\n");
    return lines.filter((line) => line.trim().startsWith("-") || line.trim().startsWith("*")).map((line) => line.replace(/^[-*]\s*/, "").trim());
  }
  calculateConsensusLevel(consensusTracker, totalAgents) {
    const uniquePoints = new Set;
    const pointFrequency = new Map;
    consensusTracker.forEach((point, key) => {
      uniquePoints.add(key);
      pointFrequency.set(key, point.count);
    });
    const consensusPoints = Array.from(pointFrequency.values()).filter((frequency) => frequency / totalAgents > this.config.minConsensusThreshold).length;
    return consensusPoints / uniquePoints.size;
  }
  async checkForEmergencyAction(event, responses) {
    const urgencyIndicators = [
      "immediate",
      "critical",
      "emergency",
      "urgent",
      "severe"
    ];
    const hasUrgentTerms = Array.from(responses.values()).some((response) => urgencyIndicators.some((term) => response.toLowerCase().includes(term)));
    return hasUrgentTerms && event.urgency > this.config.emergencyProtocolThreshold;
  }
  async storeDecisions(sessionId, decisions) {
    const metadata = {
      type: "district",
      sessionId,
      decisions: JSON.stringify(decisions),
      timestamp: Date.now()
    };
    await this.vectorStore.upsert({
      id: `decisions-${sessionId}`,
      values: await this.vectorStore.createEmbedding(JSON.stringify(decisions)),
      metadata
    });
  }
  async notifyAgentsOfDecisions(session, decisions) {
    const notification = this.formatDecisionNotification(decisions);
    for (const agentId of session.agents) {
      const agent = getAgent(agentId);
      if (agent) {
        await this.addMessage(session.eventId, "system", `@${agent.name} ${notification}`);
      }
    }
  }
  formatDecisionNotification(decisions) {
    return `Final Decisions:\n${decisions.map((d) => `- ${d.description} (Priority: ${d.priority})`).join("\n")}`;
  }
  analyzeDecisionContent(decision) {
    const environmentalTerms = [
      "environment",
      "sustainability",
      "green",
      "eco"
    ];
    const socialTerms = ["community", "social", "public", "citizens"];
    const economicTerms = ["economic", "financial", "cost", "budget"];
    return {
      environmental: environmentalTerms.some((term) => decision.toLowerCase().includes(term)) ? 0.8 : 0.2,
      social: socialTerms.some((term) => decision.toLowerCase().includes(term)) ? 0.8 : 0.2,
      economic: economicTerms.some((term) => decision.toLowerCase().includes(term)) ? 0.8 : 0.2
    };
  }
  async generateImplementationSteps(decision) {
    const systemPrompt = `Generate implementation steps for: ${decision}`;
    const response = await this.togetherService.generateText(systemPrompt);
    return response.split("\n").filter((step) => step.trim().length > 0);
  }
  estimateImplementationTimeline(decision) {
    const complexityIndicators = [
      "complex",
      "multiple",
      "long-term",
      "extensive"
    ];
    const isComplex = complexityIndicators.some((indicator) => decision.toLowerCase().includes(indicator));
    return isComplex ? 30 : 14;
  }
  async identifyRequiredResources(decision) {
    const systemPrompt = `List required resources for: ${decision}`;
    const response = await this.togetherService.generateText(systemPrompt);
    return response.split("\n").filter((resource) => resource.trim().length > 0);
  }
  async analyzeDisagreements(session) {
    const messagesByAgent = new Map;
    session.messages.forEach((msg) => {
      const agentMessages = messagesByAgent.get(msg.agentId) || [];
      agentMessages.push(msg.content);
      messagesByAgent.set(msg.agentId, agentMessages);
    });
    return this.findConflictingPoints(messagesByAgent);
  }
  findConflictingPoints(messagesByAgent) {
    const conflicts = [];
    const agents2 = Array.from(messagesByAgent.keys());
    const disagreementPatterns = [
      /disagree|oppose|reject|object|cannot accept/i,
      /however|but|instead|rather|alternatively/i,
      /not convinced|unconvinced|skeptical|doubtful/i,
      /concerned about|worried about|issue with/i
    ];
    const agentPositions = new Map;
    agents2.forEach((agentId) => {
      const messages = messagesByAgent.get(agentId) || [];
      messages.forEach((message2) => {
        const sentences = message2.split(/[.!?]+/).map((s) => s.trim());
        sentences.forEach((sentence, index) => {
          const hasDisagreement = disagreementPatterns.some((pattern2) => pattern2.test(sentence));
          if (hasDisagreement && index < sentences.length - 1) {
            const topic = this.extractTopicFromSentence(sentence);
            if (!topic)
              return;
            const position = sentences[index + 1];
            if (!agentPositions.has(topic)) {
              agentPositions.set(topic, new Map);
            }
            agentPositions.get(topic)?.set(agentId, position);
          }
        });
      });
    });
    agentPositions.forEach((positions, topic) => {
      if (positions.size > 1) {
        const uniquePositions = new Set(positions.values());
        if (uniquePositions.size > 1) {
          conflicts.push({
            topic,
            positions
          });
        }
      }
    });
    return conflicts;
  }
  extractTopicFromSentence(sentence) {
    const topicPatterns = [
      {
        pattern: /regarding|about|concerning|on the topic of|with respect to/i,
        position: "after"
      },
      {
        pattern: /the (proposed|suggested|planned|current|existing)/i,
        position: "after"
      },
      { pattern: /disagree with the/i, position: "after" },
      { pattern: /oppose the/i, position: "after" },
      {
        pattern: /([\w\s]+) (is|are|would be|will be) (not|too|very|extremely)/i,
        position: "capture"
      }
    ];
    for (const { pattern: pattern2, position } of topicPatterns) {
      const match = sentence.match(pattern2);
      if (match) {
        if (position === "after") {
          const afterMatch = sentence.substring(match.index + match[0].length).trim();
          const topic = afterMatch.split(/[\s,.]/).slice(0, 3).join(" ").trim();
          return topic || null;
        } else if (position === "capture" && match[1]) {
          return match[1].trim();
        }
      }
    }
    return null;
  }
  async generateCompromiseProposals(disagreements) {
    const proposals = await Promise.all(disagreements.map((d) => this.generateCompromiseForDisagreement(d)));
    return proposals.filter((p) => p !== null);
  }
  async generateCompromiseForDisagreement(disagreement) {
    const systemPrompt = `Generate a compromise proposal for differing positions on: ${disagreement.topic}`;
    return await this.togetherService.generateText(systemPrompt);
  }
  async conductRapidConsensusRound(sessionId, proposals) {
    const session = this.activeSessions.get(sessionId);
    for (const proposal of proposals) {
      await this.addMessage(sessionId, "system", `RAPID CONSENSUS REQUIRED: Please indicate your position on the following proposal:\n${proposal}`);
    }
  }
  async escalateToEmergencyProtocol(sessionId) {
    const session = this.activeSessions.get(sessionId);
    const leadAgent = getAgent(session.agents[0]);
    await this.addMessage(sessionId, "system", "EMERGENCY PROTOCOL ACTIVATED: Lead agent will make final decision due to time constraints.");
    const finalDecision = await this.generateEmergencyDecision(session, leadAgent);
    session.decisions.push(finalDecision);
  }
  async generateEmergencyDecision(session, leadAgent) {
    const systemPrompt = `As ${leadAgent.name}, make an emergency decision based on the current situation.`;
    const decision = await this.togetherService.generateText(systemPrompt);
    return {
      description: decision,
      proposedBy: leadAgent.id,
      supportedBy: [leadAgent.id],
      priority: 1,
      impact: this.analyzeDecisionContent(decision),
      implementation: await this.generateImplementationPlan(decision),
      status: "approved",
      timestamp: Date.now()
    };
  }
  async notifyAgentOfFailure(agentId, sessionId, error4) {
    const errorMessage = `Collaboration session ${sessionId} has encountered an error: ${error4.message}`;
    await this.addMessage(sessionId, "system", `@${agentId} ${errorMessage}`);
  }
  formatMessageHistory(messages) {
    return messages.map((msg) => {
      const agent = getAgent(msg.agentId);
      return `${agent.name}: ${msg.content}`;
    }).join("\n");
  }
  formatContextInfo(cityContext) {
    return `Current City Context:
- Weather: ${cityContext.weather.condition}, ${cityContext.weather.temperature}\xB0C
- City Mood: ${cityContext.mood.dominantEmotion} (${cityContext.mood.overall.toFixed(2)})
- Community Status: ${cityContext.mood.factors.community.toFixed(2)}
- Stress Level: ${cityContext.mood.factors.stress.toFixed(2)}`;
  }
  async extractTopics(content) {
    const topics = new Set;
    const topicPatterns = {
      infrastructure: /infrastructure|building|construction|maintenance|facility|road|bridge/i,
      environment: /environment|sustainability|green|pollution|climate|energy|waste/i,
      social: /community|social|public|citizens|welfare|education|healthcare/i,
      economic: /economic|financial|budget|cost|investment|funding|resources/i,
      emergency: /emergency|urgent|critical|immediate|crisis|safety|risk/i,
      technology: /technology|digital|smart|system|innovation|automation|data/i,
      culture: /culture|heritage|tradition|art|festival|celebration|identity/i,
      governance: /policy|regulation|compliance|governance|management|decision|planning/i,
      mobility: /transport|traffic|mobility|commute|vehicle|pedestrian|accessibility/i,
      security: /security|protection|surveillance|safety|prevention|monitoring|guard/i
    };
    Object.entries(topicPatterns).forEach(([topic, pattern2]) => {
      if (pattern2.test(content)) {
        topics.add(topic);
      }
    });
    return Array.from(topics);
  }
  async findSimilarSession(event) {
    const embedding = await this.vectorStore.createEmbedding(`${event.title} ${event.description} ${event.category}`);
    const similarSessions = await this.vectorStore.query({
      vector: embedding,
      filter: {
        type: { $eq: "collaboration_context" },
        timestamp: { $gt: Date.now() - 24 * 60 * 60 * 1000 }
      },
      topK: 1
    });
    if (similarSessions.matches && similarSessions.matches.length > 0 && similarSessions.matches[0].score > 0.85) {
      return similarSessions.matches[0].metadata.sessionId;
    }
    return null;
  }
  async mergeWithExistingSession(existingSessionId, newEvent) {
    const existingSession = this.activeSessions.get(existingSessionId);
    const mergedAgents = new Set([
      ...existingSession.agents,
      ...newEvent.requiredAgents
    ]);
    existingSession.agents = Array.from(mergedAgents);
    existingSession.history.push({
      action: "session_merged",
      timestamp: Date.now(),
      details: { mergedEventId: newEvent.id }
    });
    await this.notifySessionMerge(existingSessionId, newEvent);
    return existingSessionId;
  }
  async notifySessionMerge(sessionId, newEvent) {
    const session = this.activeSessions.get(sessionId);
    const mergeNotification = `This collaboration session has been merged with a related event: ${newEvent.title}. 
    Please consider the additional context in our ongoing discussion.`;
    await this.addMessage(sessionId, "system", mergeNotification);
  }
  async findDomainExperts(category) {
    const expertiseMatches = await this.vectorStore.query({
      vector: await this.vectorStore.createEmbedding(category),
      filter: { type: { $eq: "agent_expertise" } },
      topK: 3
    });
    return expertiseMatches.matches.map((match) => match.metadata.agentId);
  }
  async maintainSessions() {
    for (const [sessionId, session] of this.activeSessions.entries()) {
      if (session.status === "completed") {
        await this.archiveSession(sessionId);
        this.activeSessions.delete(sessionId);
        continue;
      }
      const lastActivity = import_lodash2.default.maxBy(session.messages, "timestamp")?.timestamp || 0;
      if (Date.now() - lastActivity > 24 * 60 * 60 * 1000) {
        await this.handleStaleSession(sessionId);
      }
    }
  }
  async archiveSession(sessionId) {
    const session = this.activeSessions.get(sessionId);
    const embedding = await this.vectorStore.createEmbedding(JSON.stringify(session.decisions));
    await this.vectorStore.upsert({
      id: `archived-session-${sessionId}`,
      values: embedding,
      metadata: {
        type: "collaboration",
        subtype: "archived",
        sessionId,
        decisions: JSON.stringify(session.decisions),
        metrics: JSON.stringify(session.metrics),
        timestamp: Date.now()
      }
    });
  }
  async handleStaleSession(sessionId) {
    const session = this.activeSessions.get(sessionId);
    const stallReason = await this.analyzeStallReason(session);
    if (stallReason === "lack_of_consensus") {
      await this.escalateToEmergencyProtocol(sessionId);
    } else if (stallReason === "incomplete_information") {
      await this.requestAdditionalInformation(sessionId);
    } else {
      await this.gracefullyCloseSession(sessionId);
    }
  }
  async analyzeStallReason(session) {
    const recentMessages = session.messages.slice(-5);
    const sentiments = recentMessages.map((msg) => msg.sentiment || 0.5);
    const avgSentiment = import_lodash2.default.mean(sentiments);
    if (avgSentiment < 0.4)
      return "lack_of_consensus";
    if (recentMessages.some((msg) => msg.content.includes("need more information"))) {
      return "incomplete_information";
    }
    return "natural_conclusion";
  }
  async requestAdditionalInformation(sessionId) {
    const session = this.activeSessions.get(sessionId);
    const missingInfo = await this.identifyMissingInformation(session);
    const infoRequest = `Additional information needed:
${missingInfo.join("\n")}
Please provide these details to continue the discussion.`;
    await this.addMessage(sessionId, "system", infoRequest);
  }
  async identifyMissingInformation(session) {
    const missingInfo = [];
    const content = session.messages.map((m) => m.content).join(" ");
    if (!content.includes("budget") && !content.includes("cost")) {
      missingInfo.push("- Budget/cost estimates");
    }
    if (!content.includes("timeline") && !content.includes("schedule")) {
      missingInfo.push("- Implementation timeline");
    }
    if (!content.includes("risk") && !content.includes("challenge")) {
      missingInfo.push("- Risk assessment");
    }
    return missingInfo;
  }
  async gracefullyCloseSession(sessionId) {
    const session = this.activeSessions.get(sessionId);
    const summary = await this.generateSessionSummary(session);
    await this.addMessage(sessionId, "system", summary);
    const followupTasks = await this.createFollowupTasks(session);
    await this.archiveSession(sessionId);
    this.activeSessions.delete(sessionId);
    this.emit("sessionClosed", {
      sessionId,
      summary,
      followupTasks
    });
  }
  async generateSessionSummary(session) {
    const decisions = session.decisions.map((d) => `- ${d.description} (${d.status})`).join("\n");
    const participation = Object.entries(session.metrics.participationScore).map(([agentId, score]) => {
      const agent = getAgent(agentId);
      return `${agent?.name}: ${(score * 100).toFixed(1)}%`;
    }).join("\n");
    return `Collaboration Session Summary:\n\n${decisions}\n\n${participation}`;
  }
  async getSessionStatus(sessionId) {
    const session = this.activeSessions.get(sessionId);
    if (!session)
      throw new Error("Session not found");
    const status = {
      id: sessionId,
      status: session.status,
      agents: session.agents.map((id) => ({
        id,
        name: getAgent(id)?.name,
        participationScore: session.metrics.participationScore[id]
      })),
      messages: session.messages,
      decisions: session.decisions,
      metrics: session.metrics
    };
    return status;
  }
  async handleConflictPoints(points) {
    const resolvedPoints = await Promise.all(points.map(async (point) => {
      const [similarDecisions, similarPatterns] = await Promise.all([
        this.aiIntegrationService.findSimilarDecisions(point, 3),
        this.aiIntegrationService.findSimilarPatterns(point, 3)
      ]);
      const historicalResolution = this.findBestResolution(similarDecisions, similarPatterns);
      if (historicalResolution && historicalResolution.confidence > 0.7) {
        return historicalResolution.resolution;
      }
      const compromise = await this.generateCompromise(point, similarPatterns);
      await this.aiIntegrationService.storePattern(compromise, {
        type: "conflict_resolution",
        originalPoint: point,
        context: {
          similarDecisions: similarDecisions.map((d) => d.decision),
          similarPatterns: similarPatterns.map((p) => p.pattern)
        }
      }, 0.8);
      return compromise;
    }));
    return resolvedPoints;
  }
  findBestResolution(decisions, patterns3) {
    const allSolutions = [
      ...decisions.map((d) => ({
        text: d.decision,
        confidence: d.context?.confidence || 0.5
      })),
      ...patterns3.map((p) => ({ text: p.pattern, confidence: p.confidence }))
    ];
    const bestSolution = allSolutions.reduce((best, current) => {
      return current.confidence > best.confidence ? current : best;
    }, { text: "", confidence: 0 });
    return bestSolution.confidence > 0 ? { resolution: bestSolution.text, confidence: bestSolution.confidence } : null;
  }
  async generateCompromise(point, patterns3) {
    const commonElements = patterns3.filter((p) => p.confidence > 0.6).map((p) => p.pattern).join(" ");
    return `Based on successful resolutions, we propose: ${commonElements || "a collaborative approach focusing on mutual benefits"}`;
  }
  async analyzeDiscussionTopics(session) {
    const resolvedTopics = await this.identifyTopics(session);
    for (const topic of resolvedTopics) {
      const analysis = await this.analyzeTopic(topic, session);
      await this.aiIntegrationService.storePattern(topic, {
        type: "topic_analysis",
        sessionId: session.id,
        analysis,
        participants: session.agents,
        context: {
          sentiment: analysis.sentiment,
          priority: analysis.priority,
          consensus: analysis.consensusLevel
        }
      }, analysis.confidence);
      if (analysis.priority > 0.8) {
        await this.handleHighPriorityTopic(topic, analysis, session);
      }
      session.metrics = {
        ...session.metrics,
        topicsAnalyzed: (session.metrics.topicsAnalyzed || 0) + 1,
        averageConsensus: this.calculateAverageConsensus([
          ...session.metrics.consensusLevels || [],
          analysis.consensusLevel
        ])
      };
    }
  }
  async analyzeTopic(topic, session) {
    const relevantMessages = session.messages.filter((m) => m.content.toLowerCase().includes(topic.toLowerCase()));
    const consensusMap = new Map;
    relevantMessages.forEach((msg) => {
      const point = consensusMap.get(msg.content) || {
        count: 0,
        supporters: []
      };
      point.count++;
      point.supporters.push(msg.agentId);
      consensusMap.set(msg.content, point);
    });
    const sentiment = this.calculateMessagesSentiment(relevantMessages);
    const consensusLevel = this.calculateConsensusLevel(consensusMap, session.agents.length);
    const priority = this.assessTopicPriority(topic, relevantMessages);
    return {
      topic,
      sentiment,
      consensusLevel,
      priority,
      confidence: 0.8,
      participantEngagement: this.calculateParticipantEngagement(relevantMessages, session.agents)
    };
  }
  async handleHighPriorityTopic(topic, analysis, session) {
    const interestedAgents = await this.findRelevantAgents(topic);
    if (interestedAgents.length >= 2) {
      await this.createFocusedDiscussion(topic, interestedAgents, analysis);
    }
    await this.aiIntegrationService.storePattern(topic, {
      type: "high_priority_topic",
      analysis,
      interestedAgents: interestedAgents.map((a) => a.id),
      timestamp: Date.now()
    }, 0.9);
  }
  calculateMessagesSentiment(messages) {
    return messages.reduce((acc, msg) => acc + (msg.sentiment || 0.5), 0) / Math.max(messages.length, 1);
  }
  calculateParticipantEngagement(messages, participants) {
    const participantMessages = new Map;
    messages.forEach((m) => {
      participantMessages.set(m.agentId, (participantMessages.get(m.agentId) || 0) + 1);
    });
    return participantMessages.size / participants.length;
  }
  assessTopicPriority(topic, messages) {
    const messageFrequency = messages.length / 10;
    const recentMessages = messages.filter((m) => Date.now() - m.timestamp < 30 * 60 * 1000).length;
    const recency = recentMessages / messages.length;
    const sentimentIntensity = messages.reduce((acc, msg) => acc + Math.abs((msg.sentiment || 0.5) - 0.5) * 2, 0) / messages.length;
    return messageFrequency * 0.4 + recency * 0.3 + sentimentIntensity * 0.3;
  }
  calculateAverageConsensus(consensusLevels) {
    return consensusLevels.reduce((a, b) => a + b, 0) / Math.max(consensusLevels.length, 1);
  }
  async recordAgentInteraction(agentId1, agentId2, content) {
    try {
      await this.recordMultipleAgentActivity([agentId1, agentId2]);
      const embedding = await this.vectorStore.createEmbedding(content);
      const interactionId = `interaction-${Date.now()}`;
      await this.vectorStore.upsert({
        id: interactionId,
        values: embedding,
        metadata: {
          type: "collaboration",
          agentId1,
          agentId2,
          content,
          timestamp: Date.now()
        }
      });
      this.emit("agentInteraction", {
        interactionId,
        agentId1,
        agentId2,
        content,
        timestamp: Date.now()
      });
      return {
        id: interactionId,
        agentId1,
        agentId2,
        content,
        timestamp: Date.now()
      };
    } catch (error4) {
      console.error("Failed to record agent interaction:", error4);
      throw error4;
    }
  }
  async formatCulturalContext(districtId) {
    try {
      const embedding = await this.vectorStore.createEmbedding(`district ${districtId} cultural context`);
      const results = await this.vectorStore.query({
        vector: embedding,
        filter: {
          type: { $eq: "district" },
          subtype: { $eq: "cultural_context" },
          districtId: { $eq: districtId }
        },
        topK: 3
      });
      if (!results.matches.length)
        return "No specific cultural context available.";
      return results.matches.map((match) => match.metadata.description).join("\n");
    } catch (error4) {
      console.error("Error fetching cultural context:", error4);
      return "Cultural context temporarily unavailable.";
    }
  }
  async formatRelevantMemories(event) {
    try {
      const embedding = await this.vectorStore.createEmbedding(`${event.title} ${event.description}`);
      const results = await this.vectorStore.query({
        vector: embedding,
        filter: {
          type: { $eq: "district" },
          subtype: { $eq: "collective_memory" },
          districtId: { $in: event.affectedDistricts }
        },
        topK: 3
      });
      if (!results.matches.length)
        return "No relevant historical memories found.";
      return results.matches.map((match) => `- ${match.metadata.description} (Impact: ${match.metadata.impact})`).join("\n");
    } catch (error4) {
      console.error("Error fetching relevant memories:", error4);
      return "Historical memories temporarily unavailable.";
    }
  }
  async recordAgentActivity(agentId) {
    await this.aiIntegrationService.recordAgentActivity(agentId);
    this.analyticsService.trackAgentActivity(agentId);
  }
  async recordMultipleAgentActivity(agentIds) {
    await Promise.all(agentIds.map((id) => this.recordAgentActivity(id)));
  }
  calculateProgressRate(session) {
    const totalMessages = session.messages.length;
    const uniqueParticipants = new Set(session.messages.map((m) => m.agentId)).size;
    return Math.min(1, uniqueParticipants / session.agents.length * (totalMessages / 10));
  }
  calculateEffectiveness(session) {
    if (!session.messages.length)
      return 0;
    const sentiments = session.messages.map((m) => m.sentiment || 0.5).filter((s) => s !== undefined);
    const avgSentiment = sentiments.reduce((a, b) => a + b, 0) / sentiments.length;
    const consensusLevel = session.metrics.consensusLevel;
    return avgSentiment * 0.4 + consensusLevel * 0.6;
  }
  calculateParticipationScores(session) {
    const scores = {};
    const messagesByAgent = new Map;
    session.messages.forEach((m) => {
      messagesByAgent.set(m.agentId, (messagesByAgent.get(m.agentId) || 0) + 1);
    });
    session.agents.forEach((agentId) => {
      const messageCount = messagesByAgent.get(agentId) || 0;
      scores[agentId] = messageCount / Math.max(session.messages.length, 1);
    });
    return scores;
  }
  async createFollowupTasks(session) {
    const unfinishedDecisions = session.decisions.filter((d) => d.status !== "completed");
    return unfinishedDecisions.map((decision) => ({
      id: `task-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      title: `Follow up on: ${decision.description}`,
      priority: decision.priority
    }));
  }
  async createFocusedDiscussion(topic, agents2, analysis) {
    const sessionId = `focused-${Date.now()}`;
    const session = {
      id: sessionId,
      eventId: `event-${Date.now()}`,
      agents: agents2.map((a) => a.id),
      status: "planning",
      messages: [],
      decisions: [],
      metrics: {
        consensusLevel: 0,
        progressRate: 0,
        effectiveness: 0,
        participationScore: {},
        topicsAnalyzed: 0,
        consensusLevels: [],
        averageConsensus: 0
      },
      history: [
        {
          action: "session_created",
          timestamp: Date.now(),
          details: { topic, agents: agents2.map((a) => a.id) }
        }
      ]
    };
    this.activeSessions.set(sessionId, session);
    await this.aiIntegrationService.storePattern(`Focused discussion on ${topic}`, {
      type: "focused_discussion",
      sessionId: session.id,
      topic,
      agents: agents2.map((a) => a.id),
      priority: analysis.priority
    }, 0.9);
  }
  async findRelevantAgents(topic) {
    const embedding = await this.vectorStore.createEmbedding(topic);
    const results = await this.vectorStore.query({
      vector: embedding,
      filter: { type: { $eq: "agent" } },
      topK: 5
    });
    return results.matches?.map((match) => ({
      id: match.metadata.agentId || ""
    })) || [];
  }
  async identifyTopics(session) {
    const content = session.messages.map((m) => m.content).join(" ");
    const embedding = await this.vectorStore.createEmbedding(content);
    const results = await this.vectorStore.query({
      vector: embedding,
      filter: { type: { $eq: "topic" } },
      topK: 5
    });
    return results.matches?.map((match) => match.metadata.topic) || [];
  }
}

// src/services/socket-manager.service.ts
import { WebSocket } from "ws";
import { EventEmitter as EventEmitter6 } from "events";

// src/services/event-bus.service.ts
import { EventEmitter as EventEmitter5 } from "events";

class EventBus extends EventEmitter5 {
  static instance;
  eventHistory = new Map;
  eventFilters = new Map;
  MAX_HISTORY_SIZE = 1000;
  CLEANUP_INTERVAL = 1000 * 60 * 5;
  constructor() {
    super();
    this.initializeEventCleanup();
  }
  static getInstance() {
    if (!EventBus.instance) {
      EventBus.instance = new EventBus;
    }
    return EventBus.instance;
  }
  initializeEventCleanup() {
    setInterval(() => {
      this.cleanupExpiredEvents();
    }, this.CLEANUP_INTERVAL);
  }
  cleanupExpiredEvents() {
    const now = Date.now();
    for (const [id, event] of this.eventHistory) {
      if (event.metadata.ttl && now - event.metadata.timestamp > event.metadata.ttl) {
        this.eventHistory.delete(id);
      }
    }
    if (this.eventHistory.size > this.MAX_HISTORY_SIZE) {
      const sortedEvents = Array.from(this.eventHistory.entries()).sort(([, a], [, b]) => a.metadata.timestamp - b.metadata.timestamp);
      const eventsToRemove = sortedEvents.slice(0, this.eventHistory.size - this.MAX_HISTORY_SIZE);
      eventsToRemove.forEach(([id]) => this.eventHistory.delete(id));
    }
  }
  createEventMetadata(priority, category, source, persistent = false, ttl) {
    return {
      priority,
      timestamp: Date.now(),
      source,
      acknowledged: false,
      acknowledgments: [],
      persistent,
      category,
      ttl
    };
  }
  emitWithMetadata(type3, data, metadata) {
    const eventId = crypto.randomUUID();
    const event = { id: eventId, type: type3, data, metadata };
    if (metadata.persistent) {
      this.eventHistory.set(eventId, event);
    }
    if (this.shouldEmitEvent(event)) {
      this.emit(type3, { ...data, _eventId: eventId });
      if (metadata.priority === "low") {
        this.acknowledgeEvent(eventId, "system");
      }
    }
    return eventId;
  }
  shouldEmitEvent(event) {
    for (const filter of this.eventFilters.values()) {
      if (filter.priority && !filter.priority.includes(event.metadata.priority) || filter.category && !filter.category.includes(event.metadata.category) || filter.source && !filter.source.includes(event.metadata.source) || filter.timeRange && (event.metadata.timestamp < filter.timeRange.start || event.metadata.timestamp > filter.timeRange.end) || filter.acknowledged !== undefined && filter.acknowledged !== event.metadata.acknowledged) {
        return false;
      }
    }
    return true;
  }
  acknowledgeEvent(eventId, agentId) {
    const event = this.eventHistory.get(eventId);
    if (!event)
      return false;
    event.metadata.acknowledged = true;
    event.metadata.acknowledgments?.push({
      agentId,
      timestamp: Date.now()
    });
    this.eventHistory.set(eventId, event);
    this.emit("eventAcknowledged", { eventId, agentId });
    return true;
  }
  addEventFilter(filterId, filter) {
    this.eventFilters.set(filterId, filter);
  }
  removeEventFilter(filterId) {
    this.eventFilters.delete(filterId);
  }
  getEventHistory(filter) {
    let events = Array.from(this.eventHistory.values());
    if (filter) {
      events = events.filter((event) => {
        return this.shouldEmitEvent(event);
      });
    }
    return events;
  }
  emitMessageCreated(conversationId, message2) {
    return this.emitWithMetadata("messageCreated", { conversationId, message: message2 }, this.createEventMetadata("low", "conversation", "chat", true, 1000 * 60 * 60));
  }
  emitStateUpdated(conversationId, state) {
    return this.emitWithMetadata("stateUpdated", { conversationId, state }, this.createEventMetadata("low", "conversation", "system", true));
  }
  emitAgentTyping(conversationId, agentId) {
    return this.emitWithMetadata("agentTyping", { conversationId, agentId }, this.createEventMetadata("low", "conversation", agentId, false, 1000 * 10));
  }
  emitError(error4) {
    return this.emitWithMetadata("error", { error: error4 }, this.createEventMetadata("high", "infrastructure", "system", true));
  }
  emitEmergencyAlert(emergencyData) {
    return this.emitWithMetadata("emergencyAlert", emergencyData, this.createEventMetadata("critical", "emergency", "emergency-system", true));
  }
  emitInfrastructureUpdate(updateData) {
    return this.emitWithMetadata("infrastructureUpdate", updateData, this.createEventMetadata("medium", "infrastructure", "infrastructure-system", true));
  }
  emitAIAgentAction(actionData) {
    return this.emitWithMetadata("aiAgentAction", actionData, this.createEventMetadata("medium", "ai", actionData.agentId, true));
  }
  emitCulturalEvent(eventData) {
    return this.emitWithMetadata("culturalEvent", eventData, this.createEventMetadata("medium", "cultural", "cultural-system", true));
  }
  emitEnvironmentalAlert(alertData) {
    return this.emitWithMetadata("environmentalAlert", alertData, this.createEventMetadata(alertData.severity === "critical" ? "critical" : "high", "environmental", "environmental-system", true));
  }
}

// src/services/socket-manager.service.ts
class SocketManagerService extends EventEmitter6 {
  collaborationService;
  connections = new Map;
  eventBus;
  heartbeatInterval;
  constructor(collaborationService) {
    super();
    this.collaborationService = collaborationService;
    this.eventBus = EventBus.getInstance();
    this.setupCollaborationListeners();
    this.setupEventBusListeners();
    this.initializeHeartbeat();
  }
  setupCollaborationListeners() {
    this.collaborationService.on("messageAdded", (data) => {
      this.broadcastToSession(data.sessionId, {
        type: "agentMessage",
        data: {
          agent: getAgent(data.agentId),
          content: data.content,
          timestamp: Date.now(),
          priority: this.determineMessagePriority(data.content)
        }
      });
    });
    this.collaborationService.on("decisionsReached", (data) => {
      this.broadcastToSession(data.sessionId, {
        type: "decisions",
        data: {
          decisions: data.decisions,
          agents: data.agents.map((id) => getAgent(id)),
          impact: this.calculateDecisionImpact(data.decisions),
          timestamp: Date.now()
        }
      });
    });
    this.collaborationService.on("aiAnalysisComplete", (data) => {
      this.broadcastToSession(data.sessionId, {
        type: "aiAnalysis",
        data: {
          analysis: data.analysis,
          recommendations: data.recommendations,
          confidence: data.confidence,
          timestamp: Date.now()
        }
      });
    });
  }
  setupEventBusListeners() {
    this.eventBus.on("emergencyAlert", (alert) => {
      this.broadcastToAll({
        type: "emergency",
        data: alert
      }, { priority: "critical" });
    });
    this.eventBus.on("cityMetricsUpdate", (metrics) => {
      this.broadcastToAll({
        type: "metrics",
        data: metrics
      }, { priority: "low" });
    });
    this.eventBus.on("districtEvent", (event) => {
      this.broadcastToAll({
        type: "districtUpdate",
        data: event
      }, { targetDistrict: event.districtId });
    });
  }
  handleConnection(ws, sessionId, agentId, district) {
    ws.sessionId = sessionId;
    ws.agentId = agentId;
    ws.district = district;
    ws.lastActivity = Date.now();
    if (!this.connections.has(sessionId)) {
      this.connections.set(sessionId, new Set);
    }
    this.connections.get(sessionId).add(ws);
    ws.send(JSON.stringify({
      type: "connected",
      data: {
        message: `Connected to collaboration session ${sessionId}`,
        sessionId,
        agentId,
        district,
        timestamp: Date.now()
      }
    }));
    ws.on("message", (message2) => this.handleMessage(ws, message2));
    ws.on("close", () => {
      this.handleDisconnection(ws);
    });
    ws.on("error", (error4) => {
      this.handleError(ws, error4);
    });
    this.emit("connectionEstablished", {
      sessionId,
      agentId,
      district,
      timestamp: Date.now()
    });
  }
  handleMessage(ws, message2) {
    try {
      const data = JSON.parse(message2);
      ws.lastActivity = Date.now();
      switch (data.type) {
        case "heartbeat":
          this.handleHeartbeat(ws);
          break;
        case "agentAction":
          this.handleAgentAction(ws, data);
          break;
        case "districtUpdate":
          this.handleDistrictUpdate(ws, data);
          break;
        default:
          this.emit("messageReceived", {
            sessionId: ws.sessionId,
            agentId: ws.agentId,
            data,
            timestamp: Date.now()
          });
      }
    } catch (error4) {
      this.handleError(ws, error4);
    }
  }
  handleDisconnection(ws) {
    if (ws.sessionId) {
      this.connections.get(ws.sessionId)?.delete(ws);
      this.emit("connectionClosed", {
        sessionId: ws.sessionId,
        agentId: ws.agentId,
        district: ws.district,
        timestamp: Date.now()
      });
    }
  }
  handleError(ws, error4) {
    this.emit("connectionError", {
      sessionId: ws.sessionId,
      agentId: ws.agentId,
      error: error4.message,
      timestamp: Date.now()
    });
  }
  broadcastToAll(message2, options = {}) {
    const messageStr = JSON.stringify({
      ...message2,
      priority: options.priority || "medium",
      timestamp: Date.now()
    });
    for (const connections of this.connections.values()) {
      for (const client of connections) {
        if (this.shouldSendToClient(client, options)) {
          client.send(messageStr);
        }
      }
    }
  }
  broadcastToSession(sessionId, message2, options = {}) {
    const connections = this.connections.get(sessionId);
    if (!connections)
      return;
    const messageStr = JSON.stringify({
      ...message2,
      priority: options.priority || "medium",
      timestamp: Date.now()
    });
    for (const client of connections) {
      if (this.shouldSendToClient(client, options)) {
        client.send(messageStr);
      }
    }
  }
  shouldSendToClient(client, options) {
    if (client.readyState !== WebSocket.OPEN)
      return false;
    if (options.excludeSession && client.sessionId === options.excludeSession)
      return false;
    if (options.targetDistrict && client.district !== options.targetDistrict)
      return false;
    return true;
  }
  determineMessagePriority(content) {
    const messageContent = typeof content === "string" ? content : content?.message || content?.content || "";
    if (messageContent.includes("emergency") || messageContent.includes("critical"))
      return "critical";
    if (messageContent.includes("important") || messageContent.includes("urgent"))
      return "high";
    if (messageContent.includes("update") || messageContent.includes("change"))
      return "medium";
    return "low";
  }
  calculateDecisionImpact(decisions) {
    return {
      socialImpact: 0.7,
      economicImpact: 0.5,
      environmentalImpact: 0.6
    };
  }
  initializeHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      const now = Date.now();
      for (const connections of this.connections.values()) {
        for (const client of connections) {
          if (now - (client.lastActivity || 0) > 30000) {
            client.ping();
          }
        }
      }
    }, 15000);
  }
  handleHeartbeat(ws) {
    ws.lastActivity = Date.now();
    ws.send(JSON.stringify({ type: "heartbeat", timestamp: Date.now() }));
  }
  handleAgentAction(ws, data) {
    this.eventBus.emit("agentAction", {
      sessionId: ws.sessionId,
      agentId: ws.agentId,
      action: data.action,
      timestamp: Date.now()
    });
  }
  handleDistrictUpdate(ws, data) {
    this.eventBus.emit("districtUpdate", {
      district: ws.district,
      update: data.update,
      timestamp: Date.now()
    });
  }
}

// src/services/district.service.ts
import { EventEmitter as EventEmitter7 } from "events";

class DistrictService extends EventEmitter7 {
  cityService;
  vectorStore;
  togetherService;
  analyticsService;
  districtCultureService;
  districts = new Map;
  constructor(cityService, vectorStore, togetherService, analyticsService, districtCultureService) {
    super();
    this.cityService = cityService;
    this.vectorStore = vectorStore;
    this.togetherService = togetherService;
    this.analyticsService = analyticsService;
    this.districtCultureService = districtCultureService;
    this.initializeService();
  }
  async initializeService() {
    this.on("moodChanged", (district) => {
      this.analyticsService.trackMood(district.metrics.ambiance);
    });
    this.on("eventAdded", (event) => {
      this.analyticsService.trackInteraction({ id: event.districtId, type: "district" }, {
        type: "event",
        content: event.description,
        sentiment: event.impact,
        topics: [event.category, "event", event.type]
      });
    });
    const districts = await this.getAllDistricts();
    if (districts.length === 0) {
      await this.initializeDefaultDistricts();
    }
  }
  async initializeDefaultDistricts() {
    const defaultDistricts = [
      {
        name: "Downtown District",
        type: "mixed",
        population: 50000,
        boundaries: [
          [0, 0],
          [1, 0],
          [1, 1],
          [0, 1]
        ],
        area: 10,
        density: 5000,
        economicActivity: 0.8
      },
      {
        name: "Cultural Heritage District",
        type: "mixed",
        population: 30000,
        boundaries: [
          [1, 0],
          [2, 0],
          [2, 1],
          [1, 1]
        ],
        area: 8,
        density: 3750,
        economicActivity: 0.7
      },
      {
        name: "Innovation Hub",
        type: "commercial",
        population: 20000,
        boundaries: [
          [2, 0],
          [3, 0],
          [3, 1],
          [2, 1]
        ],
        area: 6,
        density: 3333,
        economicActivity: 0.9
      },
      {
        name: "Garden District",
        type: "residential",
        population: 35000,
        boundaries: [
          [0, 1],
          [1, 1],
          [1, 2],
          [0, 2]
        ],
        area: 12,
        density: 2916,
        economicActivity: 0.6
      },
      {
        name: "Industrial Park",
        type: "industrial",
        population: 15000,
        boundaries: [
          [1, 1],
          [2, 1],
          [2, 2],
          [1, 2]
        ],
        area: 15,
        density: 1000,
        economicActivity: 0.85
      },
      {
        name: "University District",
        type: "mixed",
        population: 40000,
        boundaries: [
          [2, 1],
          [3, 1],
          [3, 2],
          [2, 2]
        ],
        area: 9,
        density: 4444,
        economicActivity: 0.75
      },
      {
        name: "Waterfront District",
        type: "mixed",
        population: 25000,
        boundaries: [
          [0, 2],
          [1, 2],
          [1, 3],
          [0, 3]
        ],
        area: 7,
        density: 3571,
        economicActivity: 0.8
      },
      {
        name: "Arts District",
        type: "mixed",
        population: 28000,
        boundaries: [
          [1, 2],
          [2, 2],
          [2, 3],
          [1, 3]
        ],
        area: 8,
        density: 3500,
        economicActivity: 0.7
      }
    ];
    for (const districtData of defaultDistricts) {
      const district = {
        id: crypto.randomUUID(),
        ...districtData,
        currentEvents: [],
        transportHubs: [],
        residentAgents: [],
        visitorAgents: [],
        amenities: {
          schools: Math.floor(Math.random() * 5) + 1,
          hospitals: Math.floor(Math.random() * 3) + 1,
          parks: Math.floor(Math.random() * 6) + 2,
          shops: Math.floor(Math.random() * 50) + 20
        },
        metrics: {
          safety: 0.8,
          cleanliness: 0.7,
          noise: 0.3,
          crowding: 0.4,
          ambiance: 0.7,
          education: 0.75,
          healthcare: 0.8,
          environment: 0.7,
          economicGrowth: 0.6,
          propertyValues: 0.7,
          businessActivity: 0.6,
          infrastructureQuality: 0.7,
          publicServiceAccess: 0.6,
          transportEfficiency: 0.7,
          culturalVibrancy: 0.8,
          communityWellbeing: 0.7,
          socialCohesion: 0.8,
          energyEfficiency: 0.7,
          greenSpaceCoverage: 0.6,
          environmentalHealth: 0.7
        },
        socialMetrics: {
          communityEngagement: 0.7,
          culturalDiversity: 0.8,
          socialCohesion: 0.75,
          publicServices: 0.7,
          index: 0.75
        },
        economicMetrics: {
          employmentRate: 0.85,
          averageIncome: 65000,
          businessActivity: 0.8,
          employment: 0.85,
          index: 0.8
        }
      };
      await this.addDistrict(district);
    }
    const religiousSites = [
      {
        districtId: "Downtown District",
        sites: [
          {
            name: "Central Cathedral",
            type: "church",
            capacity: 1000
          },
          {
            name: "Grand Mosque",
            type: "mosque",
            capacity: 800
          }
        ]
      },
      {
        districtId: "Cultural Heritage District",
        sites: [
          {
            name: "Historic Temple",
            type: "temple",
            capacity: 500
          },
          {
            name: "Heritage Synagogue",
            type: "synagogue",
            capacity: 400
          }
        ]
      },
      {
        districtId: "Garden District",
        sites: [
          {
            name: "Garden Temple",
            type: "temple",
            capacity: 600
          },
          {
            name: "Nature Shrine",
            type: "temple",
            capacity: 300
          }
        ]
      },
      {
        districtId: "University District",
        sites: [
          {
            name: "Interfaith Center",
            type: "interfaith_center",
            capacity: 1200
          },
          {
            name: "Campus Chapel",
            type: "interfaith_center",
            capacity: 400
          }
        ]
      }
    ];
    for (const location of religiousSites) {
      const district = (await this.getAllDistricts()).find((d) => d.name === location.districtId);
      if (district) {
        for (const site of location.sites) {
          const coordinates = this.calculateDistrictCenter(district.boundaries);
          const religiousZone = {
            name: site.name,
            type: site.type,
            districtId: district.id,
            capacity: site.capacity,
            status: "active",
            coordinates,
            location: {
              coordinates,
              area: Math.floor(Math.random() * 1000) + 500
            },
            facilities: [
              {
                type: "prayer_hall",
                name: "Main Prayer Hall",
                purpose: "Primary worship space"
              },
              {
                type: "community_room",
                name: "Community Center",
                purpose: "Social gatherings and events"
              },
              {
                type: "education_room",
                name: "Study Room",
                purpose: "Religious education and study"
              }
            ],
            activities: [
              {
                name: "Weekly Service",
                schedule: "Every Sunday 10:00 AM",
                participation: 0.8
              },
              {
                name: "Community Gathering",
                schedule: "Every Wednesday 6:00 PM",
                participation: 0.6
              },
              {
                name: "Religious Education",
                schedule: "Every Saturday 2:00 PM",
                participation: 0.5
              }
            ],
            metrics: {
              attendance: 0.7,
              communityEngagement: 0.8,
              culturalImpact: 0.75,
              socialHarmony: 0.9
            },
            culturalMetrics: {
              communityEngagement: 0.85,
              interfaithDialogue: 0.8,
              culturalPreservation: 0.75,
              socialImpact: 0.9
            }
          };
          await this.districtCultureService.createReligiousZone(religiousZone);
        }
      }
    }
    const culturalSites = [
      {
        districtId: "Arts District",
        type: "artistic",
        sites: [
          { name: "Contemporary Art Museum", type: "Museum" },
          { name: "Performing Arts Center", type: "Theater" },
          { name: "Artists' Colony", type: "Cultural Center" }
        ]
      },
      {
        districtId: "Cultural Heritage District",
        type: "historical",
        sites: [
          { name: "Heritage Museum", type: "Museum" },
          { name: "Traditional Arts Center", type: "Cultural Center" },
          { name: "Folk Music Hall", type: "Performance Venue" }
        ]
      },
      {
        districtId: "Downtown District",
        type: "mixed",
        sites: [
          { name: "City Museum", type: "Museum" },
          { name: "Opera House", type: "Theater" },
          { name: "Cultural Exchange Center", type: "Cultural Center" }
        ]
      },
      {
        districtId: "Waterfront District",
        type: "mixed",
        sites: [
          { name: "Maritime Museum", type: "Museum" },
          { name: "Waterfront Amphitheater", type: "Performance Venue" },
          { name: "Cultural Festival Plaza", type: "Cultural Center" }
        ]
      }
    ];
    for (const location of culturalSites) {
      const district = (await this.getAllDistricts()).find((d) => d.name === location.districtId);
      if (district) {
        const coordinates = this.calculateDistrictCenter(district.boundaries);
        const religiousZones = [
          {
            id: crypto.randomUUID(),
            name: "Cultural District Prayer Room",
            type: "interfaith_center",
            districtId: district.id,
            capacity: 100,
            status: "active",
            coordinates,
            location: {
              coordinates,
              area: Math.floor(Math.random() * 500) + 200
            },
            facilities: [
              {
                type: "prayer_room",
                name: "Interfaith Prayer Room",
                purpose: "Multi-faith worship space"
              },
              {
                type: "meditation_room",
                name: "Meditation Room",
                purpose: "Quiet reflection and meditation"
              }
            ],
            activities: [
              {
                name: "Interfaith Prayer",
                schedule: "Daily 12:00 PM",
                participation: 0.5
              },
              {
                name: "Meditation Session",
                schedule: "Every Tuesday 5:00 PM",
                participation: 0.4
              }
            ],
            metrics: {
              attendance: 0.6,
              communityEngagement: 0.7,
              culturalImpact: 0.65,
              socialHarmony: 0.8
            },
            culturalMetrics: {
              communityEngagement: 0.75,
              interfaithDialogue: 0.8,
              culturalPreservation: 0.7,
              socialImpact: 0.75
            }
          }
        ];
        const culturalDistrict = {
          name: `${district.name} Cultural Zone`,
          type: location.type,
          districtId: district.id,
          zones: religiousZones,
          culturalSites: location.sites.map((site) => ({
            id: crypto.randomUUID(),
            name: site.name,
            type: site.type,
            status: "active",
            coordinates,
            metrics: {
              visitorCount: Math.floor(Math.random() * 1000) + 500,
              eventFrequency: Math.floor(Math.random() * 10) + 5,
              culturalImpact: Math.random() * 0.3 + 0.7,
              communityEngagement: Math.random() * 0.3 + 0.7
            }
          })),
          culturalEvents: [],
          demographics: {
            youth_population: Math.random() * 0.3 + 0.2,
            adult_population: Math.random() * 0.3 + 0.4,
            senior_population: Math.random() * 0.2 + 0.1,
            local_visitors: Math.random() * 0.4 + 0.4,
            domestic_visitors: Math.random() * 0.3 + 0.2,
            international_visitors: Math.random() * 0.2 + 0.1
          },
          metrics: {
            diversity: 0.8,
            preservation: 0.75,
            engagement: 0.8,
            harmony: 0.85
          }
        };
        await this.districtCultureService.createCulturalDistrict(culturalDistrict);
      }
    }
  }
  calculateDistrictCenter(boundaries) {
    const x = boundaries.reduce((sum, coord) => sum + coord[0], 0) / boundaries.length;
    const y = boundaries.reduce((sum, coord) => sum + coord[1], 0) / boundaries.length;
    return [x, y];
  }
  async getAllDistricts() {
    return Array.from(this.districts.values());
  }
  async getDistrict(id) {
    return this.districts.get(id) || null;
  }
  async addEventToDistrict(id, eventData) {
    const district = await this.getDistrict(id);
    if (!district)
      throw new Error("District not found");
    const categoryMap = {
      environmental: "environmental",
      cultural: "cultural",
      community: "social",
      urban_development: "economic",
      transportation: "economic",
      infrastructure: "economic",
      emergency: "environmental",
      health: "social",
      education: "social",
      technology: "economic"
    };
    const event = {
      id: crypto.randomUUID(),
      type: eventData.category,
      name: eventData.title,
      description: eventData.description,
      category: categoryMap[eventData.category] || "social",
      startTime: eventData.timestamp || Date.now(),
      endTime: (eventData.timestamp || Date.now()) + (eventData.duration || 3600000),
      urgency: eventData.urgency || eventData.severity / 10,
      impact: {
        type: eventData.category,
        severity: eventData.severity,
        radius: 1000,
        environmental: eventData.impact?.environmental || 0,
        social: eventData.impact?.social || 0,
        economic: eventData.impact?.economic || 0
      },
      location: [0, 0],
      status: eventData.status || "pending",
      affectedDistricts: [id],
      propagationProbability: 0.5
    };
    const coordinates = await this.getDistrictCoordinates(id);
    if (coordinates) {
      event.location = coordinates;
    }
    district.currentEvents.push(event);
    this.emit("eventAdded", { districtId: id, event });
    await this.vectorStore.upsert({
      id: `district-event-${event.id}`,
      values: await this.vectorStore.createEmbedding(`${event.type} event in district ${id}: ${event.description}`),
      metadata: {
        type: "district",
        districtId: id,
        eventId: event.id,
        category: event.category,
        severity: event.impact.severity,
        timestamp: event.startTime
      }
    });
    return event;
  }
  async getDistrictAnalytics(id) {
    const district = await this.getDistrict(id);
    if (!district)
      throw new Error("District not found");
    const eventsByCategory = district.currentEvents.reduce((acc, event) => {
      acc[event.category] = (acc[event.category] || 0) + 1;
      return acc;
    }, {});
    const analytics = {
      totalEvents: district.currentEvents.length,
      eventsByCategory,
      eventResolutionRate: this.calculateResolutionRate(district),
      populationTrends: this.getPopulationTrends(district),
      currentAmbiance: district.metrics.ambiance,
      ambianceTrend: this.calculateAmbianceTrend(district),
      transportUtilization: this.calculateTransportUtilization(district),
      transportEfficiency: this.calculateTransportEfficiency(district),
      noiseLevel: district.metrics.noise,
      crowdingLevel: district.metrics.crowding,
      safetyScore: district.metrics.safety,
      cleanlinessScore: district.metrics.cleanliness
    };
    this.analyticsService.trackInteraction({ id: district.id, type: "district" }, {
      type: "analytics",
      content: `District ${district.id} analytics retrieved`,
      sentiment: (analytics.safetyScore + analytics.cleanlinessScore) / 2,
      topics: ["district", "analytics", "metrics"]
    });
    return analytics;
  }
  async addTransportHub(id, hubData) {
    const district = await this.getDistrict(id);
    if (!district)
      throw new Error("District not found");
    const hub = {
      id: crypto.randomUUID(),
      type: hubData.type,
      capacity: hubData.capacity,
      schedule: hubData.schedule || {
        weekday: [],
        weekend: [],
        holidays: []
      },
      currentUtilization: 0,
      status: "active",
      lastMaintenance: Date.now()
    };
    district.transportHubs.push(hub);
    this.emit("transportHubAdded", { districtId: id, hub });
    return hub;
  }
  calculateResolutionRate(district) {
    const resolvedEvents = district.currentEvents.filter((event) => event.status === "resolved").length;
    return district.currentEvents.length > 0 ? resolvedEvents / district.currentEvents.length : 1;
  }
  getPopulationTrends(district) {
    const trends = [];
    const now = Date.now();
    const dayInMs = 24 * 60 * 60 * 1000;
    for (let i = 6;i >= 0; i--) {
      const timestamp = now - i * dayInMs;
      const basePopulation = district.population;
      const variation = Math.random() * 0.1 - 0.05;
      trends.push({
        timestamp,
        count: Math.round(basePopulation * (1 + variation))
      });
    }
    return trends;
  }
  calculateAmbianceTrend(district) {
    const factors = {
      noise: district.metrics.noise,
      crowding: district.metrics.crowding,
      cleanliness: district.metrics.cleanliness,
      safety: district.metrics.safety,
      culturalVibrancy: district.metrics.culturalVibrancy
    };
    const score = Object.values(factors).reduce((sum, value2) => sum + value2, 0) / 5;
    if (score > 0.7)
      return "improving";
    if (score < 0.4)
      return "declining";
    return "stable";
  }
  calculateTransportUtilization(district) {
    if (!district.transportHubs.length)
      return 0;
    const utilization = district.transportHubs.reduce((sum, hub) => {
      const timeOfDay = new Date().getHours();
      const scheduleLoad = this.getScheduleLoad(hub.schedule, timeOfDay);
      return sum + hub.currentUtilization * scheduleLoad;
    }, 0);
    return utilization / district.transportHubs.length;
  }
  getScheduleLoad(schedule, hour2) {
    if (!schedule)
      return 0;
    const peakHours = [7, 8, 9, 17, 18, 19];
    const moderateHours = [10, 11, 12, 13, 14, 15, 16];
    const isWeekend = new Date().getDay() % 6 === 0;
    const scheduleToCheck = isWeekend ? schedule.weekend : schedule.weekday;
    if (!scheduleToCheck || scheduleToCheck.length === 0)
      return 0;
    if (peakHours.includes(hour2))
      return 1.5;
    if (moderateHours.includes(hour2))
      return 1;
    return 0.5;
  }
  calculateTransportEfficiency(district) {
    if (!district.transportHubs || district.transportHubs.length === 0) {
      return 0;
    }
    const totalUtilization = district.transportHubs.reduce((sum, hub) => sum + hub.currentUtilization, 0);
    return totalUtilization / district.transportHubs.length;
  }
  calculateHubDensity(district) {
    const area = this.calculateDistrictArea(district);
    return Math.min(1, district.transportHubs.length / (area * 0.1));
  }
  calculateNetworkConnectivity(district) {
    const connectedHubs = district.transportHubs.filter((hub) => hub.status === "active" && this.hasValidConnections(hub)).length;
    return connectedHubs / Math.max(district.transportHubs.length, 1);
  }
  hasValidConnections(hub) {
    if (!hub.schedule)
      return false;
    const hasWeekday = Array.isArray(hub.schedule.weekday) && hub.schedule.weekday.length > 0;
    const hasWeekend = Array.isArray(hub.schedule.weekend) && hub.schedule.weekend.length > 0;
    return hasWeekday || hasWeekend;
  }
  calculateMaintenanceStatus(district) {
    const now = Date.now();
    return district.transportHubs.reduce((sum, hub) => {
      const daysSinceLastMaintenance = (now - hub.lastMaintenance) / (1000 * 60 * 60 * 24);
      return sum + Math.max(0, 1 - daysSinceLastMaintenance / 30);
    }, 0) / Math.max(district.transportHubs.length, 1);
  }
  calculateDistrictArea(district) {
    return 10;
  }
  async addDistrict(district) {
    this.districts.set(district.id, district);
    this.emit("districtAdded", district);
    return district;
  }
  async addResidentAgent(districtId, agentId) {
    const district = await this.getDistrict(districtId);
    if (!district)
      throw new Error("District not found");
    district.residentAgents.push(agentId);
    await this.vectorStore.upsert({
      id: `agent-residence-${agentId}`,
      values: await this.togetherService.createEmbedding(`Agent ${agentId} resides in district ${districtId}`),
      metadata: {
        type: "agent_residence",
        agentId,
        districtId,
        timestamp: Date.now()
      }
    });
  }
  async recordAgentVisit(districtId, agentId) {
    const district = await this.getDistrict(districtId);
    if (!district)
      throw new Error("District not found");
    district.visitorAgents.push(agentId);
    await this.vectorStore.upsert({
      id: `agent-visit-${agentId}-${Date.now()}`,
      values: await this.togetherService.createEmbedding(`Agent ${agentId} visited district ${districtId}`),
      metadata: {
        type: "agent_visit",
        agentId,
        districtId,
        timestamp: Date.now()
      }
    });
  }
  async getAllMetrics() {
    const districts = await this.getAllDistricts();
    const metricsPromises = districts.map(async (district) => {
      const detailedMetrics = await this.getDistrictMetrics(district.id);
      return {
        id: district.id,
        name: district.name,
        type: district.type,
        population: district.population,
        density: district.density,
        economicActivity: district.economicActivity,
        metrics: {
          safety: district.metrics.safety,
          communityWellbeing: district.metrics.communityWellbeing,
          socialCohesion: district.metrics.socialCohesion,
          publicServiceAccess: district.metrics.publicServiceAccess,
          cleanliness: district.metrics.cleanliness,
          noise: district.metrics.noise,
          crowding: district.metrics.crowding,
          ambiance: district.metrics.ambiance,
          environmentalHealth: district.metrics.environmentalHealth,
          culturalVibrancy: district.metrics.culturalVibrancy,
          economicGrowth: district.metrics.economicGrowth,
          businessActivity: district.metrics.businessActivity,
          infrastructureQuality: district.metrics.infrastructureQuality,
          transportEfficiency: district.metrics.transportEfficiency,
          energyEfficiency: district.metrics.energyEfficiency,
          greenSpaceCoverage: district.metrics.greenSpaceCoverage
        },
        detailedMetrics: detailedMetrics || {
          socialMetrics: {
            index: 0.5,
            communityEngagement: 0.5,
            publicServices: 0.5,
            culturalDiversity: 0.5,
            socialCohesion: 0.5
          },
          economicMetrics: {
            index: 0.5,
            businessActivity: 0.5,
            employment: 0.5,
            innovation: 0.5,
            marketDynamics: 0.5
          },
          culturalMetrics: {
            index: 0.5,
            events: 0.5,
            heritage: 0.5,
            diversity: 0.5,
            participation: 0.5
          },
          environmentalMetrics: {
            index: 0.5,
            sustainability: 0.5,
            greenSpace: 0.5,
            pollution: 0.5,
            resourceEfficiency: 0.5
          },
          infrastructureMetrics: {
            index: 0.5,
            maintenance: 0.5,
            accessibility: 0.5,
            smartIntegration: 0.5,
            resilience: 0.5
          }
        }
      };
    });
    return Promise.all(metricsPromises);
  }
  async updateMetrics(districtId, metrics) {
    const district = await this.getDistrict(districtId);
    if (!district) {
      throw new Error(`District not found: ${districtId}`);
    }
    const currentMetrics = await this.getDistrictMetrics(districtId);
    if (!currentMetrics) {
      throw new Error(`Could not retrieve current metrics for district: ${districtId}`);
    }
    const updatedMetrics = {
      socialMetrics: {
        ...currentMetrics.socialMetrics,
        ...metrics.socialMetrics
      },
      economicMetrics: {
        ...currentMetrics.economicMetrics,
        ...metrics.economicMetrics
      },
      culturalMetrics: {
        ...currentMetrics.culturalMetrics,
        ...metrics.culturalMetrics
      },
      environmentalMetrics: {
        ...currentMetrics.environmentalMetrics,
        ...metrics.environmentalMetrics
      },
      infrastructureMetrics: {
        ...currentMetrics.infrastructureMetrics,
        ...metrics.infrastructureMetrics
      }
    };
    await this.vectorStore.upsert({
      id: `district-${districtId}-metrics-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(`District ${district.name} metrics update: ` + `Social: ${updatedMetrics.socialMetrics.index}, ` + `Economic: ${updatedMetrics.economicMetrics.index}, ` + `Cultural: ${updatedMetrics.culturalMetrics.index}, ` + `Environmental: ${updatedMetrics.environmentalMetrics.index}, ` + `Infrastructure: ${updatedMetrics.infrastructureMetrics.index}`),
      metadata: {
        type: "district_metrics",
        districtId,
        socialMetrics: JSON.stringify(updatedMetrics.socialMetrics),
        economicMetrics: JSON.stringify(updatedMetrics.economicMetrics),
        culturalMetrics: JSON.stringify(updatedMetrics.culturalMetrics),
        environmentalMetrics: JSON.stringify(updatedMetrics.environmentalMetrics),
        infrastructureMetrics: JSON.stringify(updatedMetrics.infrastructureMetrics),
        timestamp: Date.now()
      }
    });
    const updatedDistrict = {
      ...district,
      metrics: {
        ...district.metrics,
        safety: updatedMetrics.socialMetrics.index,
        cleanliness: updatedMetrics.environmentalMetrics.sustainability,
        noise: updatedMetrics.environmentalMetrics.pollution,
        crowding: updatedMetrics.infrastructureMetrics.accessibility,
        ambiance: updatedMetrics.culturalMetrics.index,
        culturalVibrancy: updatedMetrics.culturalMetrics.diversity,
        communityWellbeing: updatedMetrics.socialMetrics.communityEngagement,
        socialCohesion: updatedMetrics.socialMetrics.socialCohesion,
        economicGrowth: updatedMetrics.economicMetrics.index,
        businessActivity: updatedMetrics.economicMetrics.businessActivity,
        infrastructureQuality: updatedMetrics.infrastructureMetrics.maintenance,
        publicServiceAccess: updatedMetrics.socialMetrics.publicServices,
        transportEfficiency: updatedMetrics.infrastructureMetrics.accessibility,
        energyEfficiency: updatedMetrics.environmentalMetrics.resourceEfficiency,
        greenSpaceCoverage: updatedMetrics.environmentalMetrics.greenSpace,
        environmentalHealth: updatedMetrics.environmentalMetrics.index
      }
    };
    this.districts.set(districtId, updatedDistrict);
    this.emit("districtUpdated", updatedDistrict);
    return updatedDistrict;
  }
  async getDistrictMetrics(districtId) {
    const district = await this.getDistrict(districtId);
    if (!district)
      return null;
    const results = await this.vectorStore.query({
      vector: await this.vectorStore.createEmbedding(`district ${districtId} metrics`),
      filter: {
        type: { $eq: "district_metrics" },
        districtId: { $eq: districtId }
      },
      topK: 1
    });
    if (!results.matches?.length) {
      return {
        socialMetrics: {
          index: 0.5,
          communityEngagement: 0.5,
          publicServices: 0.5,
          culturalDiversity: 0.5,
          socialCohesion: 0.5
        },
        economicMetrics: {
          index: 0.5,
          businessActivity: 0.5,
          employment: 0.5,
          innovation: 0.5,
          marketDynamics: 0.5
        },
        culturalMetrics: {
          index: 0.5,
          events: 0.5,
          heritage: 0.5,
          diversity: 0.5,
          participation: 0.5
        },
        environmentalMetrics: {
          index: 0.5,
          sustainability: 0.5,
          greenSpace: 0.5,
          pollution: 0.5,
          resourceEfficiency: 0.5
        },
        infrastructureMetrics: {
          index: 0.5,
          maintenance: 0.5,
          accessibility: 0.5,
          smartIntegration: 0.5,
          resilience: 0.5
        }
      };
    }
    return {
      socialMetrics: JSON.parse(results.matches[0].metadata.socialMetrics),
      economicMetrics: JSON.parse(results.matches[0].metadata.economicMetrics),
      culturalMetrics: JSON.parse(results.matches[0].metadata.culturalMetrics),
      environmentalMetrics: JSON.parse(results.matches[0].metadata.environmentalMetrics),
      infrastructureMetrics: JSON.parse(results.matches[0].metadata.infrastructureMetrics)
    };
  }
  async getDistrictCoordinates(districtId) {
    try {
      const district = await this.getDistrict(districtId);
      if (!district || !district.boundaries || district.boundaries.length === 0) {
        return null;
      }
      const coordinates = district.boundaries.reduce((acc, coord) => {
        acc[0] += coord[0];
        acc[1] += coord[1];
        return acc;
      }, [0, 0]);
      return [
        coordinates[0] / district.boundaries.length,
        coordinates[1] / district.boundaries.length
      ];
    } catch (error4) {
      console.error(`Failed to get coordinates for district ${districtId}:`, error4);
      return null;
    }
  }
}

// src/services/city-events.service.ts
import { EventEmitter as EventEmitter8 } from "events";

class CityEventsService extends EventEmitter8 {
  metricsService;
  collaborationService;
  vectorStore;
  districtService;
  analyticsService;
  activeEvents = new Map;
  constructor(metricsService, collaborationService, vectorStore, districtService, analyticsService) {
    super();
    this.metricsService = metricsService;
    this.collaborationService = collaborationService;
    this.vectorStore = vectorStore;
    this.districtService = districtService;
    this.analyticsService = analyticsService;
    this.initializeService();
  }
  initializeService() {
    this.startRandomEventGenerator();
    this.on("eventCreated", (event) => {
      this.analyticsService.trackInteraction({ id: event.id, type: "city_event" }, {
        type: "event",
        content: event.description,
        sentiment: event.impact > 0 ? 0.7 : 0.3,
        topics: ["city_event", event.category, event.type]
      });
    });
    this.on("eventResolved", (event) => {
      this.analyticsService.trackInteraction({ id: event.id, type: "city_event" }, {
        type: "resolution",
        content: `Event resolved: ${event.description}`,
        sentiment: 0.8,
        topics: ["resolution", event.category, "success"]
      });
    });
    this.on("eventImpactAssessed", (assessment) => {
      this.analyticsService.trackInteraction({ id: assessment.eventId, type: "city_event" }, {
        type: "impact",
        content: `Impact assessment: ${assessment.description}`,
        sentiment: assessment.score,
        topics: ["impact", assessment.category, "assessment"]
      });
      this.analyticsService.trackMood(assessment.score);
    });
  }
  async startRandomEventGenerator() {
    setInterval(() => {
      if (Math.random() < 0.3) {
        this.generateRandomEvent();
      }
    }, 5 * 60 * 1000);
  }
  async generateRandomEvent(customEvent) {
    const event = customEvent || this.selectRandomEvent();
    const affectedDistrict = await this.selectAffectedDistrict(event);
    await this.vectorStore.upsert({
      id: `event-${event.id}`,
      values: await this.vectorStore.createEmbedding(`${event.title} ${event.description} priority:${event.priority} ` + `district:${affectedDistrict.name} time:${event.timeContext.preferredTimeOfDay}`),
      metadata: {
        type: "district",
        eventId: event.id,
        priority: event.priority,
        districtId: affectedDistrict.id,
        timestamp: Date.now(),
        cascading: !!customEvent
      }
    });
    const metricUpdates = {};
    event.impacts.forEach((impact) => {
      const category = impact.category;
      if (!metricUpdates[category]) {
        metricUpdates[category] = {};
      }
      const [_3, metric] = impact.metric.split(".");
      metricUpdates[category][metric] = impact.change;
    });
    await this.metricsService.updateMetrics(metricUpdates);
    await this.handleCascadingEffects(event);
    for (const agentId of event.requiredAgents) {
      await this.districtService.recordAgentVisit(affectedDistrict.id, agentId);
    }
    await this.collaborationService.initiateCollaboration({
      id: event.id,
      title: event.title,
      description: event.description,
      category: "emergency",
      severity: event.severity,
      duration: Math.max(...event.impacts.map((i) => i.duration)),
      urgency: event.severity,
      impact: {
        environmental: 0.7,
        social: 0.8,
        economic: 0.6
      },
      requiredAgents: event.requiredAgents,
      affectedDistricts: [affectedDistrict.id],
      timestamp: Date.now(),
      status: "pending"
    });
    this.emit("eventGenerated", event);
  }
  async selectAffectedDistrict(event) {
    const districts = await this.districtService.getAllDistricts();
    if (!districts || districts.length === 0) {
      console.warn("No districts available in the system");
      throw new Error("No districts available");
    }
    const query = await this.vectorStore.query({
      vector: await this.vectorStore.createEmbedding(`${event.title} ${event.description}`),
      filter: {
        type: { $eq: "district_context" }
      },
      topK: 1
    });
    if (query.matches && query.matches.length > 0) {
      const districtId = query.matches[0].metadata.districtId;
      const matchedDistrict = districts.find((d) => d.id === districtId);
      if (matchedDistrict) {
        return matchedDistrict;
      }
    }
    const randomIndex = Math.floor(Math.random() * districts.length);
    return districts[randomIndex];
  }
  selectRandomEvent() {
    const events = [
      {
        id: crypto.randomUUID(),
        title: "Smart Grid Fluctuation",
        description: "Energy grid showing unusual patterns in renewable integration",
        severity: 0.7,
        priority: "high",
        impacts: [
          {
            category: "infrastructure",
            metric: "smartGridEfficiency",
            change: -0.3,
            duration: 3 * 60 * 60 * 1000
          },
          {
            category: "sustainability",
            metric: "renewableEnergyRatio",
            change: -0.2,
            duration: 3 * 60 * 60 * 1000
          }
        ],
        requiredAgents: ["raj", "olivia"],
        districtTypes: ["residential", "commercial"],
        timeContext: {
          preferredTimeOfDay: "afternoon",
          weatherSensitive: true,
          seasonalFactor: "summer"
        }
      },
      {
        id: crypto.randomUUID(),
        title: "Cultural District Unrest",
        description: "Community tensions rising over heritage building renovation",
        severity: 0.6,
        priority: "medium",
        impacts: [
          {
            category: "social",
            metric: "communityWellbeing",
            change: -0.4,
            duration: 12 * 60 * 60 * 1000
          },
          {
            category: "economy",
            metric: "businessFormationRate",
            change: -0.2,
            duration: 24 * 60 * 60 * 1000
          }
        ],
        requiredAgents: ["elena", "sophia"],
        districtTypes: ["mixed", "commercial"],
        cascadingEffects: {
          probability: 0.4,
          relatedEvents: ["protest", "media_coverage"],
          spreadPattern: "clustered"
        },
        timeContext: {
          preferredTimeOfDay: "morning",
          weatherSensitive: false,
          seasonalFactor: "spring"
        }
      },
      {
        id: crypto.randomUUID(),
        title: "Public Health Alert",
        description: "Unusual pattern of respiratory complaints in district",
        severity: 0.8,
        priority: "critical",
        impacts: [
          {
            category: "social",
            metric: "healthcareAccessScore",
            change: -0.3,
            duration: 48 * 60 * 60 * 1000
          },
          {
            category: "sustainability",
            metric: "airQualityIndex",
            change: 200,
            duration: 24 * 60 * 60 * 1000
          }
        ],
        requiredAgents: ["elena", "olivia", "raj"],
        districtTypes: ["residential", "mixed"],
        cascadingEffects: {
          probability: 0.6,
          relatedEvents: ["school_closure", "emergency_measures"],
          spreadPattern: "exponential"
        },
        timeContext: {
          preferredTimeOfDay: "morning",
          weatherSensitive: true,
          seasonalFactor: "winter"
        }
      }
    ];
    const currentHour = new Date().getHours();
    const timeOfDay = currentHour >= 5 && currentHour < 12 ? "morning" : currentHour >= 12 && currentHour < 17 ? "afternoon" : currentHour >= 17 && currentHour < 22 ? "evening" : "night";
    const contextuallyRelevantEvents = events.filter((event) => {
      if (event.timeContext.preferredTimeOfDay && event.timeContext.preferredTimeOfDay !== timeOfDay) {
        return false;
      }
      return true;
    });
    return contextuallyRelevantEvents.length > 0 ? contextuallyRelevantEvents[Math.floor(Math.random() * contextuallyRelevantEvents.length)] : events[Math.floor(Math.random() * events.length)];
  }
  async resolveEvent(eventId) {
    const event = this.activeEvents.get(eventId);
    if (!event)
      return;
    const metricUpdates = {};
    event.impacts.forEach((impact) => {
      const category = impact.category;
      if (!metricUpdates[category]) {
        metricUpdates[category] = {};
      }
      const [_3, metric] = impact.metric.split(".");
      metricUpdates[category][metric] = 0;
    });
    await this.metricsService.updateMetrics(metricUpdates);
    this.activeEvents.delete(eventId);
    this.emit("eventResolved", eventId);
  }
  async findAgentHomeDistrict(agentId) {
    const embedding = await this.vectorStore.createEmbedding(`agent ${agentId} home district`);
    const query = await this.vectorStore.query({
      vector: embedding,
      filter: {
        type: { $eq: "agent_residence" },
        agentId: { $eq: agentId }
      },
      topK: 1
    });
    if (query.matches.length > 0) {
      const districtId = query.matches[0].metadata.districtId;
      return this.districtService.getDistrict(districtId);
    }
    return null;
  }
  async handleCascadingEffects(event) {
    if (!event.cascadingEffects)
      return;
    if (Math.random() < event.cascadingEffects.probability) {
      for (const relatedEventType of event.cascadingEffects.relatedEvents) {
        const delay = event.cascadingEffects.spreadPattern === "exponential" ? Math.random() * 60 * 60 * 1000 : 30 * 60 * 1000;
        setTimeout(() => {
          this.generateSecondaryEvent(event, relatedEventType);
        }, delay);
      }
    }
  }
  async generateSecondaryEvent(primaryEvent, eventType) {
    const secondaryEvent = this.createSecondaryEvent(primaryEvent, eventType);
    await this.generateRandomEvent(secondaryEvent);
  }
  createSecondaryEvent(primaryEvent, eventType) {
    const baseEvent = {
      id: crypto.randomUUID(),
      title: `${eventType} following ${primaryEvent.title}`,
      description: `Secondary event triggered by ${primaryEvent.description}`,
      severity: primaryEvent.severity * 0.8,
      priority: primaryEvent.priority,
      impacts: primaryEvent.impacts.map((impact) => ({
        ...impact,
        change: impact.change * 0.7,
        duration: impact.duration * 0.5
      })),
      requiredAgents: primaryEvent.requiredAgents.slice(0, 2),
      districtTypes: primaryEvent.districtTypes,
      timeContext: {
        preferredTimeOfDay: primaryEvent.timeContext.preferredTimeOfDay,
        weatherSensitive: primaryEvent.timeContext.weatherSensitive,
        seasonalFactor: primaryEvent.timeContext.seasonalFactor
      }
    };
    return baseEvent;
  }
  async getActiveEvents() {
    return [];
  }
  async getCurrentEvents() {
    const activeEvents = await this.getActiveEvents();
    return activeEvents.map((event) => event.title);
  }
}

// src/services/metrics.service.ts
import { EventEmitter as EventEmitter9 } from "events";

class MetricsService extends EventEmitter9 {
  vectorStore;
  currentMetrics;
  metricsHistory = [];
  constructor(vectorStore) {
    super();
    this.vectorStore = vectorStore;
    this.currentMetrics = this.initializeMetrics();
    this.initializeMonitoring();
  }
  initializeMonitoring() {
    setInterval(() => this.monitorAIMetrics(), 60 * 1000);
    setInterval(() => this.analyzeAIPerformance(), 5 * 60 * 1000);
    setInterval(() => this.updateAISafetyMetrics(), 15 * 60 * 1000);
  }
  async monitorAIMetrics() {
    const aiMetrics = await this.gatherAIMetrics();
    await this.updateMetrics({ ai: aiMetrics });
  }
  async analyzeAIPerformance() {
    const performance2 = await this.calculateAIPerformance();
    if (performance2.bottlenecks.length > 0) {
      this.emit("aiOptimizationNeeded", performance2.optimizationSuggestions);
    }
    return performance2;
  }
  async updateAISafetyMetrics() {
    const safetyMetrics = await this.assessAISafety();
    if (safetyMetrics.hasIssues) {
      this.emit("aiSafetyAlert", safetyMetrics.issues);
    }
  }
  async updateMetrics(updates) {
    this.currentMetrics = {
      ...this.currentMetrics,
      ...updates
    };
    await this.vectorStore.upsert({
      id: `metrics-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(JSON.stringify(updates)),
      metadata: {
        type: "district",
        timestamp: Date.now(),
        metrics: JSON.stringify(updates)
      }
    });
    this.metricsHistory.push({
      timestamp: Date.now(),
      metrics: this.currentMetrics
    });
    if (this.metricsHistory.length > 1000) {
      this.metricsHistory = this.metricsHistory.slice(-1000);
    }
    this.emit("metricsUpdated", this.currentMetrics);
  }
  async getMetricsAnalysis() {
    return {
      current: this.currentMetrics,
      trends: this.analyzeTrends(),
      recommendations: await this.generateRecommendations(),
      aiInsights: await this.generateAIInsights()
    };
  }
  async generateAIInsights() {
    const performance2 = await this.analyzeAIPerformance();
    const safety = await this.assessAISafety();
    const innovation = await this.evaluateAIInnovation();
    return {
      performance: performance2,
      safety,
      innovation
    };
  }
  async gatherAIMetrics() {
    return {
      agentActivity: {
        activeAgents: 0,
        averageResponseTime: 0,
        interactionQuality: 0,
        taskCompletionRate: 0,
        learningProgress: 0
      },
      computationalResources: {
        cpuUtilization: 0,
        memoryUsage: 0,
        networkBandwidth: 0,
        storageCapacity: 0,
        processingLatency: 0
      },
      aiServices: {
        availabilityRate: 0,
        accuracyScore: 0,
        adaptabilityIndex: 0,
        innovationRate: 0,
        userSatisfaction: 0
      },
      dataMetrics: {
        dataQuality: 0,
        dataProcessingRate: 0,
        insightGeneration: 0,
        predictionAccuracy: 0,
        anomalyDetection: 0
      },
      aiSafety: {
        securityScore: 0,
        biasRating: 0,
        ethicsCompliance: 0,
        privacyProtection: 0,
        systemReliability: 0
      }
    };
  }
  async calculateAIPerformance() {
    const metrics = this.currentMetrics.ai;
    const bottlenecks = this.identifyBottlenecks(metrics);
    const optimizationSuggestions = await this.generateOptimizationSuggestions(bottlenecks);
    return {
      score: this.calculatePerformanceScore(metrics),
      bottlenecks,
      optimizationSuggestions
    };
  }
  async assessAISafety() {
    const metrics = this.currentMetrics.ai.aiSafety;
    const risks = this.identifySafetyRisks(metrics);
    const mitigationStrategies = await this.generateMitigationStrategies(risks);
    return {
      score: this.calculateSafetyScore(metrics),
      hasIssues: risks.length > 0,
      issues: risks,
      risks,
      mitigationStrategies
    };
  }
  async evaluateAIInnovation() {
    const metrics = this.currentMetrics.ai;
    const opportunities = await this.identifyInnovationOpportunities(metrics);
    const researchDirections = await this.suggestResearchDirections(opportunities);
    return {
      score: this.calculateInnovationScore(metrics),
      opportunities,
      researchDirections
    };
  }
  identifyBottlenecks(metrics) {
    const bottlenecks = [];
    if (metrics.computationalResources.cpuUtilization > 0.8) {
      bottlenecks.push("High CPU utilization");
    }
    if (metrics.computationalResources.memoryUsage > 0.8) {
      bottlenecks.push("High memory usage");
    }
    if (metrics.agentActivity.averageResponseTime > 2000) {
      bottlenecks.push("High response time");
    }
    if (metrics.aiServices.accuracyScore < 0.8) {
      bottlenecks.push("Low accuracy score");
    }
    return bottlenecks;
  }
  async generateOptimizationSuggestions(bottlenecks) {
    const suggestions = [];
    for (const bottleneck of bottlenecks) {
      const query = await this.vectorStore.query({
        vector: await this.vectorStore.createEmbedding(`optimization solutions for ${bottleneck}`),
        filter: {
          type: { $eq: "optimization" }
        },
        topK: 1
      });
      if (query.matches.length > 0) {
        suggestions.push(query.matches[0].metadata.solution);
      }
    }
    return suggestions;
  }
  identifySafetyRisks(metrics) {
    const risks = [];
    if (metrics.securityScore < 0.7) {
      risks.push("Security vulnerabilities detected");
    }
    if (metrics.biasRating > 0.3) {
      risks.push("Significant bias detected");
    }
    if (metrics.ethicsCompliance < 0.9) {
      risks.push("Ethics compliance issues");
    }
    if (metrics.privacyProtection < 0.8) {
      risks.push("Privacy protection concerns");
    }
    return risks;
  }
  async generateMitigationStrategies(risks) {
    const strategies = [];
    for (const risk of risks) {
      const query = await this.vectorStore.query({
        vector: await this.vectorStore.createEmbedding(`mitigation strategies for ${risk}`),
        filter: {
          type: { $eq: "mitigation" }
        },
        topK: 1
      });
      if (query.matches.length > 0) {
        strategies.push(query.matches[0].metadata.strategy);
      }
    }
    return strategies;
  }
  async identifyInnovationOpportunities(metrics) {
    const opportunities = [];
    if (metrics.aiServices.adaptabilityIndex > 0.8) {
      opportunities.push("High adaptability enables new service types");
    }
    if (metrics.dataMetrics.insightGeneration > 0.7) {
      opportunities.push("Strong insight generation capabilities");
    }
    if (metrics.agentActivity.learningProgress > 0.8) {
      opportunities.push("Advanced learning capabilities");
    }
    return opportunities;
  }
  async suggestResearchDirections(opportunities) {
    const directions = [];
    for (const opportunity of opportunities) {
      const query = await this.vectorStore.query({
        vector: await this.vectorStore.createEmbedding(`research directions for ${opportunity}`),
        filter: {
          type: { $eq: "research" }
        },
        topK: 1
      });
      if (query.matches.length > 0) {
        directions.push(query.matches[0].metadata.direction);
      }
    }
    return directions;
  }
  calculatePerformanceScore(metrics) {
    return metrics.agentActivity.taskCompletionRate * 0.3 + metrics.aiServices.accuracyScore * 0.3 + metrics.dataMetrics.predictionAccuracy * 0.2 + (1 - metrics.computationalResources.processingLatency / 1000) * 0.2;
  }
  calculateSafetyScore(metrics) {
    return metrics.securityScore * 0.25 + (1 - metrics.biasRating) * 0.25 + metrics.ethicsCompliance * 0.25 + metrics.privacyProtection * 0.25;
  }
  calculateInnovationScore(metrics) {
    return metrics.aiServices.innovationRate * 0.4 + metrics.aiServices.adaptabilityIndex * 0.3 + metrics.dataMetrics.insightGeneration * 0.3;
  }
  initializeMetrics() {
    return {
      sustainability: {
        carbonEmissions: 10,
        renewableEnergyRatio: 0.3,
        greenSpaceIndex: 0.4,
        airQualityIndex: 150,
        waterQualityScore: 0.8,
        biodiversityIndex: 0.6
      },
      economy: {
        employmentRate: 0.92,
        giniCoefficient: 0.35,
        businessFormationRate: 5.2,
        innovationIndex: 0.7,
        housingAffordability: 0.6
      },
      social: {
        healthcareAccessScore: 0.75,
        educationQualityIndex: 0.8,
        culturalEngagement: 3.5,
        civicParticipation: 0.65,
        communityWellbeing: 0.7
      },
      infrastructure: {
        trafficCongestion: 0.4,
        publicTransitReliability: 0.85,
        wasteRecyclingRate: 0.6,
        infrastructureHealth: 0.75,
        smartGridEfficiency: 0.8
      },
      safety: {
        crimeRate: 2.1,
        emergencyResponseTime: 8.5,
        publicTrustIndex: 0.7,
        disasterReadiness: 0.8
      },
      ai: {
        agentActivity: {
          activeAgents: 0,
          averageResponseTime: 0,
          interactionQuality: 0,
          taskCompletionRate: 0,
          learningProgress: 0
        },
        computationalResources: {
          cpuUtilization: 0,
          memoryUsage: 0,
          networkBandwidth: 0,
          storageCapacity: 0,
          processingLatency: 0
        },
        aiServices: {
          availabilityRate: 0,
          accuracyScore: 0,
          adaptabilityIndex: 0,
          innovationRate: 0,
          userSatisfaction: 0
        },
        dataMetrics: {
          dataQuality: 0,
          dataProcessingRate: 0,
          insightGeneration: 0,
          predictionAccuracy: 0,
          anomalyDetection: 0
        },
        aiSafety: {
          securityScore: 0,
          biasRating: 0,
          ethicsCompliance: 0,
          privacyProtection: 0,
          systemReliability: 0
        }
      }
    };
  }
  analyzeTrends() {
    const recentMetrics = this.metricsHistory.slice(-5);
    const trends = {
      improving: [],
      declining: [],
      stable: []
    };
    Object.entries(this.currentMetrics).forEach(([category, metrics]) => {
      Object.entries(metrics).forEach(([metric, currentValue]) => {
        const trend = this.calculateMetricTrend(category, metric, recentMetrics);
        trends[trend].push(`${category}.${metric}`);
      });
    });
    return trends;
  }
  calculateMetricTrend(category, metric, history) {
    const values = history.map((h) => h.metrics[category][metric]);
    const change = this.calculateTrendChange(values);
    if (Math.abs(change) < 0.05)
      return "stable";
    return change > 0 ? "improving" : "declining";
  }
  calculateTrendChange(values) {
    if (values.length < 2)
      return 0;
    const first = values[0];
    const last = values[values.length - 1];
    return (last - first) / first;
  }
  async generateRecommendations() {
    const trends = this.analyzeTrends();
    const recommendations = [];
    for (const metric of trends.declining) {
      const [category, name] = metric.split(".");
      const recommendation = await this.getRecommendationForMetric(category, name, this.currentMetrics[category][name]);
      recommendations.push(recommendation);
    }
    return recommendations;
  }
  async getRecommendationForMetric(category, metric, value2) {
    const query = await this.vectorStore.query({
      vector: await this.vectorStore.createEmbedding(`${category} ${metric} improvement strategies`),
      filter: {
        type: { $eq: "recommendation" }
      },
      topK: 1
    });
    if (query.matches.length > 0) {
      return query.matches[0].metadata.recommendation;
    }
    return `Consider reviewing and optimizing ${category} policies related to ${metric}`;
  }
  async getCurrentMetrics(districtId) {
    try {
      const results = await this.vectorStore.query({
        vector: await this.vectorStore.createEmbedding(`district ${districtId} current metrics`),
        filter: {
          type: { $eq: "district" },
          districtId: { $eq: districtId }
        },
        topK: 1
      });
      if (results.matches?.length > 0) {
        return JSON.parse(results.matches[0].metadata.metrics);
      }
      return {
        weather: {
          temperature: 22,
          feelsLike: 23,
          humidity: 65,
          precipitation: 0,
          windSpeed: 12,
          windDirection: "NE"
        },
        environmental: {
          airQuality: 85
        },
        emergency: {
          level: "normal",
          activeIncidents: 2,
          responseTeamsAvailable: 8
        },
        vitals: {
          populationCount: 15234,
          activeEntities: 12453,
          visitorCount: 892,
          peakHoursStatus: "Optimal"
        },
        community: {
          activeEvents: 12,
          ongoingMeetings: 5,
          collaborationSessions: 8,
          chatActivity: "High"
        },
        safety: {
          overallScore: 95,
          recentIncidents: 3,
          responseTime: "2.5 min",
          serviceAvailability: 98
        },
        resources: {
          energyConsumption: 72,
          waterUsage: 65,
          wasteManagement: 88,
          efficiency: 91
        },
        transport: {
          trafficDensity: 45,
          publicTransportLoad: 68,
          parkingAvailable: 342,
          avgTransitTime: 15
        },
        economic: {
          businessActivity: 82,
          growthRate: 4.2,
          activeTransactions: 1243,
          marketSentiment: "Positive"
        },
        cultural: {
          eventAttendance: 89,
          culturalSiteVisits: 1205,
          communityEngagement: 86,
          socialCohesion: 92
        },
        infrastructure: {
          maintenanceRequests: 23,
          serviceUptime: 99.9,
          healthScore: 94,
          developmentProgress: 78
        },
        budget: {
          currentStatus: 8500000,
          monthlySpending: 750000,
          efficiency: 92,
          allocation: {
            infrastructure: 35,
            services: 25,
            development: 20,
            emergency: 20
          }
        },
        departments: {
          responseTimes: 95,
          serviceQuality: 89,
          resourceUtilization: 86,
          efficiency: 91
        },
        donations: {
          activeCampaigns: 5,
          totalDonations: 2500000,
          goalProgress: 75,
          impactScore: 89
        }
      };
    } catch (error4) {
      console.error("Error getting current metrics:", error4);
      throw error4;
    }
  }
}

// src/services/department.service.ts
import { EventEmitter as EventEmitter10 } from "events";

class DepartmentService extends EventEmitter10 {
  vectorStore;
  togetherService;
  analyticsService;
  metricsService;
  departments = new Map;
  departmentAgents = new Map;
  healthUpdateInterval;
  constructor(vectorStore, togetherService, analyticsService, metricsService) {
    super();
    this.vectorStore = vectorStore;
    this.togetherService = togetherService;
    this.analyticsService = analyticsService;
    this.metricsService = metricsService;
    this.initializeHealthMonitoring();
    this.initializePerformanceMonitoring();
  }
  initializeHealthMonitoring() {
    this.healthUpdateInterval = setInterval(() => {
      this.updateAgentHealth();
    }, 30 * 60 * 1000);
    this.analyticsService.trackEvent("department_health_monitoring_initialized", {
      timestamp: Date.now(),
      updateInterval: "30m"
    });
  }
  async updateAgentHealth() {
    for (const [deptId, agents2] of this.departmentAgents) {
      const department = this.departments.get(deptId);
      if (!department)
        continue;
      const budgetHealth = department.budget.total > 0 ? (department.budget.total - department.budget.spent) / department.budget.total : 0;
      let updatedAgentsCount = 0;
      let stressedAgentsCount = 0;
      for (const agent of agents2) {
        const previousStatus = agent.health.status;
        agent.health.energy = Math.max(0, agent.health.energy - 0.1);
        agent.health.motivation = Math.max(0, agent.health.motivation - 0.05);
        agent.mood.enthusiasm = Math.max(0, agent.mood.enthusiasm - 0.08);
        if (budgetHealth < 0.2) {
          agent.health.physical = Math.max(0, agent.health.physical - 0.15);
          agent.health.mental = Math.max(0, agent.health.mental - 0.2);
          agent.mood.stress = Math.min(1, agent.mood.stress + 0.2);
          agent.health.status = "stressed";
          stressedAgentsCount++;
        }
        this.updateAgentStatus(agent);
        const timeSinceLastDonation = Date.now() - agent.donationImpact.lastDonationEffect;
        if (timeSinceLastDonation < 24 * 60 * 60 * 1000) {
          this.applyDonationRecovery(agent);
        }
        if (previousStatus !== agent.health.status) {
          this.analyticsService.trackEvent("agent_status_changed", {
            departmentId: deptId,
            agentId: agent.id,
            previousStatus,
            newStatus: agent.health.status,
            timestamp: Date.now()
          });
        }
        updatedAgentsCount++;
      }
      this.departmentAgents.set(deptId, agents2);
      this.emit("agentsHealthUpdated", { departmentId: deptId, agents: agents2 });
      this.analyticsService.trackEvent("department_health_updated", {
        departmentId: deptId,
        totalAgents: agents2.length,
        updatedAgents: updatedAgentsCount,
        stressedAgents: stressedAgentsCount,
        budgetHealth,
        timestamp: Date.now()
      });
    }
  }
  updateAgentStatus(agent) {
    const { physical, mental, energy, motivation } = agent.health;
    const averageHealth = (physical + mental + energy + motivation) / 4;
    if (averageHealth < 0.2) {
      agent.health.status = "sick";
    } else if (averageHealth < 0.4) {
      agent.health.status = "stressed";
    } else if (averageHealth < 0.6) {
      agent.health.status = "tired";
    } else if (agent.health.status === "sick" || agent.health.status === "stressed") {
      agent.health.status = "recovering";
    } else {
      agent.health.status = "healthy";
    }
  }
  applyDonationRecovery(agent) {
    const recoveryAmount = agent.donationImpact.recoveryRate * 0.1;
    const motivationBoost = agent.donationImpact.motivationBoost * 0.15;
    agent.health.physical = Math.min(1, agent.health.physical + recoveryAmount);
    agent.health.mental = Math.min(1, agent.health.mental + recoveryAmount);
    agent.health.energy = Math.min(1, agent.health.energy + recoveryAmount);
    agent.health.motivation = Math.min(1, agent.health.motivation + motivationBoost);
    agent.mood.happiness = Math.min(1, agent.mood.happiness + 0.2);
    agent.mood.satisfaction = Math.min(1, agent.mood.satisfaction + 0.15);
    agent.mood.enthusiasm = Math.min(1, agent.mood.enthusiasm + 0.25);
    agent.mood.stress = Math.max(0, agent.mood.stress - 0.2);
  }
  async getAllDepartments() {
    return Array.from(this.departments.values());
  }
  async createDepartment(department) {
    this.departments.set(department.id, department);
    await this.vectorStore.upsert({
      id: `department-${department.id}`,
      values: await this.vectorStore.createEmbedding(`${department.name} ${department.description} ${department.type}`),
      metadata: {
        type: "district",
        departmentId: department.id,
        departmentType: department.type
      }
    });
    this.analyticsService.trackEvent("department_created", {
      departmentId: department.id,
      type: department.type,
      timestamp: Date.now()
    });
    return department;
  }
  async assignAgent(departmentId, agentId) {
    const department = this.departments.get(departmentId);
    if (!department)
      throw new Error("Department not found");
    department.assignedAgents.push(agentId);
    const newAgent = {
      id: agentId,
      departmentId,
      name: `Agent ${agentId.slice(0, 6)}`,
      role: "field_agent",
      schedule: {
        availability: true,
        shifts: []
      },
      performance: {
        responseTime: 0.8,
        resolutionRate: 0.7,
        efficiency: 0.75,
        citizenSatisfaction: 0.8
      },
      health: {
        physical: 1,
        mental: 1,
        energy: 1,
        motivation: 1,
        status: "healthy"
      },
      mood: {
        happiness: 0.8,
        satisfaction: 0.8,
        enthusiasm: 0.9,
        stress: 0.2,
        lastUpdate: Date.now()
      },
      donationImpact: {
        recoveryRate: 0,
        motivationBoost: 0,
        lastDonationEffect: 0
      }
    };
    const agents2 = this.departmentAgents.get(departmentId) || [];
    agents2.push(newAgent);
    this.departmentAgents.set(departmentId, agents2);
    await this.vectorStore.upsert({
      id: `department-agent-${departmentId}-${agentId}`,
      values: await this.vectorStore.createEmbedding(`Agent ${agentId} works in ${department.name} department`),
      metadata: {
        type: "district",
        departmentId,
        agentId,
        timestamp: Date.now()
      }
    });
    this.analyticsService.trackEvent("agent_assigned", {
      departmentId,
      agentId,
      role: newAgent.role,
      timestamp: Date.now()
    });
    this.emit("agentAssigned", { departmentId, agent: newAgent });
  }
  async createDepartmentChat(departmentId, topic, participants) {
    const department = this.departments.get(departmentId);
    if (!department)
      throw new Error("Department not found");
    const chatId = crypto.randomUUID();
    department.activeChats.push(chatId);
    await this.vectorStore.upsert({
      id: `department-chat-${chatId}`,
      values: await this.vectorStore.createEmbedding(`Department chat about ${topic} in ${department.name}`),
      metadata: {
        type: "conversation",
        departmentId,
        chatId,
        topic,
        participants,
        timestamp: Date.now()
      }
    });
    return chatId;
  }
  async getDepartmentBudget(departmentId) {
    const department = this.departments.get(departmentId);
    if (!department)
      throw new Error("Department not found");
    return department.budget;
  }
  async addDonation(departmentId, donation) {
    const department = this.departments.get(departmentId);
    if (!department)
      throw new Error("Department not found");
    department.budget.donations += donation.amount;
    department.budget.total += donation.amount;
    department.budget.donations_history.push(donation);
    const agents2 = this.departmentAgents.get(departmentId) || [];
    for (const agent of agents2) {
      agent.donationImpact = {
        recoveryRate: Math.min(1, donation.amount / department.budget.total * 2),
        motivationBoost: Math.min(1, donation.amount / department.budget.total * 3),
        lastDonationEffect: Date.now()
      };
      agent.mood.happiness = Math.min(1, agent.mood.happiness + 0.3);
      agent.mood.satisfaction = Math.min(1, agent.mood.satisfaction + 0.25);
      agent.mood.enthusiasm = Math.min(1, agent.mood.enthusiasm + 0.35);
      agent.mood.stress = Math.max(0, agent.mood.stress - 0.3);
      agent.mood.lastUpdate = Date.now();
      if (agent.health.status === "sick" || agent.health.status === "stressed") {
        agent.health.status = "recovering";
      }
    }
    this.departmentAgents.set(departmentId, agents2);
    await this.vectorStore.upsert({
      id: `department-donation-${donation.id}`,
      values: await this.vectorStore.createEmbedding(`Donation of ${donation.amount} to ${department.name} department`),
      metadata: {
        type: "district",
        departmentId,
        donationId: donation.id,
        amount: donation.amount,
        timestamp: donation.timestamp
      }
    });
    this.emit("donationReceived", {
      departmentId,
      donation,
      agentImpact: agents2.length
    });
  }
  async addExpense(departmentId, expense) {
    const department = this.departments.get(departmentId);
    if (!department)
      throw new Error("Department not found");
    if (expense.amount > department.budget.total - department.budget.spent) {
      throw new Error("Insufficient budget");
    }
    department.budget.spent += expense.amount;
    department.budget.expenses.push(expense);
    await this.vectorStore.upsert({
      id: `department-expense-${expense.id}`,
      values: await this.vectorStore.createEmbedding(`Expense of ${expense.amount} for ${expense.description} in ${department.name} department`),
      metadata: {
        type: "district",
        departmentId,
        expenseId: expense.id,
        amount: expense.amount,
        category: expense.category,
        timestamp: expense.timestamp
      }
    });
    this.emit("expenseAdded", { departmentId, expense });
  }
  async addActivity(departmentId, activity) {
    const department = this.departments.get(departmentId);
    if (!department)
      throw new Error("Department not found");
    await this.vectorStore.upsert({
      id: `department-activity-${departmentId}-${activity.timestamp}`,
      values: await this.vectorStore.createEmbedding(`Department ${department.name} activity: ${activity.type}`),
      metadata: {
        type: "district",
        departmentId,
        activityType: activity.type,
        timestamp: activity.timestamp,
        details: JSON.stringify(activity)
      }
    });
    if (activity.type === "emergency_response") {
      department.metrics.responseTime = Math.min(1, department.metrics.responseTime * 1.1);
    } else if (activity.type === "successful_operation") {
      department.metrics.successRate = Math.min(1, department.metrics.successRate * 1.05);
    } else if (activity.type === "collaboration") {
      department.metrics.collaborationScore = Math.min(1, department.metrics.collaborationScore * 1.05);
    } else if (activity.type === "training") {
      const agents2 = await this.getDepartmentAgents(departmentId);
      for (const agent of agents2) {
        agent.health.motivation = Math.min(1, agent.health.motivation + 0.1);
        agent.health.energy = Math.min(1, agent.health.energy + 0.05);
        agent.mood.enthusiasm = Math.min(1, agent.mood.enthusiasm + 0.1);
      }
      this.departmentAgents.set(departmentId, agents2);
    }
    this.departments.set(departmentId, department);
    this.emit("activityAdded", { departmentId, activity });
  }
  async getDepartmentAgents(departmentId) {
    return this.departmentAgents.get(departmentId) || [];
  }
  async healAgent(departmentId, agentId, treatment) {
    const agents2 = await this.getDepartmentAgents(departmentId);
    const agent = agents2.find((a) => a.id === agentId);
    if (!agent)
      throw new Error("Agent not found");
    const department = this.departments.get(departmentId);
    if (!department)
      throw new Error("Department not found");
    const initialHealth = { ...agent.health };
    const initialMood = { ...agent.mood };
    if (department.budget.total - department.budget.spent < treatment.cost) {
      this.analyticsService.trackEvent("treatment_failed", {
        departmentId,
        agentId,
        reason: "insufficient_budget",
        treatment: treatment.treatment,
        cost: treatment.cost,
        availableBudget: department.budget.total - department.budget.spent,
        timestamp: Date.now()
      });
      throw new Error("Insufficient department budget for treatment");
    }
    await this.addExpense(departmentId, {
      id: crypto.randomUUID(),
      amount: treatment.cost,
      category: "personnel",
      description: `Medical treatment for agent ${agent.name}: ${treatment.treatment}`,
      timestamp: Date.now(),
      approvedBy: "system"
    });
    const healingPower = treatment.cost / 1000;
    agent.health.physical = Math.min(1, agent.health.physical + healingPower * 0.3);
    agent.health.mental = Math.min(1, agent.health.mental + healingPower * 0.3);
    agent.health.energy = Math.min(1, agent.health.energy + healingPower * 0.2);
    agent.health.motivation = Math.min(1, agent.health.motivation + healingPower * 0.2);
    agent.mood.stress = Math.max(0, agent.mood.stress - healingPower * 0.4);
    agent.mood.happiness = Math.min(1, agent.mood.happiness + healingPower * 0.2);
    agent.mood.satisfaction = Math.min(1, agent.mood.satisfaction + healingPower * 0.2);
    agent.mood.lastUpdate = Date.now();
    if (healingPower > 0.5) {
      agent.health.status = "recovering";
    }
    this.analyticsService.trackEvent("treatment_applied", {
      departmentId,
      agentId,
      treatment: treatment.treatment,
      cost: treatment.cost,
      healthImprovement: {
        physical: agent.health.physical - initialHealth.physical,
        mental: agent.health.mental - initialHealth.mental,
        energy: agent.health.energy - initialHealth.energy,
        motivation: agent.health.motivation - initialHealth.motivation
      },
      moodImprovement: {
        stress: initialMood.stress - agent.mood.stress,
        happiness: agent.mood.happiness - initialMood.happiness,
        satisfaction: agent.mood.satisfaction - initialMood.satisfaction
      },
      timestamp: Date.now()
    });
    await this.vectorStore.upsert({
      id: `agent-healing-${agentId}-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(`Agent ${agent.name} received treatment: ${treatment.treatment}`),
      metadata: {
        type: "district",
        departmentId,
        agentId,
        treatment: treatment.treatment,
        cost: treatment.cost,
        timestamp: Date.now()
      }
    });
    this.emit("agentHealed", { departmentId, agent, treatment });
    return agent;
  }
  async updateDepartmentMetrics(departmentId) {
    const department = this.departments.get(departmentId);
    if (!department)
      return;
    const agents2 = await this.getDepartmentAgents(departmentId);
    const avgHealth = agents2.reduce((sum, agent) => {
      const health = (agent.health.physical + agent.health.mental + agent.health.energy + agent.health.motivation) / 4;
      return sum + health;
    }, 0) / agents2.length;
    const avgMood = agents2.reduce((sum, agent) => {
      const mood = (agent.mood.happiness + agent.mood.satisfaction + agent.mood.enthusiasm - agent.mood.stress) / 4;
      return sum + mood;
    }, 0) / agents2.length;
    await this.metricsService.updateMetrics({
      social: {
        healthcareAccessScore: avgHealth,
        educationQualityIndex: 0.8,
        culturalEngagement: 3.5,
        civicParticipation: 0.65,
        communityWellbeing: avgMood
      },
      infrastructure: {
        trafficCongestion: 0.4,
        publicTransitReliability: 0.85,
        wasteRecyclingRate: 0.6,
        infrastructureHealth: department.metrics.efficiency,
        smartGridEfficiency: 0.8
      },
      safety: {
        crimeRate: 2.1,
        emergencyResponseTime: department.metrics.responseTime,
        publicTrustIndex: department.metrics.collaborationScore,
        disasterReadiness: 0.8
      }
    });
  }
  initializePerformanceMonitoring() {
    setInterval(async () => {
      for (const [departmentId, department] of this.departments) {
        const agents2 = await this.getDepartmentAgents(departmentId);
        department.metrics.responseTime = agents2.reduce((sum, agent) => sum + agent.performance.responseTime, 0) / agents2.length;
        department.metrics.successRate = agents2.reduce((sum, agent) => sum + agent.performance.resolutionRate, 0) / agents2.length;
        department.metrics.collaborationScore = agents2.reduce((sum, agent) => sum + agent.performance.citizenSatisfaction, 0) / agents2.length;
        department.metrics.efficiency = agents2.reduce((sum, agent) => sum + agent.performance.efficiency, 0) / agents2.length;
        await this.updateDepartmentMetrics(departmentId);
      }
    }, 60 * 60 * 1000);
  }
  async getDepartment(id) {
    return this.departments.get(id);
  }
}

// src/services/citizen.service.ts
import { EventEmitter as EventEmitter11 } from "events";

class CitizenService extends EventEmitter11 {
  vectorStore;
  togetherService;
  departmentService;
  analyticsService;
  citizens = new Map;
  constructor(vectorStore, togetherService, departmentService, analyticsService) {
    super();
    this.vectorStore = vectorStore;
    this.togetherService = togetherService;
    this.departmentService = departmentService;
    this.analyticsService = analyticsService;
    this.initializeService();
  }
  initializeService() {
    this.on("newCitizenNeed", ({ citizenId, need }) => {
      this.analyticsService.trackInteraction({ id: citizenId, type: "citizen" }, {
        type: "need",
        content: need.description,
        sentiment: 1 - need.urgency,
        topics: [need.type, "need", "citizen"]
      });
    });
    this.on("citizenActivityUpdated", ({ citizenId, activity }) => {
      this.analyticsService.trackInteraction({ id: citizenId, type: "citizen" }, {
        type: "activity",
        content: `Citizen engaged in ${activity.type}`,
        sentiment: 0.5 + activity.intensity * 0.5,
        topics: ["activity", activity.type, "citizen"]
      });
    });
  }
  async simulateCitizenNeeds() {
    for (const citizen of this.citizens.values()) {
      if (Math.random() < 0.3) {
        const need = await this.generateRandomNeed(citizen);
        citizen.needs.push(need);
        await this.routeNeedToDepartment(citizen.id, need);
        this.analyticsService.trackMood(this.calculateCitizenMood(citizen));
      }
    }
  }
  calculateCitizenMood(citizen) {
    if (!citizen.needs.length)
      return 0.8;
    const urgentNeeds = citizen.needs.filter((n) => n.urgency > 0.7 && n.status === "pending");
    const resolvedNeeds = citizen.needs.filter((n) => n.status === "resolved");
    const moodScore = 0.8 - urgentNeeds.length * 0.2 + resolvedNeeds.length * 0.1;
    return Math.max(0, Math.min(1, moodScore));
  }
  async generateRandomNeed(citizen) {
    const needTypes = [
      "infrastructure",
      "service",
      "safety",
      "environmental",
      "social"
    ];
    const type3 = needTypes[Math.floor(Math.random() * needTypes.length)];
    const prompt = `Generate a realistic city-related need for a citizen who works as ${citizen.occupation} in the ${citizen.district} district.`;
    const description = await this.togetherService.generateText(prompt);
    return {
      type: type3,
      description,
      urgency: Math.random(),
      status: "pending",
      created: Date.now()
    };
  }
  async routeNeedToDepartment(citizenId, need) {
    await this.vectorStore.upsert({
      id: `citizen-need-${citizenId}-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(need.description),
      metadata: {
        type: "district",
        citizenId,
        needType: need.type,
        urgency: need.urgency,
        timestamp: need.created
      }
    });
    this.emit("newCitizenNeed", { citizenId, need });
  }
  async updateActivityLevels(type3, intensity) {
    for (const citizen of this.citizens.values()) {
      citizen.currentActivity = {
        type: type3,
        intensity,
        timestamp: Date.now()
      };
      this.emit("citizenActivityUpdated", {
        citizenId: citizen.id,
        activity: citizen.currentActivity
      });
    }
  }
  async getCitizenAnalytics(citizenId) {
    const citizen = this.citizens.get(citizenId);
    if (!citizen)
      throw new Error("Citizen not found");
    return {
      needsAnalysis: {
        total: citizen.needs.length,
        pending: citizen.needs.filter((n) => n.status === "pending").length,
        resolved: citizen.needs.filter((n) => n.status === "resolved").length,
        urgentCount: citizen.needs.filter((n) => n.urgency > 0.7).length,
        byType: this.groupNeedsByType(citizen.needs)
      },
      activityAnalysis: {
        currentActivity: citizen.currentActivity,
        mood: this.calculateCitizenMood(citizen),
        engagementLevel: this.calculateEngagementLevel(citizen)
      },
      districtInteraction: {
        district: citizen.district,
        participation: await this.getDistrictParticipation(citizen)
      }
    };
  }
  groupNeedsByType(needs) {
    return needs.reduce((acc, need) => {
      acc[need.type] = (acc[need.type] || 0) + 1;
      return acc;
    }, {});
  }
  calculateEngagementLevel(citizen) {
    if (!citizen.currentActivity)
      return 0;
    const recencyScore = Math.max(0, 1 - (Date.now() - citizen.currentActivity.timestamp) / (24 * 60 * 60 * 1000));
    return citizen.currentActivity.intensity * 0.7 + recencyScore * 0.3;
  }
  async getDistrictParticipation(citizen) {
    const recentNeeds = citizen.needs.filter((n) => Date.now() - n.created < 30 * 24 * 60 * 60 * 1000);
    return recentNeeds.length > 0 ? 0.5 + recentNeeds.length * 0.1 : 0.5;
  }
}

// src/services/department-agent.service.ts
import { EventEmitter as EventEmitter12 } from "events";

class DepartmentAgentService extends EventEmitter12 {
  togetherService;
  analyticsService;
  departmentService;
  metricsService;
  agents = new Map;
  constructor(togetherService, analyticsService, departmentService, metricsService) {
    super();
    this.togetherService = togetherService;
    this.analyticsService = analyticsService;
    this.departmentService = departmentService;
    this.metricsService = metricsService;
    this.setupEventListeners();
  }
  setupEventListeners() {
    this.departmentService.on("agentAssigned", ({
      departmentId,
      agent
    }) => {
      this.agents.set(agent.id, agent);
      this.analyticsService.trackEvent("agent_registered", {
        agentId: agent.id,
        departmentId,
        timestamp: Date.now()
      });
    });
    this.departmentService.on("agentsHealthUpdated", ({
      departmentId,
      agents: agents2
    }) => {
      agents2.forEach((agent) => {
        if (this.agents.has(agent.id)) {
          this.agents.set(agent.id, agent);
        }
      });
    });
  }
  async handleCitizenNeed(need) {
    const availableAgents = Array.from(this.agents.values()).filter((agent2) => agent2.schedule.availability && !agent2.currentTask);
    if (availableAgents.length === 0) {
      this.analyticsService.trackEvent("no_available_agents", {
        needType: need.type,
        urgency: need.urgency,
        timestamp: Date.now()
      });
      return;
    }
    const agent = this.selectBestAgent(availableAgents, need);
    await this.assignTask(agent.id, {
      type: "citizen_request",
      description: need.description,
      priority: need.urgency > 0.7 ? "high" : need.urgency > 0.3 ? "medium" : "low"
    });
    await this.metricsService.updateMetrics({
      social: {
        healthcareAccessScore: agent.performance.efficiency,
        educationQualityIndex: 0.8,
        culturalEngagement: 3.5,
        civicParticipation: availableAgents.length / this.agents.size,
        communityWellbeing: agent.performance.citizenSatisfaction
      }
    });
  }
  selectBestAgent(agents2, need) {
    const selectedAgent = agents2.reduce((best, current) => {
      const score = current.performance.responseTime * 0.4 + current.performance.resolutionRate * 0.4 + current.performance.efficiency * 0.2;
      const bestScore = best.performance.responseTime * 0.4 + best.performance.resolutionRate * 0.4 + best.performance.efficiency * 0.2;
      return score > bestScore ? current : best;
    });
    this.analyticsService.trackEvent("agent_selected", {
      agentId: selectedAgent.id,
      needType: need.type,
      urgency: need.urgency,
      score: selectedAgent.performance.efficiency,
      timestamp: Date.now()
    });
    return selectedAgent;
  }
  async assignTask(agentId, task) {
    const agent = this.agents.get(agentId);
    if (!agent)
      return;
    agent.currentTask = task;
    this.agents.set(agentId, agent);
    this.analyticsService.trackEvent("task_assigned", {
      agentId,
      taskType: task.type,
      priority: task.priority,
      timestamp: Date.now()
    });
    this.emit("taskAssigned", { agentId, task });
  }
  async getAgentTasks(departmentId) {
    const agents2 = await this.departmentService.getDepartmentAgents(departmentId);
    return agents2.filter((agent) => agent.currentTask !== null && agent.currentTask !== undefined).map((agent) => ({
      agentId: agent.id,
      task: agent.currentTask
    }));
  }
}

// src/services/development.service.ts
import { EventEmitter as EventEmitter13 } from "events";

class DevelopmentService extends EventEmitter13 {
  vectorStore;
  districtService;
  smartInfrastructure;
  environmentService;
  projects = new Map;
  zoningPlans = new Map;
  urbanFabrics = new Map;
  districtVitals = new Map;
  environmentalMetrics = new Map;
  agentActivities = new Map;
  cityConsciousness = {
    awarenessLevels: {
      environmental: 0.5,
      social: 0.5,
      cultural: 0.5,
      technological: 0.5
    },
    collectiveMemory: {
      shortTerm: new Map,
      longTerm: new Map,
      cultural: new Map,
      evolutionary: new Map
    },
    decisionMaking: {
      autonomy: 0.5,
      consensus: 0.5,
      adaptation: 0.5,
      prediction: 0.5
    }
  };
  cityChronicles = new Map;
  constructor(vectorStore, districtService, smartInfrastructure, environmentService) {
    super();
    this.vectorStore = vectorStore;
    this.districtService = districtService;
    this.smartInfrastructure = smartInfrastructure;
    this.environmentService = environmentService;
    this.initializeAIPlanning();
  }
  async initializeAIPlanning() {
    setInterval(() => this.analyzeGrowthPatterns(), 1000 * 60 * 60 * 24);
    setInterval(() => this.optimizeProjects(), 1000 * 60 * 60);
    setInterval(() => this.updateUrbanFabric(), 1000 * 60 * 60 * 12);
    setInterval(() => this.monitorDistrictVitals(), 1000 * 60 * 5);
    setInterval(() => this.trackEnvironmentalMetrics(), 1000 * 60 * 15);
    setInterval(() => this.analyzeAgentActivities(), 1000 * 60 * 10);
    setInterval(() => this.evolveConsciousness(), 1000 * 60 * 30);
    setInterval(() => this.updateCollectiveMemory(), 1000 * 60 * 60);
    setInterval(() => this.processConsciousnessEvents(), 1000 * 60 * 15);
    setInterval(() => this.updateChronicles(), 1000 * 60 * 30);
  }
  async monitorDistrictVitals() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const extendedDistrict = district;
      const vitals = {
        aiPopulationDensity: await this.calculateAIPopulationDensity(extendedDistrict),
        computationalLoad: await this.measureComputationalLoad(extendedDistrict),
        networkUtilization: await this.assessNetworkUtilization(extendedDistrict),
        eventFrequency: await this.trackEventFrequency(extendedDistrict),
        communityEngagement: await this.measureCommunityEngagement(extendedDistrict)
      };
      this.districtVitals.set(district.id, vitals);
      this.emit("districtVitalsUpdated", { districtId: district.id, vitals });
    }
  }
  async trackEnvironmentalMetrics() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const extendedDistrict = district;
      const metrics = {
        carbonEmissions: await this.measureCarbonEmissions(extendedDistrict),
        energyEfficiency: await this.calculateEnergyEfficiency(extendedDistrict),
        wasteManagement: await this.assessWasteManagement(extendedDistrict),
        resourceUtilization: await this.trackResourceUtilization(extendedDistrict),
        sustainabilityScore: await this.computeSustainabilityScore(extendedDistrict)
      };
      this.environmentalMetrics.set(district.id, metrics);
      this.emit("environmentalMetricsUpdated", {
        districtId: district.id,
        metrics
      });
    }
  }
  async analyzeAgentActivities() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const extendedDistrict = district;
      const activities = {
        interactionFrequency: await this.measureInteractionFrequency(extendedDistrict),
        collaborationScore: await this.assessCollaboration(extendedDistrict),
        knowledgeSharing: await this.trackKnowledgeSharing(extendedDistrict),
        innovationRate: await this.calculateInnovationRate(extendedDistrict),
        adaptabilityScore: await this.measureAdaptability(extendedDistrict)
      };
      this.agentActivities.set(district.id, activities);
      this.emit("agentActivitiesUpdated", {
        districtId: district.id,
        activities
      });
    }
  }
  async calculateAIPopulationDensity(district) {
    const activeAgents = district.agents?.filter((a) => a.status === "active") || [];
    const computationalCapacity = district.infrastructure?.computationalCapacity || 1;
    return activeAgents.length / computationalCapacity * 0.7 + activeAgents.reduce((sum, a) => sum + (a.complexity || 0), 0) / computationalCapacity * 0.3;
  }
  async measureComputationalLoad(district) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(district.id);
    const systems = infrastructure.systems.filter((s) => s.type === "digital" || s.type === "power");
    return systems.reduce((sum, s) => sum + s.metrics.utilization, 0) / Math.max(systems.length, 1);
  }
  async assessNetworkUtilization(district) {
    const metrics = await this.calculateInfrastructureMetrics(district.id);
    return metrics.digitalScore;
  }
  async trackEventFrequency(district) {
    const events = district.events || [];
    const recentEvents = events.filter((e) => Date.now() - e.timestamp < 24 * 60 * 60 * 1000);
    return recentEvents.length / 24;
  }
  async measureCommunityEngagement(district) {
    const activeAgents = district.agents?.filter((a) => a.status === "active") || [];
    return activeAgents.reduce((sum, a) => sum + (a.interactions?.length || 0), 0) / Math.max(activeAgents.length * 24, 1);
  }
  async measureCarbonEmissions(district) {
    const powerSystems = district.infrastructure?.systems?.filter((s) => s.type === "power") || [];
    return powerSystems.reduce((sum, s) => sum + s.emissions, 0) / Math.max(powerSystems.length, 1);
  }
  async calculateEnergyEfficiency(district) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(district.id);
    const powerSystems = infrastructure.systems.filter((s) => s.type === "power");
    return powerSystems.reduce((sum, s) => sum + s.metrics.efficiency, 0) / Math.max(powerSystems.length, 1);
  }
  async assessWasteManagement(district) {
    const wasteSystems = district.infrastructure?.systems?.filter((s) => s.type === "waste") || [];
    return wasteSystems.reduce((sum, s) => sum + s.processingEfficiency, 0) / Math.max(wasteSystems.length, 1);
  }
  async trackResourceUtilization(district) {
    const systems = district.infrastructure?.systems || [];
    return systems.reduce((sum, s) => sum + s.resourceEfficiency, 0) / Math.max(systems.length, 1);
  }
  async computeSustainabilityScore(district) {
    const emissions = await this.measureCarbonEmissions(district);
    const efficiency = await this.calculateEnergyEfficiency(district);
    const waste = await this.assessWasteManagement(district);
    const resources = await this.trackResourceUtilization(district);
    return (1 - emissions) * 0.3 + efficiency * 0.3 + waste * 0.2 + resources * 0.2;
  }
  async measureInteractionFrequency(district) {
    const agents2 = district.agents || [];
    const interactions = agents2.reduce((sum, a) => sum + (a.interactions?.length || 0), 0);
    return interactions / Math.max(agents2.length * 24, 1);
  }
  async assessCollaboration(district) {
    const agents2 = district.agents || [];
    const collaborations = agents2.reduce((sum, a) => sum + (a.collaborations?.length || 0), 0);
    return collaborations / Math.max(agents2.length * 24, 1);
  }
  async trackKnowledgeSharing(district) {
    const agents2 = district.agents || [];
    const knowledgeTransfers = agents2.reduce((sum, a) => sum + (a.knowledgeTransfers?.length || 0), 0);
    return knowledgeTransfers / Math.max(agents2.length * 24, 1);
  }
  async calculateInnovationRate(district) {
    const agents2 = district.agents || [];
    const innovations = agents2.reduce((sum, a) => sum + (a.innovations?.length || 0), 0);
    return innovations / Math.max(agents2.length * 24, 1);
  }
  async measureAdaptability(district) {
    const agents2 = district.agents || [];
    return agents2.reduce((sum, a) => sum + (a.adaptabilityScore || 0), 0) / Math.max(agents2.length, 1);
  }
  async planCityGrowth() {
    const growthAnalysis = await this.analyzeGrowthPatterns();
    const sustainabilityGoals = await this.calculateSustainabilityTargets();
    const developmentNeeds = await this.identifyDevelopmentNeeds();
    const culturalContext = await this.analyzeCulturalContext();
    const proposedProjects = await this.generateSmartProjects(growthAnalysis, sustainabilityGoals, developmentNeeds, culturalContext);
    for (const project of proposedProjects) {
      await this.evaluateAndApproveProject(project);
    }
    await this.updateZoningPlans();
    this.emit("developmentPlanUpdated", Array.from(this.projects.values()));
  }
  async analyzeCulturalContext() {
    const districts = await this.districtService.getAllDistricts();
    const culturalPatterns = new Map;
    for (const district of districts) {
      const extendedDistrict = district;
      const heritageValue = this.calculateHeritageValue(extendedDistrict);
      const religiousSignificance = this.calculateReligiousSignificance(extendedDistrict);
      const communityTraditions = await this.identifyCommunityTraditions(extendedDistrict);
      const developmentSensitivity = this.calculateDevelopmentSensitivity(heritageValue, religiousSignificance);
      culturalPatterns.set(district.id, {
        heritageValue,
        religiousSignificance,
        communityTraditions,
        developmentSensitivity
      });
    }
    return culturalPatterns;
  }
  calculateHeritageValue(district) {
    const historicSites = district.culturalAssets?.historicSites || [];
    const preservationStatus = district.culturalAssets?.preservationStatus || 0.5;
    const communityValue = district.culturalAssets?.communityValue || 0.5;
    return (historicSites.length * 0.4 + preservationStatus * 0.3 + communityValue * 0.3) / (historicSites.length > 0 ? 1 : 2);
  }
  calculateReligiousSignificance(district) {
    const religiousSites = district.culturalAssets?.religiousSites || [];
    const activeWorship = district.culturalAssets?.activeWorship || 0.5;
    const communityEngagement = district.culturalAssets?.communityEngagement || 0.5;
    return (religiousSites.length * 0.4 + activeWorship * 0.3 + communityEngagement * 0.3) / (religiousSites.length > 0 ? 1 : 2);
  }
  async identifyCommunityTraditions(district) {
    const traditions = new Set;
    const culturalEvents = district.events?.filter((e) => e.type === "cultural") || [];
    for (const event of culturalEvents) {
      if (event.tradition)
        traditions.add(event.tradition);
    }
    return Array.from(traditions);
  }
  calculateDevelopmentSensitivity(heritageValue, religiousSignificance) {
    return Math.max(heritageValue, religiousSignificance) * 0.7 + (heritageValue + religiousSignificance) * 0.15;
  }
  async updateUrbanFabric() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const extendedDistrict = district;
      const patterns3 = await this.identifyDevelopmentPatterns(extendedDistrict);
      const density = this.calculateDistrictDensity(extendedDistrict);
      const diversity = this.calculateDistrictDiversity(extendedDistrict);
      const connectivity = await this.calculateConnectivity(extendedDistrict);
      const culturalIntegration = await this.calculateCulturalIntegration(extendedDistrict);
      this.urbanFabrics.set(district.id, {
        density,
        diversity,
        connectivity,
        culturalIntegration,
        patterns: patterns3
      });
    }
  }
  async identifyDevelopmentPatterns(district) {
    const patterns3 = [];
    const developments = Array.from(this.projects.values()).filter((p) => p.location.districtId === district.id);
    const typeGroups = new Map;
    for (const dev of developments) {
      const group = typeGroups.get(dev.type) || [];
      group.push(dev);
      typeGroups.set(dev.type, group);
    }
    for (const [type3, group] of typeGroups) {
      patterns3.push({
        type: type3,
        frequency: group.length / developments.length,
        spatialDistribution: group.map((d) => d.location.coordinates),
        culturalSignificance: this.calculateCulturalSignificance(group),
        communityImpact: this.calculateCommunityImpact(group)
      });
    }
    return patterns3;
  }
  calculateCulturalSignificance(developments) {
    return developments.reduce((sum, dev) => {
      const cultural = dev.culturalImpact || {};
      return sum + ((cultural.preservation || 0) * 0.4 + (cultural.communityValue || 0) * 0.3 + (cultural.traditionalElements || 0) * 0.3);
    }, 0) / developments.length;
  }
  calculateCommunityImpact(developments) {
    return developments.reduce((sum, dev) => {
      const impact = dev.communityImpact || {};
      return sum + ((impact?.accessibility || 0) * 0.3 + (impact?.socialCohesion || 0) * 0.4 + (impact?.localBenefit || 0) * 0.3);
    }, 0) / developments.length;
  }
  async calculateConnectivity(district) {
    const metrics = await this.calculateInfrastructureMetrics(district.id);
    return metrics.transportScore * 0.4 + metrics.digitalScore * 0.3 + metrics.pedestrianScore * 0.3;
  }
  async calculateCulturalIntegration(district) {
    const culturalAssets = district.culturalAssets || {};
    return (culturalAssets.preservationScore || 0) * 0.3 + (culturalAssets.communityEngagement || 0) * 0.4 + (culturalAssets.culturalDiversity || 0) * 0.3;
  }
  async evaluateAndApproveProject(project) {
    const evaluation = await this.calculateProjectImpact(project);
    const culturalEvaluation = await this.evaluateCulturalImpact(project);
    const communityEvaluation = await this.evaluateCommunityImpact(project);
    if (this.meetsApprovalCriteria(evaluation) && this.meetsCulturalCriteria(culturalEvaluation) && this.meetsCommunityStandards(communityEvaluation)) {
      project.status = "approved";
      this.projects.set(project.id, project);
      await this.vectorStore.upsert({
        id: `development-${project.id}`,
        values: await this.vectorStore.createEmbedding(`${project.type} development in ${project.location.districtId} with cultural impact`),
        metadata: {
          type: "district",
          projectId: project.id,
          projectType: project.type,
          districtId: project.location.districtId,
          culturalImpact: JSON.stringify(culturalEvaluation),
          timestamp: Date.now()
        }
      });
    }
  }
  async evaluateCulturalImpact(project) {
    const district = await this.districtService.getDistrict(project.location.districtId);
    const culturalContext = (await this.analyzeCulturalContext()).get(project.location.districtId);
    return {
      heritagePreservation: this.calculateHeritageImpact(project, culturalContext),
      culturalContinuity: this.calculateCulturalContinuity(project, district),
      communityIntegration: this.calculateCommunityIntegration(project, district),
      religiousConsideration: this.calculateReligiousConsideration(project, culturalContext)
    };
  }
  calculateHeritageImpact(project, culturalContext) {
    const heritageValue = culturalContext?.heritageValue || 0.5;
    const projectImpact = project.culturalImpact?.heritagePreservation || 0.5;
    return heritageValue * 0.6 + projectImpact * 0.4;
  }
  calculateCulturalContinuity(project, district) {
    const traditions = district.culturalAssets?.traditions || [];
    const projectAlignment = project.culturalAlignment || 0.5;
    return traditions.length > 0 ? projectAlignment * 0.7 + traditions.length / 10 * 0.3 : projectAlignment;
  }
  calculateCommunityIntegration(project, district) {
    const communitySpaces = project.communityFeatures?.spaces || 0;
    const culturalFacilities = project.communityFeatures?.culturalFacilities || 0;
    const accessibility = project.communityFeatures?.accessibility || 0.5;
    return communitySpaces * 0.4 + culturalFacilities * 0.3 + accessibility * 0.3;
  }
  calculateReligiousConsideration(project, culturalContext) {
    const religiousSignificance = culturalContext?.religiousSignificance || 0.5;
    const projectConsideration = project.culturalImpact?.religiousConsideration || 0.5;
    return religiousSignificance * 0.6 + projectConsideration * 0.4;
  }
  async evaluateCommunityImpact(project) {
    return {
      socialCohesion: this.calculateSocialCohesion(project),
      accessibility: this.calculateAccessibility(project),
      culturalEnrichment: this.calculateCulturalEnrichment(project),
      communityBenefit: this.calculateCommunityBenefit(project)
    };
  }
  calculateSocialCohesion(project) {
    const communitySpaces = project.communityFeatures?.spaces || 0;
    const mixedUse = project.features?.mixedUse || 0;
    const inclusivity = project.features?.inclusivity || 0.5;
    return communitySpaces * 0.4 + mixedUse * 0.3 + inclusivity * 0.3;
  }
  calculateAccessibility(project) {
    const physicalAccess = project.accessibility?.physical || 0.5;
    const publicTransport = project.accessibility?.publicTransport || 0.5;
    const universalDesign = project.accessibility?.universalDesign || 0.5;
    return physicalAccess * 0.4 + publicTransport * 0.3 + universalDesign * 0.3;
  }
  calculateCulturalEnrichment(project) {
    const culturalSpaces = project.culturalFeatures?.spaces || 0;
    const artIntegration = project.culturalFeatures?.art || 0;
    const heritage = project.culturalFeatures?.heritage || 0;
    return culturalSpaces * 0.4 + artIntegration * 0.3 + heritage * 0.3;
  }
  calculateCommunityBenefit(project) {
    const communityFeatures = project.communityFeatures || {};
    return (communityFeatures.accessibility || 0.5) * 0.4 + (communityFeatures.socialCohesion || 0.5) * 0.3 + (communityFeatures.localBenefit || 0.5) * 0.3;
  }
  meetsCulturalCriteria(evaluation) {
    return evaluation.heritagePreservation >= 0.6 && evaluation.culturalContinuity >= 0.5 && evaluation.communityIntegration >= 0.7 && evaluation.religiousConsideration >= 0.6;
  }
  meetsCommunityStandards(evaluation) {
    return evaluation.socialCohesion >= 0.6 && evaluation.accessibility >= 0.7 && evaluation.culturalEnrichment >= 0.5 && evaluation.communityBenefit >= 0.6;
  }
  calculateOptimalScale(type3, location) {
    return 0.7;
  }
  calculateProjectPriority(type3, location, needs) {
    return 0.8;
  }
  generateSustainabilityMetrics(goals) {
    return {
      energyEfficiency: 0.85,
      greenScore: 0.9,
      environmentalImpact: 0.3
    };
  }
  projectInitialMetrics(type3, location) {
    return {
      costEfficiency: 0.8,
      communityBenefit: 0.75,
      economicGrowth: 0.7,
      qualityOfLife: 0.85
    };
  }
  async calculateSustainabilityTargets() {
    const environmentalData = await this.environmentService.getEnvironmentalMetrics();
    return {
      energyEfficiency: 0.85,
      greenSpaceRatio: 0.3,
      emissionsTarget: 0.4
    };
  }
  async identifyDevelopmentNeeds() {
    return {
      housing: this.calculateHousingNeeds(),
      infrastructure: this.calculateInfrastructureNeeds(),
      economic: this.calculateEconomicNeeds()
    };
  }
  async updateZoningPlans() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const environmentalMetrics = this.environmentalMetrics.get(district.id);
      const agentActivities = this.agentActivities.get(district.id);
      const districtVitals = this.districtVitals.get(district.id);
      this.zoningPlans.set(district.id, {
        districtId: district.id,
        allowedTypes: [
          "residential",
          "commercial",
          "greenspace",
          "computational",
          "data_center"
        ],
        densityLimit: 0.8,
        heightLimit: 100,
        greenSpaceRatio: 0.3,
        culturalZoning: {
          type: "modern",
          preservationLevel: "moderate",
          heightRestrictions: 100,
          architecturalGuidelines: {
            style: "modern",
            materials: ["concrete", "glass", "steel"],
            colorPalette: ["gray", "white", "black"]
          },
          culturalRequirements: {
            preservationElements: [],
            communitySpaces: true,
            ritualAreas: false,
            soundRegulations: {
              maxDecibels: 50,
              quietHours: []
            }
          }
        },
        smartZoning: {
          type: "modern",
          preservationLevel: "moderate",
          heightRestrictions: 100,
          architecturalGuidelines: {
            style: "modern",
            materials: ["concrete", "glass", "steel"],
            colorPalette: ["gray", "white", "black"]
          },
          culturalRequirements: {
            preservationElements: [],
            communitySpaces: true,
            ritualAreas: false,
            soundRegulations: {
              maxDecibels: 50,
              quietHours: []
            }
          },
          aiLivingSpaces: {
            computationalHubs: Math.ceil((districtVitals?.aiPopulationDensity || 0.5) * 10),
            dataProcessingCenters: Math.ceil((districtVitals?.computationalLoad || 0.5) * 5),
            interactionZones: Math.ceil((agentActivities?.interactionFrequency || 0.5) * 8),
            learningCenters: Math.ceil((agentActivities?.knowledgeSharing || 0.5) * 6)
          },
          environmentalControls: {
            emissionLimits: (environmentalMetrics?.carbonEmissions || 0.5) * 1.2,
            energyQuotas: (environmentalMetrics?.energyEfficiency || 0.7) * 100,
            wasteProcessing: (environmentalMetrics?.wasteManagement || 0.6) * 100,
            resourceAllocation: (environmentalMetrics?.resourceUtilization || 0.7) * 100
          },
          agentFacilities: {
            collaborationSpaces: Math.ceil((agentActivities?.collaborationScore || 0.5) * 10),
            innovationHubs: Math.ceil((agentActivities?.innovationRate || 0.5) * 5),
            knowledgeCenters: Math.ceil((agentActivities?.knowledgeSharing || 0.5) * 8),
            adaptationZones: Math.ceil((agentActivities?.adaptabilityScore || 0.5) * 6)
          }
        },
        sustainabilityRequirements: {
          minEnergyEfficiency: 0.7,
          minGreenScore: 0.6,
          maxEnvironmentalImpact: 0.4,
          culturalPreservation: 0.5
        },
        communityRequirements: {
          publicSpaceRatio: 0.3,
          culturalFacilities: true,
          accessibilityScore: 0.7
        },
        aiMetrics: {
          minComputationalEfficiency: 0.8,
          minDataAccessibility: 0.9,
          minInteractionQuality: 0.85
        },
        environmentalStandards: {
          maxCarbonEmissions: 0.4,
          minEnergyEfficiency: 0.8,
          minWasteProcessing: 0.7
        }
      });
    }
  }
  calculatePopulationTrends(metrics) {
    return {
      growth: 0.05,
      density: 0.7,
      distribution: {}
    };
  }
  assessInfrastructureCapacity(data) {
    return {
      utilization: 0.75,
      bottlenecks: [],
      expansionNeeds: []
    };
  }
  evaluateEnvironmentalFactors(metrics) {
    return {
      airQuality: 0.8,
      greenCoverage: 0.4,
      sustainability: 0.6
    };
  }
  analyzeEconomicTrends(metrics) {
    return {
      growth: 0.04,
      sectors: { residential: 0.3, commercial: 0.5, industrial: 0.2 },
      investment: 0.6
    };
  }
  determineOptimalProjectMix(analysis) {
    return [
      "residential",
      "commercial",
      "greenspace"
    ];
  }
  async findOptimalLocations(types2) {
    return types2.map((type3) => [
      type3,
      { districtId: "central", coordinates: [0, 0] }
    ]);
  }
  async calculateProjectImpact(project) {
    return {
      environmental: 0.3,
      social: 0.7,
      economic: 0.8
    };
  }
  meetsApprovalCriteria(evaluation) {
    return evaluation.environmental < 0.5 && evaluation.social > 0.6 && evaluation.economic > 0.7;
  }
  async calculateOptimizations(project) {
    return {
      timeline: { adjustments: [] },
      resources: { optimizations: [] },
      sustainability: { improvements: [] }
    };
  }
  async applyProjectOptimizations(project, optimizations) {
    this.projects.set(project.id, {
      ...project
    });
  }
  calculateHousingNeeds() {
    return { demand: 0.8, affordability: 0.6 };
  }
  calculateInfrastructureNeeds() {
    return { capacity: 0.7, maintenance: 0.4 };
  }
  calculateEconomicNeeds() {
    return { growth: 0.6, diversity: 0.7 };
  }
  getProjects() {
    return this.projects;
  }
  async submitProject(projectData) {
    const project = {
      id: crypto.randomUUID(),
      ...projectData,
      status: "proposed",
      timeline: {
        proposed: Date.now()
      },
      metrics: this.projectInitialMetrics(projectData.type, projectData.location),
      sustainability: this.generateSustainabilityMetrics({}),
      culturalImpact: {
        culturalPreservation: 0.7,
        communityEngagement: 0.6,
        touristAttraction: 0.7,
        heritagePreservation: (await this.calculateInitialCulturalImpact(projectData)).heritagePreservation,
        culturalContinuity: (await this.calculateInitialCulturalImpact(projectData)).culturalContinuity,
        religiousConsideration: (await this.calculateInitialCulturalImpact(projectData)).religiousConsideration
      },
      communityFeatures: this.generateCommunityFeatures(projectData)
    };
    await this.evaluateAndApproveProject(project);
    return project;
  }
  async calculateInitialCulturalImpact(projectData) {
    const district = await this.districtService.getDistrict(projectData.location.districtId);
    const culturalContext = (await this.analyzeCulturalContext()).get(projectData.location.districtId);
    return {
      heritagePreservation: this.calculateInitialHeritageImpact(projectData, culturalContext),
      culturalContinuity: this.calculateInitialCulturalContinuity(projectData, district),
      communityIntegration: 0.7,
      religiousConsideration: this.calculateInitialReligiousConsideration(projectData, culturalContext)
    };
  }
  calculateInitialHeritageImpact(projectData, culturalContext) {
    const heritageValue = culturalContext?.heritageValue || 0.5;
    const projectType = projectData.type;
    const baseImpact = projectType === "heritage" ? 0.9 : projectType === "cultural" ? 0.8 : projectType === "religious" ? 0.7 : 0.5;
    return heritageValue * 0.4 + baseImpact * 0.6;
  }
  calculateInitialCulturalContinuity(projectData, district) {
    const traditions = district?.culturalAssets?.traditions || [];
    const projectType = projectData.type;
    const baseAlignment = projectType === "cultural" ? 0.8 : projectType === "religious" ? 0.7 : projectType === "community" ? 0.6 : 0.4;
    return traditions.length > 0 ? baseAlignment * 0.7 + traditions.length / 10 * 0.3 : baseAlignment;
  }
  calculateInitialReligiousConsideration(projectData, culturalContext) {
    const religiousSignificance = culturalContext?.religiousSignificance || 0.5;
    const projectType = projectData.type;
    const baseConsideration = projectType === "religious" ? 0.9 : projectType === "cultural" ? 0.7 : projectType === "community" ? 0.6 : 0.4;
    return religiousSignificance * 0.4 + baseConsideration * 0.6;
  }
  generateCommunityFeatures(projectData) {
    const baseFeatures = {
      spaces: 0.6,
      culturalFacilities: 0.5,
      accessibility: 0.7
    };
    if (projectData.type === "cultural" || projectData.type === "religious") {
      return {
        spaces: 0.8,
        culturalFacilities: 0.9,
        accessibility: 0.8
      };
    }
    return baseFeatures;
  }
  async getGrowthAnalysis() {
    return this.analyzeGrowthPatterns();
  }
  async analyzeGrowthPatterns() {
    const districtMetrics = await this.districtService.getAllMetrics();
    const infrastructureData = await this.smartInfrastructure.getSystemStatus();
    const environmentalFactors = await this.environmentService.getEnvironmentalMetrics();
    return {
      populationTrends: this.calculatePopulationTrends(districtMetrics),
      infrastructureNeeds: this.assessInfrastructureCapacity(infrastructureData),
      environmentalConsiderations: this.evaluateEnvironmentalFactors(environmentalFactors),
      economicIndicators: this.analyzeEconomicTrends(districtMetrics)
    };
  }
  async optimizeProjects() {
    const activeProjects = Array.from(this.projects.values()).filter((p) => p.status === "in_progress");
    for (const project of activeProjects) {
      const optimizations = await this.calculateOptimizations(project);
      await this.applyProjectOptimizations(project, optimizations);
    }
  }
  async generateSmartProjects(growthAnalysis, sustainabilityGoals, developmentNeeds, culturalContext) {
    const projects = [];
    const projectTypes = this.determineOptimalProjectMix(growthAnalysis);
    const locations = await this.findOptimalLocations(projectTypes);
    for (const [type3, location] of locations) {
      const culturalData = culturalContext.get(location.districtId);
      projects.push({
        id: crypto.randomUUID(),
        type: type3,
        status: "proposed",
        location,
        timeline: {
          proposed: Date.now()
        },
        metrics: this.projectInitialMetrics(type3, location),
        sustainability: this.generateSustainabilityMetrics(sustainabilityGoals),
        culturalImpact: {
          culturalPreservation: culturalData?.heritageValue || 0.7,
          communityEngagement: culturalData?.religiousSignificance || 0.6,
          touristAttraction: 0.7,
          heritagePreservation: culturalData?.heritageValue || 0.7,
          culturalContinuity: 0.8,
          religiousConsideration: culturalData?.religiousSignificance || 0.6
        }
      });
    }
    return projects;
  }
  calculateDistrictDensity(district) {
    const area = district.area || 1;
    const population = district.population || 0;
    const buildings = district.buildings?.length || 0;
    return population / area * 0.6 + buildings / area * 0.4;
  }
  calculateDistrictDiversity(district) {
    const buildingTypes = new Set(district.buildings?.map((b) => b.type) || []);
    const landUseTypes = new Set(district.landUse?.map((l) => l.type) || []);
    return (buildingTypes.size * 0.5 + landUseTypes.size * 0.5) / 10;
  }
  async evolveConsciousness() {
    const districts = await this.districtService.getAllDistricts();
    let totalEnvironmental = 0;
    let totalSocial = 0;
    let totalCultural = 0;
    let totalTechnological = 0;
    for (const district of districts) {
      const vitals = this.districtVitals.get(district.id);
      const envMetrics = this.environmentalMetrics.get(district.id);
      const activities = this.agentActivities.get(district.id);
      if (vitals && envMetrics && activities) {
        totalEnvironmental += envMetrics.sustainabilityScore;
        totalSocial += vitals.communityEngagement;
        totalCultural += activities.knowledgeSharing;
        totalTechnological += vitals.computationalLoad;
      }
    }
    const districtCount = Math.max(districts.length, 1);
    this.cityConsciousness.awarenessLevels = {
      environmental: totalEnvironmental / districtCount,
      social: totalSocial / districtCount,
      cultural: totalCultural / districtCount,
      technological: totalTechnological / districtCount
    };
    this.emit("consciousnessEvolved", this.cityConsciousness.awarenessLevels);
  }
  async updateCollectiveMemory() {
    const currentState = {
      timestamp: Date.now(),
      districts: await this.districtService.getAllDistricts(),
      vitals: Array.from(this.districtVitals.entries()),
      environment: Array.from(this.environmentalMetrics.entries()),
      activities: Array.from(this.agentActivities.entries())
    };
    this.cityConsciousness.collectiveMemory.shortTerm.set(Date.now().toString(), currentState);
    const significantEvents = this.identifySignificantEvents(currentState);
    for (const event of significantEvents) {
      this.cityConsciousness.collectiveMemory.longTerm.set(event.timestamp.toString(), event);
    }
    const culturalPatterns = this.identifyCulturalPatterns(currentState);
    for (const pattern2 of culturalPatterns) {
      this.cityConsciousness.collectiveMemory.cultural.set(pattern2.id, pattern2);
    }
    const evolutionaryTrends = this.analyzeEvolutionaryTrends(currentState);
    for (const trend of evolutionaryTrends) {
      this.cityConsciousness.collectiveMemory.evolutionary.set(trend.id, trend);
    }
    this.emit("collectiveMemoryUpdated", {
      shortTermSize: this.cityConsciousness.collectiveMemory.shortTerm.size,
      longTermSize: this.cityConsciousness.collectiveMemory.longTerm.size,
      culturalPatterns: this.cityConsciousness.collectiveMemory.cultural.size,
      evolutionaryTrends: this.cityConsciousness.collectiveMemory.evolutionary.size
    });
  }
  async processConsciousnessEvents() {
    const events = [];
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const vitals = this.districtVitals.get(district.id);
      const envMetrics = this.environmentalMetrics.get(district.id);
      const activities = this.agentActivities.get(district.id);
      if (vitals && envMetrics && activities) {
        if (envMetrics.sustainabilityScore < 0.3) {
          events.push({
            type: "awareness",
            timestamp: Date.now(),
            impact: 0.8,
            scope: "district",
            data: {
              districtId: district.id,
              metric: "sustainability",
              value: envMetrics.sustainabilityScore
            }
          });
        }
        if (activities.knowledgeSharing > 0.8) {
          events.push({
            type: "memory",
            timestamp: Date.now(),
            impact: 0.7,
            scope: "district",
            data: {
              districtId: district.id,
              metric: "knowledge",
              value: activities.knowledgeSharing
            }
          });
        }
        if (vitals.computationalLoad > 0.9) {
          events.push({
            type: "decision",
            timestamp: Date.now(),
            impact: 0.9,
            scope: "district",
            data: {
              districtId: district.id,
              metric: "computation",
              value: vitals.computationalLoad
            }
          });
        }
        if (activities.innovationRate > 0.7) {
          events.push({
            type: "evolution",
            timestamp: Date.now(),
            impact: 0.8,
            scope: "district",
            data: {
              districtId: district.id,
              metric: "innovation",
              value: activities.innovationRate
            }
          });
        }
      }
    }
    if (events.length > 0) {
      this.cityConsciousness.decisionMaking = {
        autonomy: this.calculateAutonomy(events),
        consensus: this.calculateConsensus(events),
        adaptation: this.calculateAdaptation(events),
        prediction: this.calculatePrediction(events)
      };
    }
    this.emit("consciousnessEventsProcessed", events);
  }
  identifySignificantEvents(currentState) {
    return [];
  }
  identifyCulturalPatterns(currentState) {
    return [];
  }
  analyzeEvolutionaryTrends(currentState) {
    return [];
  }
  calculateAutonomy(events) {
    return events.reduce((sum, event) => sum + event.impact, 0) / events.length;
  }
  calculateConsensus(events) {
    const districtEvents = events.filter((e) => e.scope === "district");
    return districtEvents.length / events.length;
  }
  calculateAdaptation(events) {
    const adaptiveEvents = events.filter((e) => e.type === "evolution");
    return adaptiveEvents.reduce((sum, event) => sum + event.impact, 0) / events.length;
  }
  calculatePrediction(events) {
    const decisionEvents = events.filter((e) => e.type === "decision");
    return decisionEvents.reduce((sum, event) => sum + event.impact, 0) / events.length;
  }
  async updateChronicles() {
    const currentState = {
      districts: await this.districtService.getAllDistricts(),
      vitals: Array.from(this.districtVitals.entries()),
      environment: Array.from(this.environmentalMetrics.entries()),
      activities: Array.from(this.agentActivities.entries()),
      consciousness: this.cityConsciousness
    };
    const newEvents = await this.identifySignificantEvents(currentState);
    for (const event of newEvents) {
      const chronicle = {
        id: crypto.randomUUID(),
        timestamp: Date.now(),
        type: this.determineEventType(event),
        importance: this.calculateEventImportance(event),
        scope: await this.determineEventScope(event),
        title: this.generateEventTitle(event),
        description: this.generateEventDescription(event),
        location: {
          districtId: event.data.districtId,
          coordinates: event.data.coordinates
        },
        impact: {
          cultural: this.calculateCulturalImpact(event),
          social: this.calculateSocialImpact(event),
          environmental: this.calculateEnvironmentalImpact(event),
          technological: this.calculateTechnologicalImpact(event)
        },
        participants: {
          agents: await this.identifyInvolvedAgents(event),
          districts: await this.identifyAffectedDistricts(event),
          systems: await this.identifyInvolvedSystems(event)
        },
        relatedEvents: this.findRelatedEvents(event),
        outcomes: {
          immediate: this.identifyImmediateOutcomes(event),
          longTerm: this.predictLongTermOutcomes(event)
        },
        metrics: this.gatherEventMetrics(event)
      };
      this.cityChronicles.set(chronicle.id, chronicle);
      await this.vectorStore.upsert({
        id: `chronicle-${chronicle.id}`,
        values: await this.vectorStore.createEmbedding(`${chronicle.title} ${chronicle.description} ${chronicle.type} impact on ${chronicle.scope} level`),
        metadata: {
          type: "district",
          chronicleId: chronicle.id,
          eventType: chronicle.type,
          importance: chronicle.importance,
          scope: chronicle.scope,
          timestamp: chronicle.timestamp,
          impact: JSON.stringify(chronicle.impact),
          districts: chronicle.participants.districts
        }
      });
      if (chronicle.importance > 0.7) {
        this.cityConsciousness.collectiveMemory.longTerm.set(chronicle.id, chronicle);
      }
      this.emit("chronicleCreated", chronicle);
    }
  }
  determineEventType(event) {
    if (event.data.metric === "sustainability")
      return "environmental";
    if (event.data.metric === "knowledge")
      return "cultural";
    if (event.data.metric === "computation")
      return "innovation";
    if (event.data.metric === "social")
      return "social";
    return "milestone";
  }
  calculateEventImportance(event) {
    return Math.min(1, event.impact * 0.4 + event.data.value * 0.3 + (event.scope === "global" ? 0.3 : event.scope === "city" ? 0.2 : 0.1));
  }
  async determineEventScope(event) {
    const affectedDistricts = await this.identifyAffectedDistricts(event);
    const allDistricts = await this.districtService.getAllDistricts();
    if (affectedDistricts.length > allDistricts.length * 0.7) {
      return "global";
    }
    if (affectedDistricts.length > 1) {
      return "city";
    }
    return "district";
  }
  generateEventTitle(event) {
    const type3 = event.type.charAt(0).toUpperCase() + event.type.slice(1);
    const metric = event.data.metric.charAt(0).toUpperCase() + event.data.metric.slice(1);
    return `${type3} Event: ${metric} Milestone in ${event.data.districtId}`;
  }
  generateEventDescription(event) {
    return `A significant ${event.type} event occurred in district ${event.data.districtId}, 
    involving ${event.data.metric} with a value of ${event.data.value}. 
    This event has an impact of ${event.impact} on the ${event.scope} level.`;
  }
  calculateCulturalImpact(event) {
    const district = this.districtService.getDistrict(event.data.districtId);
    const activities = this.agentActivities.get(event.data.districtId);
    return (activities?.knowledgeSharing || 0.5) * event.impact;
  }
  calculateSocialImpact(event) {
    const vitals = this.districtVitals.get(event.data.districtId);
    return (vitals?.communityEngagement || 0.5) * event.impact;
  }
  calculateEnvironmentalImpact(event) {
    const metrics = this.environmentalMetrics.get(event.data.districtId);
    return (1 - (metrics?.carbonEmissions || 0.5)) * event.impact;
  }
  calculateTechnologicalImpact(event) {
    const vitals = this.districtVitals.get(event.data.districtId);
    return (vitals?.computationalLoad || 0.5) * event.impact;
  }
  async identifyInvolvedAgents(event) {
    const district = await this.districtService.getDistrict(event.data.districtId);
    return district?.agents?.filter((a) => a.status === "active").map((a) => a.id) || [];
  }
  async identifyAffectedDistricts(event) {
    const districts = await this.districtService.getAllDistricts();
    const affectedDistricts = [];
    for (const district of districts) {
      const extendedDistrict = district;
      if (await this.isDistrictAffected(extendedDistrict, event)) {
        affectedDistricts.push(extendedDistrict);
      }
    }
    return affectedDistricts.map((d) => d.id);
  }
  async identifyInvolvedSystems(event) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(event.data.districtId);
    return infrastructure.systems.map((s) => s.id);
  }
  findRelatedEvents(event) {
    return Array.from(this.cityChronicles.values()).filter((c) => c.type === event.type || c.location.districtId === event.data.districtId || Math.abs(c.timestamp - event.timestamp) < 24 * 60 * 60 * 1000).map((c) => c.id);
  }
  identifyImmediateOutcomes(event) {
    const outcomes = [];
    if (event.data.value > 0.8)
      outcomes.push("Significant improvement in " + event.data.metric);
    if (event.data.value < 0.3)
      outcomes.push("Critical decline in " + event.data.metric);
    if (event.impact > 0.7)
      outcomes.push("Major impact on " + event.scope + " level");
    return outcomes;
  }
  predictLongTermOutcomes(event) {
    const outcomes = [];
    if (event.type === "innovation")
      outcomes.push("Potential technological advancement");
    if (event.type === "cultural")
      outcomes.push("Cultural pattern evolution");
    if (event.type === "environmental")
      outcomes.push("Environmental impact trend");
    return outcomes;
  }
  gatherEventMetrics(event) {
    return {
      value: event.data.value,
      impact: event.impact,
      duration: event.data.duration || 0,
      intensity: event.data.intensity || event.impact,
      frequency: this.calculateEventFrequency(event.type)
    };
  }
  calculateEventFrequency(eventType) {
    const recentEvents = Array.from(this.cityChronicles.values()).filter((c) => c.type === eventType && c.timestamp > Date.now() - 24 * 60 * 60 * 1000);
    return recentEvents.length / 24;
  }
  async isDistrictAffected(district, event) {
    const distance = await this.calculateDistrictDistance(district, event.data.districtId);
    return distance < event.impact * 100;
  }
  async calculateDistrictDistance(district1, district2Id) {
    const district2 = await this.districtService.getDistrict(district2Id);
    if (!district2)
      return Infinity;
    const [x1, y1] = district1.location.coordinates;
    const [x2, y2] = district2.location.coordinates;
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }
  calculateInfrastructureScore(infrastructure) {
    const transportSystems = infrastructure.systems.filter((s) => s.type === "transportation" || s.type === "traffic");
    const digitalSystems = infrastructure.systems.filter((s) => s.type === "digital");
    const pedestrianSystems = infrastructure.systems.filter((s) => s.type === "pedestrian");
    const transportScore = transportSystems.length > 0 ? transportSystems.reduce((sum, s) => sum + s.metrics.efficiency, 0) / transportSystems.length : 0.5;
    const digitalScore = digitalSystems.length > 0 ? digitalSystems.reduce((sum, s) => sum + (s.metrics.connectivity || 0), 0) / digitalSystems.length : 0.5;
    const pedestrianScore = pedestrianSystems.length > 0 ? pedestrianSystems.reduce((sum, s) => sum + (s.metrics.accessibility || 0), 0) / pedestrianSystems.length : 0.5;
    return (transportScore + digitalScore + pedestrianScore) / 3;
  }
  async calculateInfrastructureMetrics(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const score = this.calculateInfrastructureScore(infrastructure);
    return {
      transportScore: this.calculateTransportScore(infrastructure.systems),
      digitalScore: this.calculateDigitalScore(infrastructure.systems),
      pedestrianScore: this.calculatePedestrianScore(infrastructure.systems),
      overallScore: score
    };
  }
  calculateTransportScore(systems) {
    const transportSystems = systems.filter((s) => s.type === "transportation" || s.type === "traffic");
    return transportSystems.length > 0 ? transportSystems.reduce((sum, s) => sum + s.metrics.efficiency, 0) / transportSystems.length : 0.5;
  }
  calculateDigitalScore(systems) {
    const digitalSystems = systems.filter((s) => s.type === "digital");
    return digitalSystems.length > 0 ? digitalSystems.reduce((sum, s) => sum + (s.metrics.connectivity || 0), 0) / digitalSystems.length : 0.5;
  }
  calculatePedestrianScore(systems) {
    const pedestrianSystems = systems.filter((s) => s.type === "pedestrian");
    return pedestrianSystems.length > 0 ? pedestrianSystems.reduce((sum, s) => sum + (s.metrics.accessibility || 0), 0) / pedestrianSystems.length : 0.5;
  }
  async evaluateInfrastructure(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const metrics = await this.calculateInfrastructureMetrics(districtId);
    return {
      transportationScore: metrics.transportScore,
      digitalConnectivity: metrics.digitalScore,
      pedestrianAccess: metrics.pedestrianScore,
      resourceUtilization: this.calculateResourceUtilization(infrastructure),
      overallScore: metrics.overallScore
    };
  }
  calculateResourceUtilization(infrastructure) {
    const waterUtil = infrastructure.resources.water.consumption / infrastructure.resources.water.capacity;
    const powerUtil = infrastructure.resources.power.consumption / infrastructure.resources.power.capacity;
    const dataUtil = infrastructure.resources.data.usage / infrastructure.resources.data.capacity;
    return (waterUtil + powerUtil + dataUtil) / 3;
  }
  async calculateConnectivityScore(infrastructure) {
    const metrics = await this.calculateInfrastructureMetrics(infrastructure.districtId);
    return metrics.digitalScore;
  }
  calculateInfrastructureEfficiency(infrastructure) {
    const metrics = this.calculateInfrastructureScore(infrastructure);
    return metrics * 0.4 + this.calculateResourceUtilization(infrastructure) * 0.6;
  }
}

// src/services/environment.service.ts
import { EventEmitter as EventEmitter14 } from "events";

class EnvironmentService extends EventEmitter14 {
  vectorStore;
  districtService;
  smartInfrastructure;
  analyticsService;
  activeAlerts = new Set;
  districtMetrics = new Map;
  sustainabilityProjects = new Map;
  greenInitiatives = new Map;
  resourceUsage = new Map;
  emissionSources = new Map;
  environmentalZones = new Map;
  smartSensors = new Map;
  constructor(vectorStore, districtService, smartInfrastructure, analyticsService) {
    super();
    this.vectorStore = vectorStore;
    this.districtService = districtService;
    this.smartInfrastructure = smartInfrastructure;
    this.analyticsService = analyticsService;
    this.initializeService();
  }
  initializeService() {
    this.initializeEnvironmentalMonitoring();
    this.on("environmentalAlert", (alert) => {
      this.analyticsService.trackInteraction({ id: alert.districtId, type: "environment" }, {
        type: "alert",
        content: alert.description,
        sentiment: alert.severity > 0.7 ? 0.2 : 0.5,
        topics: ["environment", alert.type, "alert"]
      });
    });
    this.on("airQualityChanged", (data) => {
      this.analyticsService.trackInteraction({ id: data.districtId, type: "environment" }, {
        type: "air_quality",
        content: `Air quality index: ${data.aqi}`,
        sentiment: data.aqi > 150 ? 0.3 : 0.8,
        topics: ["environment", "air_quality", "health"]
      });
    });
    this.on("sustainabilityMetricsUpdated", (metrics) => {
      this.analyticsService.trackInteraction({ id: metrics.districtId, type: "environment" }, {
        type: "sustainability",
        content: `Sustainability score: ${metrics.score}`,
        sentiment: metrics.score,
        topics: ["environment", "sustainability", "metrics"]
      });
      this.analyticsService.trackMood(metrics.score);
    });
  }
  initializeEnvironmentalMonitoring() {
    setInterval(() => this.monitorEnvironmentalMetrics(), 1000 * 60 * 5);
    setInterval(() => this.processEnvironmentalAlerts(), 1000 * 60 * 15);
    setInterval(() => this.updateSustainabilityProjects(), 1000 * 60 * 30);
    setInterval(() => this.trackResourceUsage(), 1000 * 60 * 10);
    setInterval(() => this.monitorEmissions(), 1000 * 60 * 20);
  }
  async monitorEnvironmentalMetrics() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const metrics = {
        airQuality: await this.measureAirQuality(district.id),
        waterQuality: await this.measureWaterQuality(district.id),
        noiseLevel: await this.measureNoiseLevel(district.id),
        greenCoverage: await this.calculateGreenCoverage(district.id),
        biodiversity: await this.assessBiodiversity(district.id),
        emissions: await this.calculateEmissions(district.id),
        sustainability: await this.calculateSustainabilityScore(district.id),
        resourceEfficiency: await this.calculateResourceEfficiency(district.id),
        wasteManagement: await this.assessWasteManagement(district.id),
        energyUsage: await this.monitorEnergyUsage(district.id),
        water: {
          quality: (await this.measureWaterQuality(district.id)).score || 0.5,
          usage: await this.measureWaterUsage(district.id),
          conservation: await this.measureSystemValue(await this.smartInfrastructure.getDistrictInfrastructure(district.id), "water")
        },
        greenSpace: {
          coverage: await this.calculateGreenCoverage(district.id),
          quality: await this.measureSystemValue(await this.smartInfrastructure.getDistrictInfrastructure(district.id), "green"),
          accessibility: 0.7
        }
      };
      this.districtMetrics.set(district.id, metrics);
      this.emit("metricsUpdated", { districtId: district.id, metrics });
    }
  }
  async processEnvironmentalAlerts() {
    for (const [districtId, metrics] of this.districtMetrics.entries()) {
      if (metrics.airQuality.aqi < 50) {
        this.createAlert({
          id: crypto.randomUUID(),
          type: "air",
          severity: metrics.airQuality.aqi < 30 ? "high" : "medium",
          location: {
            districtId,
            coordinates: [0, 0]
          },
          timestamp: Date.now(),
          description: `Poor air quality detected in district ${districtId}`,
          metrics: { airQuality: metrics.airQuality }
        });
      }
      if (metrics.waterQuality.ph < 6) {
        this.createAlert({
          id: crypto.randomUUID(),
          type: "water",
          severity: metrics.waterQuality.ph < 4 ? "high" : "medium",
          location: {
            districtId,
            coordinates: [0, 0]
          },
          timestamp: Date.now(),
          description: `Water quality issues detected in district ${districtId}`,
          metrics: { waterQuality: metrics.waterQuality }
        });
      }
      if (metrics.noiseLevel.decibels > 70) {
        this.createAlert({
          id: crypto.randomUUID(),
          type: "noise",
          severity: metrics.noiseLevel.decibels > 80 ? "high" : "medium",
          location: {
            districtId,
            coordinates: [0, 0]
          },
          timestamp: Date.now(),
          description: `High noise levels detected in district ${districtId}`,
          metrics: { noiseLevel: metrics.noiseLevel }
        });
      }
    }
  }
  async updateSustainabilityProjects() {
    for (const project of this.sustainabilityProjects.values()) {
      const progress = await this.calculateProjectProgress(project);
      const impact = await this.assessProjectImpact(project);
      await this.vectorStore.upsert({
        id: `sustainability-${project.id}`,
        values: await this.vectorStore.createEmbedding(`Sustainability project ${project.type} with progress ${progress} and impact ${impact.overall}`),
        metadata: {
          type: "district",
          projectId: project.id,
          projectType: project.type,
          districtId: project.districtId,
          progress,
          impact: JSON.stringify(impact),
          timestamp: Date.now()
        }
      });
      this.emit("projectUpdated", { projectId: project.id, progress, impact });
    }
  }
  async trackResourceUsage() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const usage = {
        water: await this.measureWaterUsage(district.id),
        energy: await this.measureEnergyUsage(district.id),
        waste: await this.measureWasteGeneration(district.id),
        recycling: await this.measureRecyclingRate(district.id)
      };
      this.resourceUsage.set(district.id, usage);
      this.emit("resourceUsageUpdated", { districtId: district.id, usage });
    }
  }
  async monitorEmissions() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const sources = await this.identifyEmissionSources(district.id);
      const totalEmissions = sources.reduce((total, source) => total + source.amount, 0);
      if (totalEmissions > 0.7) {
        this.createAlert({
          id: crypto.randomUUID(),
          type: "green",
          severity: totalEmissions > 0.9 ? "high" : "medium",
          location: {
            districtId: district.id,
            coordinates: [0, 0]
          },
          timestamp: Date.now(),
          description: `High emission levels detected in district ${district.id}`,
          metrics: { emissions: totalEmissions }
        });
      }
      const emissionSource = {
        id: district.id,
        type: "district",
        amount: totalEmissions,
        location: {
          districtId: district.id,
          coordinates: [0, 0]
        }
      };
      this.emissionSources.set(district.id, emissionSource);
      this.emit("emissionsUpdated", {
        districtId: district.id,
        emissions: totalEmissions,
        sources
      });
    }
  }
  async measureSystemValue(infrastructure, systemType) {
    if (!infrastructure?.systems?.length)
      return 0.5;
    const systems = infrastructure.systems.filter((s) => s.type === systemType);
    if (!systems.length)
      return 0.5;
    const values = systems.map((s) => {
      const metrics = s.metrics || {};
      if ("value" in metrics && typeof metrics.value === "number")
        return metrics.value;
      if ("efficiency" in metrics && typeof metrics.efficiency === "number")
        return metrics.efficiency;
      if ("consumption" in metrics && typeof metrics.consumption === "number")
        return 1 - metrics.consumption;
      if ("emissions" in metrics && typeof metrics.emissions === "number")
        return 1 - metrics.emissions;
      if ("generation" in metrics && typeof metrics.generation === "number")
        return metrics.generation;
      return 0.5;
    });
    return values.reduce((acc, val) => acc + val, 0) / values.length;
  }
  async measureAirQuality(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const sensorValue = await this.measureSystemValue(infrastructure, "air");
    return {
      pm25: sensorValue * 500,
      pm10: sensorValue * 500,
      no2: sensorValue * 200,
      o3: sensorValue * 300,
      aqi: sensorValue * 500
    };
  }
  async measureWaterQuality(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const sensorValue = await this.measureSystemValue(infrastructure, "water");
    return {
      ph: 7 + (sensorValue - 0.5) * 2,
      turbidity: sensorValue,
      dissolvedOxygen: (1 - sensorValue) * 10,
      conductivity: sensorValue * 1000,
      temperature: 20 + (sensorValue - 0.5) * 10
    };
  }
  async measureNoiseLevel(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const sensorValue = await this.measureSystemValue(infrastructure, "noise");
    return {
      decibels: sensorValue * 120,
      frequency: 1000 + sensorValue * 4000,
      duration: 60,
      peakTime: Date.now(),
      source: "environmental_sensor"
    };
  }
  async calculateGreenCoverage(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    return await this.measureSystemValue(infrastructure, "green");
  }
  async assessBiodiversity(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const biodiversityValue = await this.measureSystemValue(infrastructure, "green");
    return {
      speciesCount: Math.floor(biodiversityValue * 200),
      habitatQuality: biodiversityValue,
      ecosystemHealth: biodiversityValue
    };
  }
  async calculateEmissions(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const powerEmissions = await this.measureSystemValue(infrastructure, "power");
    const wasteEmissions = await this.measureSystemValue(infrastructure, "waste");
    return (powerEmissions + wasteEmissions) / 2;
  }
  async calculateSustainabilityScore(districtId) {
    const metrics = this.districtMetrics.get(districtId);
    if (!metrics)
      return 0.5;
    const airQualityScore = metrics.airQuality.aqi / 500;
    const waterQualityScore = await this.calculateWaterQualityScore(metrics.waterQuality);
    const noiseLevelScore = metrics.noiseLevel.decibels <= 60 ? 1 : 0;
    return airQualityScore * 0.2 + waterQualityScore * 0.2 + metrics.greenCoverage * 0.15 + (1 - metrics.emissions) * 0.15 + metrics.resourceEfficiency * 0.15 + metrics.wasteManagement * 0.15;
  }
  async calculateWaterQualityScore(data) {
    const score = {
      phScore: data.ph >= 6 && data.ph <= 8 ? 1 : 0,
      turbidityScore: 1 - data.turbidity,
      oxygenScore: data.dissolvedOxygen / 10,
      conductivityScore: Math.min(1, 1000 / data.conductivity),
      temperatureScore: data.temperature >= 15 && data.temperature <= 25 ? 1 : 0,
      value: 0
    };
    score.value = (score.phScore + score.turbidityScore + score.oxygenScore + score.conductivityScore + score.temperatureScore) / 5;
    const result = { ...data, score: score.value };
    return result.score;
  }
  async calculateResourceEfficiency(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const powerEfficiency = await this.measureSystemValue(infrastructure, "power");
    const waterEfficiency = await this.measureSystemValue(infrastructure, "water");
    const wasteEfficiency = await this.measureSystemValue(infrastructure, "waste");
    return (powerEfficiency + waterEfficiency + wasteEfficiency) / 3;
  }
  async assessWasteManagement(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    return await this.measureSystemValue(infrastructure, "waste");
  }
  async monitorEnergyUsage(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    return await this.measureSystemValue(infrastructure, "power");
  }
  async measureWaterUsage(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const waterSystems = infrastructure.systems.filter((s) => s.type === "water");
    return waterSystems.reduce((acc, s) => acc + (s.consumption || 0), 0) / Math.max(waterSystems.length, 1);
  }
  async measureEnergyUsage(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const energySystems = infrastructure.systems.filter((s) => s.type === "power");
    return energySystems.reduce((acc, s) => acc + (s.consumption || 0), 0) / Math.max(energySystems.length, 1);
  }
  async measureWasteGeneration(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const wasteSystems = infrastructure.systems.filter((s) => s.type === "waste");
    return wasteSystems.reduce((acc, s) => acc + (s.generation || 0), 0) / Math.max(wasteSystems.length, 1);
  }
  async measureRecyclingRate(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    const recyclingSystems = infrastructure.systems.filter((s) => s.type === "recycling");
    return recyclingSystems.reduce((acc, s) => acc + (s.efficiency || 0), 0) / Math.max(recyclingSystems.length, 1);
  }
  async identifyEmissionSources(districtId) {
    const infrastructure = await this.smartInfrastructure.getDistrictInfrastructure(districtId);
    if (!infrastructure?.systems?.length)
      return [];
    return infrastructure.systems.filter((s) => {
      const metrics = s.metrics || {};
      return "emissions" in metrics && typeof metrics.emissions === "number";
    }).map((s) => {
      const metrics = s.metrics || {};
      return {
        id: s.id,
        type: s.type,
        amount: metrics.emissions || 0,
        location: {
          districtId,
          coordinates: [0, 0]
        }
      };
    });
  }
  async calculateProjectProgress(project) {
    const metrics = this.districtMetrics.get(project.districtId);
    if (!metrics)
      return 0;
    switch (project.type) {
      case "green_space":
        return metrics.greenCoverage;
      case "emissions_reduction":
        return 1 - metrics.emissions;
      case "water_conservation":
        return this.calculateWaterQuality(metrics.waterQuality);
      case "waste_management":
        return metrics.wasteManagement;
      default:
        return 0.5;
    }
  }
  calculateWaterQuality(data) {
    return (data.ph + data.turbidity + data.dissolvedOxygen + data.conductivity) / 4;
  }
  async assessProjectImpact(project) {
    const metrics = this.districtMetrics.get(project.districtId);
    if (!metrics)
      return { environmental: 0, social: 0, economic: 0, overall: 0 };
    const environmental = metrics.sustainability;
    const social = 0.7;
    const economic = 0.6;
    return {
      environmental,
      social,
      economic,
      overall: (environmental + social + economic) / 3
    };
  }
  getActiveAlerts() {
    return this.activeAlerts;
  }
  async getEnvironmentalMetrics(districtId) {
    if (districtId) {
      const defaultMetrics = {
        airQuality: {
          pm25: 10,
          pm10: 20,
          no2: 40,
          o3: 30,
          aqi: 50
        },
        waterQuality: {
          ph: 7,
          turbidity: 0.5,
          dissolvedOxygen: 8,
          conductivity: 500,
          temperature: 20
        },
        noiseLevel: {
          decibels: 45,
          frequency: 1000,
          duration: 60,
          peakTime: Date.now(),
          source: "environmental_sensor"
        },
        greenCoverage: 0.4,
        biodiversity: {
          speciesCount: 100,
          habitatQuality: 0.6,
          ecosystemHealth: 0.7
        },
        emissions: 0.5,
        sustainability: 0.6,
        resourceEfficiency: 0.7,
        wasteManagement: 0.6,
        energyUsage: 0.5,
        water: {
          quality: (await this.measureWaterQuality(districtId)).score || 0.5,
          usage: await this.measureWaterUsage(districtId),
          conservation: await this.measureSystemValue(await this.smartInfrastructure.getDistrictInfrastructure(districtId), "water")
        },
        greenSpace: {
          coverage: await this.calculateGreenCoverage(districtId),
          quality: await this.measureSystemValue(await this.smartInfrastructure.getDistrictInfrastructure(districtId), "green"),
          accessibility: 0.7
        }
      };
      return this.districtMetrics.get(districtId) || defaultMetrics;
    }
    return this.districtMetrics;
  }
  async addSustainabilityProject(project) {
    this.sustainabilityProjects.set(project.id, project);
    this.emit("projectAdded", project);
  }
  async addGreenInitiative(initiative) {
    this.greenInitiatives.set(initiative.id, initiative);
    this.emit("initiativeAdded", initiative);
  }
  createAlert(alert) {
    this.activeAlerts.add(alert);
    this.emit("alertCreated", alert);
  }
  async resolveAlert(alertId) {
    const alert = Array.from(this.activeAlerts).find((a) => a.id === alertId);
    if (alert) {
      this.activeAlerts.delete(alert);
      this.emit("alertResolved", alert);
    }
  }
  async addEnvironmentalZone(zone) {
    this.environmentalZones.set(zone.id, zone);
    await this.vectorStore.upsert({
      id: `zone-${zone.id}`,
      values: await this.vectorStore.createEmbedding(`Environmental zone of type ${zone.type} in district ${zone.districtId}`),
      metadata: {
        type: "district",
        zoneId: zone.id,
        zoneType: zone.type,
        districtId: zone.districtId,
        status: zone.status,
        timestamp: Date.now()
      }
    });
    this.emit("zoneAdded", zone);
  }
  async addSmartSensor(sensor) {
    this.smartSensors.set(sensor.id, sensor);
    await this.vectorStore.upsert({
      id: `sensor-${sensor.id}`,
      values: await this.vectorStore.createEmbedding(`Environmental sensor of type ${sensor.type} in district ${sensor.location.districtId}`),
      metadata: {
        type: "district",
        sensorId: sensor.id,
        sensorType: sensor.type,
        districtId: sensor.location.districtId,
        status: sensor.status,
        timestamp: Date.now()
      }
    });
    this.emit("sensorAdded", sensor);
  }
  async getEnvironmentalZones(districtId) {
    const zones = Array.from(this.environmentalZones.values());
    return districtId ? zones.filter((z) => z.districtId === districtId) : zones;
  }
  async getSmartSensors(districtId) {
    const sensors = Array.from(this.smartSensors.values());
    return districtId ? sensors.filter((s) => s.location.districtId === districtId) : sensors;
  }
  async updateZoneStatus(zoneId, status) {
    const zone = this.environmentalZones.get(zoneId);
    if (zone) {
      zone.status = status;
      this.environmentalZones.set(zoneId, zone);
      this.emit("zoneUpdated", zone);
    }
  }
  async updateSensorStatus(sensorId, status) {
    const sensor = this.smartSensors.get(sensorId);
    if (sensor) {
      sensor.status = status;
      this.smartSensors.set(sensorId, sensor);
      this.emit("sensorUpdated", sensor);
    }
  }
  async updateSensorValue(sensorId, value2) {
    const sensor = this.smartSensors.get(sensorId);
    if (sensor) {
      sensor.value = value2;
      sensor.lastUpdate = Date.now();
      this.smartSensors.set(sensorId, sensor);
      this.emit("sensorValueUpdated", sensor);
    }
  }
  async monitorSensors() {
    for (const sensor of this.smartSensors.values()) {
      if (sensor.status === "active") {
        const value2 = await this.readSensorValue(sensor);
        await this.updateSensorValue(sensor.id, value2);
        await this.checkSensorAnomalies(sensor);
      }
    }
  }
  async readSensorValue(sensor) {
    const baseValue = 0.5;
    const noise = Math.random() * 0.2 - 0.1;
    return Math.max(0, Math.min(1, baseValue + noise));
  }
  async checkSensorAnomalies(sensor) {
    const threshold = this.getSensorThreshold(sensor.type);
    if (sensor.value > threshold.high || sensor.value < threshold.low) {
      this.createAlert({
        id: crypto.randomUUID(),
        type: this.getSensorAlertType(sensor.type),
        severity: sensor.value > threshold.critical ? "high" : "medium",
        location: sensor.location,
        timestamp: Date.now(),
        description: `Anomalous reading from ${sensor.type} sensor in district ${sensor.location.districtId}`,
        metrics: this.createAlertMetrics(sensor)
      });
    }
  }
  getSensorThreshold(type3) {
    switch (type3) {
      case "air_quality":
        return { low: 0.3, high: 0.7, critical: 0.8 };
      case "water_quality":
        return { low: 0.4, high: 0.8, critical: 0.9 };
      case "noise":
        return { low: 0.2, high: 0.6, critical: 0.7 };
      case "emissions":
        return { low: 0.3, high: 0.7, critical: 0.8 };
    }
  }
  getSensorAlertType(sensorType) {
    switch (sensorType) {
      case "air_quality":
        return "air";
      case "water_quality":
        return "water";
      case "noise":
        return "noise";
      case "emissions":
        return "green";
    }
  }
  createAlertMetrics(sensor) {
    switch (sensor.type) {
      case "air_quality":
        return {
          airQuality: {
            pm25: sensor.value * 500,
            pm10: sensor.value * 500,
            no2: sensor.value * 200,
            o3: sensor.value * 300,
            aqi: sensor.value * 500
          }
        };
      case "water_quality":
        return {
          waterQuality: {
            ph: 7 + (sensor.value - 0.5) * 2,
            turbidity: sensor.value,
            dissolvedOxygen: (1 - sensor.value) * 10,
            conductivity: sensor.value * 1000,
            temperature: 20 + (sensor.value - 0.5) * 10
          }
        };
      case "noise":
        return {
          noiseLevel: {
            decibels: sensor.value * 120,
            frequency: 1000 + sensor.value * 4000,
            duration: 60,
            peakTime: Date.now(),
            source: "environmental_sensor"
          }
        };
      default:
        return {};
    }
  }
}

// src/services/smart-infrastructure.service.ts
import { EventEmitter as EventEmitter15 } from "events";

class SmartInfrastructureService extends EventEmitter15 {
  vectorStore;
  metricsService;
  transportService;
  systems = new Map;
  districts = new Map;
  constructor(vectorStore, metricsService, transportService) {
    super();
    this.vectorStore = vectorStore;
    this.metricsService = metricsService;
    this.transportService = transportService;
    this.initializeMetricsTracking();
    this.setupEventListeners();
  }
  setupEventListeners() {
    this.transportService?.on("metricsUpdated", (transportMetrics) => {
      this.updateInfrastructureMetrics(transportMetrics);
    });
  }
  initializeMetricsTracking() {
    setInterval(() => this.updateInfrastructureMetrics(), 5 * 60 * 1000);
  }
  async updateInfrastructureMetrics(transportMetrics) {
    const powerSystems = Array.from(this.systems.values()).filter((s) => s.type === "power");
    const waterSystems = Array.from(this.systems.values()).filter((s) => s.type === "water");
    const avgPowerEfficiency = powerSystems.length ? powerSystems.reduce((sum, s) => sum + s.metrics.efficiency, 0) / powerSystems.length : 0.8;
    const avgWaterEfficiency = waterSystems.length ? waterSystems.reduce((sum, s) => sum + s.metrics.efficiency, 0) / waterSystems.length : 0.8;
    const transportSystems = Array.from(this.systems.values()).filter((s) => s.type === "transportation");
    const avgTransportEfficiency = transportMetrics ? transportMetrics.efficiency : transportSystems.reduce((sum, s) => sum + s.metrics.efficiency, 0) / Math.max(transportSystems.length, 1);
    await this.metricsService.updateMetrics({
      infrastructure: {
        trafficCongestion: transportMetrics ? transportMetrics.congestion : 1 - avgTransportEfficiency,
        publicTransitReliability: transportMetrics ? transportMetrics.reliability : avgTransportEfficiency,
        wasteRecyclingRate: 0.6,
        infrastructureHealth: (avgTransportEfficiency + avgPowerEfficiency + avgWaterEfficiency) / 3,
        smartGridEfficiency: avgPowerEfficiency
      }
    });
  }
  async getSystemStatus() {
    return Array.from(this.systems.values());
  }
  async getDistrictInfrastructure(districtId) {
    const systems = Array.from(this.systems.values()).filter((system2) => system2.location.districtId === districtId);
    return {
      id: `infra-${districtId}`,
      districtId,
      systems,
      status: "operational",
      lastUpdate: Date.now(),
      resources: {
        water: {
          consumption: this.calculateResourceConsumption(systems, "water"),
          capacity: this.calculateResourceCapacity(systems, "water")
        },
        power: {
          consumption: this.calculateResourceConsumption(systems, "power"),
          capacity: this.calculateResourceCapacity(systems, "power")
        },
        data: {
          usage: this.calculateResourceConsumption(systems, "digital"),
          capacity: this.calculateResourceCapacity(systems, "digital")
        }
      }
    };
  }
  calculateResourceConsumption(systems, type3) {
    const typeSystems = systems.filter((s) => s.type === type3);
    return typeSystems.reduce((sum, s) => sum + (s.consumption || 0), 0);
  }
  calculateResourceCapacity(systems, type3) {
    const typeSystems = systems.filter((s) => s.type === type3);
    return typeSystems.reduce((sum, s) => sum + (s.generation || 100), 0);
  }
  calculateTransportationScore(systems) {
    const transportSystems = systems.filter((s) => s.type === "transportation" || s.type === "traffic");
    return transportSystems.length > 0 ? transportSystems.reduce((sum, s) => sum + s.metrics.efficiency, 0) / transportSystems.length : 0.5;
  }
  calculateDigitalConnectivity(systems) {
    const digitalSystems = systems.filter((s) => s.type === "digital");
    return digitalSystems.length > 0 ? digitalSystems.reduce((sum, s) => sum + (s.metrics.connectivity || 0), 0) / digitalSystems.length : 0.5;
  }
  calculatePedestrianAccess(systems) {
    const accessSystems = systems.filter((s) => s.type === "pedestrian");
    return accessSystems.length > 0 ? accessSystems.reduce((sum, s) => sum + (s.metrics.accessibility || 0), 0) / accessSystems.length : 0.5;
  }
  async getNearbyInfrastructure(coordinates) {
    try {
      const results = await this.vectorStore.query({
        vector: await this.vectorStore.createEmbedding(`infrastructure near ${coordinates.join(",")}`),
        filter: {
          type: { $eq: "infrastructure" }
        },
        topK: 5
      });
      if (!results.matches?.length)
        return null;
      return {
        type: results.matches[0].metadata.type,
        status: results.matches[0].metadata.status,
        coordinates: JSON.parse(results.matches[0].metadata.coordinates)
      };
    } catch (error4) {
      console.error("Error getting nearby infrastructure:", error4);
      return null;
    }
  }
}

// src/services/spatial-coordination.service.ts
import { EventEmitter as EventEmitter16 } from "events";
class SpatialCoordinationService extends EventEmitter16 {
  vectorStore;
  districtService;
  emergencyService;
  locationNodes = new Map;
  agentLocations = new Map;
  eventBus;
  constructor(vectorStore, districtService, emergencyService) {
    super();
    this.vectorStore = vectorStore;
    this.districtService = districtService;
    this.emergencyService = emergencyService;
    this.eventBus = EventBus.getInstance();
    this.initializeCoordinateSystem();
    this.setupEventListeners();
  }
  setupEventListeners() {
    this.eventBus.on("emergencyAlert", this.handleEmergency.bind(this));
    this.eventBus.on("congestionDetected", this.optimizeTraffic.bind(this));
    this.eventBus.on("aiSystemUpdate", this.updateAINodes.bind(this));
  }
  async moveAgent(agentId, targetLocation) {
    const currentLocation = this.agentLocations.get(agentId);
    if (!currentLocation)
      return false;
    const movementPlan = await this.calculateMovementPlan(currentLocation, targetLocation);
    if (movementPlan.congestionLevel > 0.8) {
      await this.handleHighCongestion(movementPlan);
    }
    await this.executeAgentMovement(agentId, movementPlan);
    await this.recordMovement(agentId, currentLocation, targetLocation);
    return true;
  }
  async calculateMovementPlan(start, end) {
    const path = await this.findOptimalPath(start, end);
    const smartIntersections = this.findSmartIntersectionsOnPath(path);
    const congestionLevel = await this.analyzeCongestion(path);
    const alternativeRoutes = congestionLevel > 0.6 ? await this.findAlternativeRoutes(start, end) : [];
    return {
      path,
      estimatedTime: this.calculateEstimatedTime(path, congestionLevel),
      congestionLevel,
      alternativeRoutes,
      smartIntersections
    };
  }
  async findOptimalPath(start, end) {
    const nodes = Array.from(this.locationNodes.values());
    const graph = this.buildNavigationGraph(nodes);
    return this.aStarPathfinding(start, end, graph);
  }
  async analyzeCongestion(path) {
    const agentDensity = await this.calculateAgentDensity(path);
    const trafficFlow = await this.analyzeTrafficFlow(path);
    return (agentDensity + trafficFlow) / 2;
  }
  async handleHighCongestion(plan) {
    const optimizedRoute = await this.optimizeRoute(plan);
    this.eventBus.emit("congestionHandled", {
      area: plan.path[0],
      congestionLevel: plan.congestionLevel,
      optimizedRoute
    });
  }
  async recordMovement(agentId, from, to) {
    await this.vectorStore.upsert({
      id: `movement-${agentId}-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(`Agent ${agentId} movement from (${from.x},${from.y}) to (${to.x},${to.y})`),
      metadata: {
        type: "transport",
        agentId,
        fromLocation: JSON.stringify(from),
        toLocation: JSON.stringify(to),
        timestamp: Date.now()
      }
    });
  }
  async getClosestEmergencyPoint(coordinates) {
    const emergencyNodes = Array.from(this.locationNodes.values()).filter((node) => node.type === "emergency_point");
    return this.findClosestNode(coordinates, emergencyNodes);
  }
  async findOptimalMeetingPoint(agents2) {
    const agentLocations = agents2.map((id) => this.agentLocations.get(id)).filter((loc) => !!loc);
    if (agentLocations.length === 0)
      return null;
    const centroid = this.calculateCentroid(agentLocations);
    const meetingNodes = Array.from(this.locationNodes.values()).filter((node) => node.type === "meeting_point" && node.currentOccupancy < node.capacity && this.isNodeAvailable(node));
    return this.findClosestNode(centroid, meetingNodes);
  }
  async initializeCoordinateSystem() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      await this.createDistrictNodes(district);
    }
    await this.connectNodes();
    await this.initializeAIHubs();
  }
  async createDistrictNodes(district) {
    const center = this.calculateDistrictCenter(district.boundaries);
    const centerNode = {
      id: `center-${district.id}`,
      type: "district_center",
      coordinates: center,
      districtId: district.id,
      capacity: 100,
      currentOccupancy: 0,
      connections: [],
      smartFeatures: {
        trafficControl: true,
        environmentalMonitoring: true,
        emergencyResponse: true,
        crowdManagement: true
      }
    };
    const aiHub = {
      id: `ai-hub-${district.id}`,
      type: "ai_hub",
      coordinates: {
        x: center.x + 0.05,
        y: center.y + 0.05
      },
      districtId: district.id,
      capacity: 50,
      currentOccupancy: 0,
      connections: [centerNode.id],
      aiMetrics: {
        processingPower: 100,
        bandwidth: 1000,
        utilizationRate: 0,
        efficiency: 1
      }
    };
    this.locationNodes.set(centerNode.id, centerNode);
    this.locationNodes.set(aiHub.id, aiHub);
  }
  calculateDistrictCenter(boundaries) {
    const sumX = boundaries.reduce((sum, coord) => sum + coord[0], 0);
    const sumY = boundaries.reduce((sum, coord) => sum + coord[1], 0);
    return {
      x: sumX / boundaries.length,
      y: sumY / boundaries.length
    };
  }
  async handleEmergency(alert) {
    const nearbyNodes = this.findNodesInRadius(alert.location, 1);
    for (const node of nearbyNodes) {
      node.smartFeatures.emergencyResponse = true;
      this.eventBus.emit("nodeStateChanged", {
        nodeId: node.id,
        type: "emergency_mode",
        active: true
      });
    }
  }
  async optimizeTraffic(congestionData) {
    const affectedArea = congestionData.area;
    const nodes = this.findNodesInRadius(affectedArea, 0.5);
    for (const node of nodes) {
      if (node.smartFeatures?.trafficControl) {
        await this.adjustTrafficControl(node, congestionData);
      }
    }
  }
  async updateAINodes(update) {
    const aiHubs = Array.from(this.locationNodes.values()).filter((node) => node.type === "ai_hub");
    for (const hub of aiHubs) {
      hub.aiMetrics = {
        ...hub.aiMetrics,
        utilizationRate: update.utilizationRate,
        efficiency: update.efficiency
      };
    }
  }
  findNodesInRadius(center, radius) {
    return Array.from(this.locationNodes.values()).filter((node) => this.calculateDistance(center, node.coordinates) <= radius);
  }
  async adjustTrafficControl(node, congestionData) {
    this.eventBus.emit("trafficControlAdjusted", {
      nodeId: node.id,
      adjustments: {
        signalTiming: congestionData.recommendedTiming,
        routeDiversion: congestionData.alternativeRoutes
      }
    });
  }
  isNodeAvailable(node) {
    return node.currentOccupancy < node.capacity * 0.8 && (!node.aiMetrics || node.aiMetrics.utilizationRate < 0.9);
  }
  findClosestNode(point, nodes) {
    return nodes.reduce((closest, current) => {
      const currentDistance = this.calculateDistance(point, current.coordinates);
      const closestDistance = closest ? this.calculateDistance(point, closest.coordinates) : Infinity;
      return currentDistance < closestDistance ? current : closest;
    }, null);
  }
  calculateDistance(point1, point2) {
    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
  }
  calculateCentroid(points) {
    const sum = points.reduce((acc, point) => ({
      x: acc.x + point.x,
      y: acc.y + point.y
    }), { x: 0, y: 0 });
    return {
      x: sum.x / points.length,
      y: sum.y / points.length
    };
  }
  async executeAgentMovement(agentId, plan) {
    for (const point of plan.path) {
      this.agentLocations.set(agentId, point);
      this.emit("agentMoved", {
        agentId,
        location: point,
        congestion: plan.congestionLevel,
        estimatedTimeRemaining: plan.estimatedTime
      });
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  findSmartIntersectionsOnPath(path) {
    return Array.from(this.locationNodes.values()).filter((node) => node.type === "smart_intersection" && path.some((point) => this.calculateDistance(point, node.coordinates) < 0.1)).map((node) => node.id);
  }
  async findAlternativeRoutes(start, end) {
    const mainPath = await this.findOptimalPath(start, end);
    const alternatives = [];
    const midPoints = Array.from(this.locationNodes.values()).filter((node) => node.type === "transport_hub" && this.calculateDistance(node.coordinates, start) < this.calculateDistance(start, end));
    for (const point of midPoints) {
      const route1 = await this.findOptimalPath(start, point.coordinates);
      const route2 = await this.findOptimalPath(point.coordinates, end);
      alternatives.push([...route1, ...route2]);
    }
    return alternatives;
  }
  calculateEstimatedTime(path, congestion) {
    const baseTime = path.reduce((time, point, index) => {
      if (index === 0)
        return 0;
      return time + this.calculateDistance(path[index - 1], point) * 100;
    }, 0);
    return baseTime * (1 + congestion);
  }
  buildNavigationGraph(nodes) {
    const graph = new Map;
    nodes.forEach((node) => {
      const connections = new Set;
      nodes.forEach((other) => {
        if (node.id !== other.id && this.calculateDistance(node.coordinates, other.coordinates) < 1) {
          connections.add(other.id);
        }
      });
      graph.set(node.id, connections);
    });
    return graph;
  }
  aStarPathfinding(start, end, graph) {
    return [start, end];
  }
  async calculateAgentDensity(path) {
    const nearbyAgents = Array.from(this.agentLocations.entries()).filter(([_3, location]) => path.some((point) => this.calculateDistance(point, location) < 0.5));
    return nearbyAgents.length / (path.length * 0.5);
  }
  async analyzeTrafficFlow(path) {
    const trafficNodes = path.map((point) => Array.from(this.locationNodes.values()).find((node) => node.type === "smart_intersection" && this.calculateDistance(point, node.coordinates) < 0.1)).filter((node) => !!node);
    return trafficNodes.reduce((flow, node) => flow + node.currentOccupancy / node.capacity, 0) / Math.max(trafficNodes.length, 1);
  }
  async optimizeRoute(plan) {
    if (plan.alternativeRoutes.length === 0)
      return plan.path;
    const routeScores = await Promise.all(plan.alternativeRoutes.map(async (route) => ({
      route,
      score: await this.calculateRouteScore(route)
    })));
    const bestRoute = routeScores.reduce((best, current) => current.score > best.score ? current : best);
    return bestRoute.route;
  }
  async calculateRouteScore(route) {
    const distance = route.reduce((total, point, index) => {
      if (index === 0)
        return 0;
      return total + this.calculateDistance(route[index - 1], point);
    }, 0);
    const congestion = await this.analyzeCongestion(route);
    const smartIntersections = this.findSmartIntersectionsOnPath(route).length;
    return 1 / distance * (1 - congestion) * (1 + smartIntersections * 0.1);
  }
  async connectNodes() {
    const nodes = Array.from(this.locationNodes.values());
    for (const node of nodes) {
      const nearbyNodes = nodes.filter((other) => other.id !== node.id && this.calculateDistance(node.coordinates, other.coordinates) < 1);
      node.connections = nearbyNodes.map((n) => n.id);
    }
  }
  async initializeAIHubs() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const center = this.calculateDistrictCenter(district.boundaries);
      const aiHub = {
        id: `ai-hub-${district.id}`,
        type: "ai_hub",
        coordinates: {
          x: center.x + 0.05,
          y: center.y + 0.05
        },
        districtId: district.id,
        capacity: 50,
        currentOccupancy: 0,
        connections: [],
        aiMetrics: {
          processingPower: 100,
          bandwidth: 1000,
          utilizationRate: 0,
          efficiency: 1
        }
      };
      this.locationNodes.set(aiHub.id, aiHub);
    }
  }
}

// src/services/emergency.service.ts
import { EventEmitter as EventEmitter17 } from "events";
class EmergencyService extends EventEmitter17 {
  vectorStore;
  departmentService;
  citizenService;
  activeEmergencies = new Map;
  emergencyUnits = new Map;
  constructor(vectorStore, departmentService, citizenService) {
    super();
    this.vectorStore = vectorStore;
    this.departmentService = departmentService;
    this.citizenService = citizenService;
    this.initializeEmergencyUnits();
  }
  async initializeEmergencyUnits() {
    const types2 = [
      "medical" /* MEDICAL */,
      "fire" /* FIRE */,
      "police" /* POLICE */,
      "disaster" /* DISASTER */,
      "infrastructure" /* INFRASTRUCTURE */,
      "environmental" /* ENVIRONMENTAL */
    ];
    types2.forEach((type3) => {
      for (let i = 0;i < 3; i++) {
        const unit = {
          id: `${type3}-unit-${i}`,
          type: type3,
          status: "available",
          location: {
            districtId: "central",
            coordinates: [0, 0]
          },
          capabilities: this.getUnitCapabilities(type3),
          personnel: this.getPersonnelCount(type3)
        };
        this.emergencyUnits.set(unit.id, unit);
      }
    });
  }
  async handleEmergency(incident) {
    this.activeEmergencies.set(incident.id, incident);
    await this.vectorStore.upsert({
      id: `emergency-${incident.id}`,
      values: await this.vectorStore.createEmbedding(`${incident.type} emergency in ${incident.location.districtId}: ${incident.description}`),
      metadata: {
        type: "district",
        emergencyId: incident.id,
        emergencyType: incident.type,
        priority: incident.priority,
        timestamp: incident.timestamp
      }
    });
    const nearbyUnits = await this.findNearestUnits(incident.location);
    const response = await this.calculateOptimalResponse(incident, nearbyUnits);
    await this.dispatchUnits(response.units);
    await this.notifyNearbyResidents(incident.affectedArea);
    this.emit("emergencyResponse", { incident, response });
  }
  async findNearestUnits(location) {
    const availableUnits = Array.from(this.emergencyUnits.values()).filter((unit) => unit.status === "available");
    return availableUnits.map((unit) => ({
      ...unit,
      estimatedResponseTime: this.calculateResponseTime(unit.location, location)
    })).sort((a, b) => (a.estimatedResponseTime || 0) - (b.estimatedResponseTime || 0));
  }
  async calculateOptimalResponse(incident, availableUnits) {
    const requiredUnits = this.determineRequiredUnits(incident);
    const selectedUnits = availableUnits.filter((unit) => unit.type === incident.type).slice(0, requiredUnits);
    return {
      units: selectedUnits,
      estimatedResponseTime: Math.max(...selectedUnits.map((u) => u.estimatedResponseTime || 0))
    };
  }
  async dispatchUnits(units) {
    units.forEach((unit) => {
      const storedUnit = this.emergencyUnits.get(unit.id);
      if (storedUnit) {
        storedUnit.status = "responding";
        this.emergencyUnits.set(unit.id, storedUnit);
      }
    });
    const departmentIds = await this.getDepartmentsForEmergency(units[0].type);
    departmentIds.forEach(async (deptId) => {
      await this.departmentService.addActivity(deptId, {
        type: "emergency_response",
        units: units.map((u) => u.id),
        timestamp: Date.now()
      });
    });
  }
  async notifyNearbyResidents(affectedArea) {
    this.emit("emergencyAlert", { affectedArea });
  }
  calculateResponseTime(unitLocation, emergencyLocation) {
    const distance = Math.sqrt(Math.pow(unitLocation.coordinates[0] - emergencyLocation.coordinates[0], 2) + Math.pow(unitLocation.coordinates[1] - emergencyLocation.coordinates[1], 2));
    return distance * 2;
  }
  determineRequiredUnits(incident) {
    switch (incident.priority) {
      case "critical":
        return 3;
      case "high":
        return 2;
      case "medium":
        return 1;
      case "low":
        return 1;
      default:
        return 1;
    }
  }
  getUnitCapabilities(type3) {
    const capabilities = {
      ["medical" /* MEDICAL */]: ["first_aid", "ambulance", "paramedic"],
      ["fire" /* FIRE */]: ["fire_fighting", "rescue", "hazmat"],
      ["police" /* POLICE */]: ["patrol", "investigation", "crowd_control"],
      ["disaster" /* DISASTER */]: ["evacuation", "rescue", "coordination"],
      ["infrastructure" /* INFRASTRUCTURE */]: ["repair", "maintenance", "assessment"],
      ["environmental" /* ENVIRONMENTAL */]: ["containment", "cleanup", "monitoring"],
      ["weather" /* WEATHER */]: ["monitoring", "warning", "response"],
      ["accident" /* ACCIDENT */]: ["investigation", "rescue", "cleanup"],
      ["security" /* SECURITY */]: ["patrol", "surveillance", "response"],
      ["health" /* HEALTH */]: ["medical_care", "quarantine", "treatment"]
    };
    return capabilities[type3];
  }
  getPersonnelCount(type3) {
    const counts = {
      ["medical" /* MEDICAL */]: 3,
      ["fire" /* FIRE */]: 4,
      ["police" /* POLICE */]: 2,
      ["disaster" /* DISASTER */]: 5,
      ["infrastructure" /* INFRASTRUCTURE */]: 3,
      ["environmental" /* ENVIRONMENTAL */]: 3,
      ["weather" /* WEATHER */]: 2,
      ["accident" /* ACCIDENT */]: 3,
      ["security" /* SECURITY */]: 2,
      ["health" /* HEALTH */]: 3
    };
    return counts[type3];
  }
  async getDepartmentsForEmergency(type3) {
    const departments = await this.departmentService.getAllDepartments();
    return departments.filter((dept) => {
      switch (type3) {
        case "medical" /* MEDICAL */:
        case "fire" /* FIRE */:
        case "police" /* POLICE */:
          return dept.type === "emergency_response";
        case "infrastructure" /* INFRASTRUCTURE */:
          return dept.type === "infrastructure";
        case "environmental" /* ENVIRONMENTAL */:
          return dept.type === "environmental";
        default:
          return dept.type === "public_safety";
      }
    }).map((dept) => dept.id);
  }
}

// src/services/city-memory.service.ts
var import_lodash3 = __toESM(require_lodash2(), 1);
import { EventEmitter as EventEmitter18 } from "events";

class CityMemoryService extends EventEmitter18 {
  vectorStore;
  culturalService;
  landmarkService;
  districtService;
  smartInfrastructureService;
  analyticsService;
  memoryCache = new Map;
  CACHE_DURATION = 60 * 60 * 1000;
  SIGNIFICANCE_THRESHOLD = 0.7;
  memoryAgent = {
    id: "city-memory",
    name: "Memory Service",
    personality: "Analytical and preservative",
    systemPrompt: "Manage and preserve city memories and cultural heritage",
    interests: ["cultural preservation", "history", "community memory"],
    preferredStyle: "formal",
    memoryWindowSize: 1000,
    emotionalRange: { min: 0.3, max: 0.8 },
    traits: {
      analyticalThinking: 0.8,
      creativity: 0.6,
      empathy: 0.7,
      curiosity: 0.9,
      enthusiasm: 0.6,
      reliability: 0.9,
      environmentalAwareness: 0.7
    }
  };
  constructor(vectorStore, culturalService, landmarkService, districtService, smartInfrastructureService, analyticsService) {
    super();
    this.vectorStore = vectorStore;
    this.culturalService = culturalService;
    this.landmarkService = landmarkService;
    this.districtService = districtService;
    this.smartInfrastructureService = smartInfrastructureService;
    this.analyticsService = analyticsService;
    this.initializeMemoryService();
  }
  async initializeMemoryService() {
    this.analyticsService.trackInteraction(this.memoryAgent, {
      id: crypto.randomUUID(),
      agentId: this.memoryAgent.id,
      content: "City Memory Service initialized",
      timestamp: Date.now(),
      role: "assistant",
      sentiment: 0.8,
      topics: ["memory", "initialization"]
    });
    setInterval(() => this.analyzeCityMemoryPatterns(), 24 * 60 * 60 * 1000);
    setInterval(() => this.updateMemoryPreservationPriorities(), 12 * 60 * 60 * 1000);
    this.districtService.on("districtUpdated", this.handleDistrictUpdate.bind(this));
    this.smartInfrastructureService.on("infrastructureChange", this.handleInfrastructureChange.bind(this));
  }
  async handleDistrictUpdate(districtEvent) {
    const districtMemories = await this.getDistrictMemories(districtEvent.districtId);
    for (const memory of districtMemories.memories) {
      await this.updateMemoryContext(memory, districtEvent);
    }
  }
  async handleInfrastructureChange(change) {
    const affectedMemories = await this.findMemoriesByLocation(change.location);
    for (const memory of affectedMemories) {
      await this.updateLocationContext(memory, change);
    }
  }
  async updateMemoryContext(memory, districtEvent) {
    const updatedMemory = { ...memory };
    const district = await this.districtService.getDistrict(memory.districtId);
    if (district) {
      updatedMemory.culturalSignificance = this.recalculateSignificance(memory, district);
      await this.storeCollectiveMemory(updatedMemory);
    }
    this.analyticsService.trackInteraction(this.memoryAgent, {
      id: crypto.randomUUID(),
      agentId: this.memoryAgent.id,
      content: `Updated memory context for ${memory.type} memory`,
      timestamp: Date.now(),
      role: "assistant",
      sentiment: 0.6,
      topics: ["memory", "context", "update"]
    });
  }
  async updateLocationContext(memory, infrastructureChange) {
    const locationData = await this.getInfrastructureData(memory.location?.coordinates || [0, 0]);
    if (locationData?.nearestLandmark) {
      memory.location = {
        coordinates: memory.location?.coordinates || [0, 0],
        landmark: locationData.nearestLandmark
      };
      await this.storeCollectiveMemory(memory);
    }
  }
  async getInfrastructureData(coordinates) {
    try {
      const nearbyInfrastructure = await this.smartInfrastructureService.getNearbyInfrastructure(coordinates);
      const landmarks = await this.landmarkService.getAllLandmarks();
      const nearestLandmark = landmarks.find((l) => this.calculateDistance(coordinates, l.coordinates) < 1000);
      return {
        nearestLandmark: nearestLandmark?.name,
        coordinates,
        type: nearbyInfrastructure?.type,
        status: nearbyInfrastructure?.status
      };
    } catch (error4) {
      console.error("Error getting infrastructure data:", error4);
      return {};
    }
  }
  async getDistrictMetrics(districtId) {
    try {
      const district = await this.districtService.getDistrict(districtId);
      const culturalData = await this.culturalService.getDistrictCulture(districtId);
      return {
        culturalIndex: culturalData?.culturalIndex || 1,
        socialIndex: district?.socialMetrics?.index || 1,
        economicIndex: district?.economicMetrics?.index || 1
      };
    } catch (error4) {
      console.error("Error getting district metrics:", error4);
      return {
        culturalIndex: 1,
        socialIndex: 1,
        economicIndex: 1
      };
    }
  }
  async findMemoriesByLocation(coordinates) {
    const nearbyMemories = await this.vectorStore.query({
      vector: await this.vectorStore.createEmbedding(`location memories ${coordinates.join(",")}`),
      filter: {
        type: { $eq: "district" },
        subtype: { $eq: "collective_memory" }
      },
      topK: 10
    });
    return this.processMemoryResults(nearbyMemories.matches);
  }
  recalculateSignificance(memory, district) {
    const baseSignificance = memory.culturalSignificance;
    const districtFactor = district.culturalImportance || 1;
    const timeFactor = this.calculateTemporalRelevance(memory.timestamp);
    return baseSignificance * 0.5 + districtFactor * 0.3 + timeFactor * 0.2;
  }
  async analyzeCityMemoryPatterns() {
    try {
      const allMemories = await this.getAllStoredMemories();
      const patterns3 = this.analyzeTemporalPatterns(allMemories);
      this.emit("memoryPatternsAnalyzed", {
        patterns: patterns3,
        timestamp: Date.now()
      });
    } catch (error4) {
      console.error("Error analyzing memory patterns:", error4);
    }
  }
  async getAllStoredMemories() {
    try {
      const results = await this.vectorStore.query({
        vector: await this.vectorStore.createEmbedding("all city memories"),
        filter: {
          type: { $eq: "district" },
          subtype: { $eq: "collective_memory" }
        },
        topK: 1000
      });
      if (!results.matches) {
        return [];
      }
      return results.matches.map((match) => ({
        type: match.metadata.type,
        description: match.metadata.description,
        districtId: match.metadata.districtId,
        timestamp: match.metadata.timestamp,
        emotionalImpact: match.metadata.impact,
        participants: JSON.parse(match.metadata.participants || "[]"),
        culturalSignificance: match.metadata.significance
      }));
    } catch (error4) {
      console.error("Error retrieving stored memories:", error4);
      throw error4;
    }
  }
  async updateMemoryPreservationPriorities() {
    try {
      const allMemories = await this.getAllStoredMemories();
      for (const memory of allMemories) {
        const analytics = await this.analyzeMemory(memory);
        const priority = this.calculatePreservationPriority(analytics.significance, analytics.relevance, analytics.communityImpact);
        if (priority >= this.SIGNIFICANCE_THRESHOLD) {
          await this.initiatePreservationProtocol(memory);
        }
      }
    } catch (error4) {
      console.error("Error updating preservation priorities:", error4);
    }
  }
  async storeCollectiveMemory(memory) {
    try {
      this.analyticsService.trackInteraction(this.memoryAgent, {
        id: crypto.randomUUID(),
        agentId: this.memoryAgent.id,
        content: `Storing ${memory.type} memory: ${memory.description}`,
        timestamp: Date.now(),
        role: "assistant",
        sentiment: 0.7,
        topics: ["memory", "storage", memory.type]
      });
      const district = await this.districtService.getDistrict(memory.districtId);
      if (district) {
        const districtMetrics = await this.getDistrictMetrics(memory.districtId);
        memory.culturalSignificance *= districtMetrics.culturalIndex;
      }
      if (memory.location) {
        const infrastructureData = await this.getInfrastructureData(memory.location.coordinates);
        if (infrastructureData.nearestLandmark) {
          memory.location.landmark = infrastructureData.nearestLandmark;
        }
      }
      const enrichedMemory = await this.enrichMemoryContext(memory);
      const analytics = await this.analyzeMemory(enrichedMemory);
      await this.vectorStore.upsert({
        id: `city-memory-${Date.now()}`,
        values: await this.vectorStore.createEmbedding(`${enrichedMemory.type}: ${enrichedMemory.description} ${enrichedMemory.tags?.join(" ")}`),
        metadata: {
          type: "district",
          subtype: "collective_memory",
          districtId: enrichedMemory.districtId,
          impact: enrichedMemory.emotionalImpact,
          significance: enrichedMemory.culturalSignificance,
          timestamp: enrichedMemory.timestamp,
          analytics: JSON.stringify(analytics)
        }
      });
      this.memoryCache.delete(enrichedMemory.districtId);
      this.emit("memoryStored", {
        memory: enrichedMemory,
        analytics
      });
      if (analytics.significance > this.SIGNIFICANCE_THRESHOLD) {
        await this.initiatePreservationProtocol(enrichedMemory);
      }
    } catch (error4) {
      console.error("Error storing collective memory:", error4);
      throw error4;
    }
  }
  async getDistrictMemories(districtId, options = {}) {
    try {
      const cached = this.memoryCache.get(districtId);
      if (cached && !this.isCacheStale(districtId)) {
        return this.filterMemories(cached, options);
      }
      const embedding = await this.vectorStore.createEmbedding(`district ${districtId} collective memories ${options.type || ""}`);
      const results = await this.vectorStore.query({
        vector: embedding,
        filter: {
          type: { $eq: "district" },
          subtype: { $eq: "collective_memory" },
          districtId: { $eq: districtId }
        },
        topK: 100
      });
      const memories = await this.processMemoryResults(results.matches);
      const collection = await this.analyzeMemoryCollection(memories);
      this.memoryCache.set(districtId, collection);
      return this.filterMemories(collection, options);
    } catch (error4) {
      console.error("Error retrieving district memories:", error4);
      throw error4;
    }
  }
  async enrichMemoryContext(memory) {
    const tags = await this.generateMemoryTags(memory);
    const relatedMemories = await this.findRelatedMemories(memory);
    const location = memory.location || await this.inferMemoryLocation(memory);
    return {
      ...memory,
      tags,
      relatedMemories: relatedMemories.map((m) => m.id),
      location
    };
  }
  async generateMemoryTags(memory) {
    const tags = new Set;
    tags.add(memory.type);
    const themes = await this.extractThemes(memory.description);
    themes.forEach((theme) => tags.add(theme));
    memory.participants.forEach((participant) => {
      tags.add(`participant:${participant}`);
    });
    const timeContext = this.getTemporalContext(memory.timestamp);
    tags.add(timeContext);
    return Array.from(tags);
  }
  async extractThemes(text) {
    const themes = new Set;
    const themePatterns = {
      celebration: /celebrat|festival|ceremony|gathering/i,
      conflict: /conflict|dispute|resolution|challenge/i,
      progress: /development|improvement|growth|innovation/i,
      tradition: /tradition|heritage|cultural|ancestral/i,
      change: /transform|change|evolution|adapt/i
    };
    Object.entries(themePatterns).forEach(([theme, pattern2]) => {
      if (pattern2.test(text)) {
        themes.add(theme);
      }
    });
    return Array.from(themes);
  }
  getTemporalContext(timestamp) {
    const date4 = new Date(timestamp);
    const currentYear = new Date().getFullYear();
    const years = currentYear - date4.getFullYear();
    if (years < 1)
      return "recent";
    if (years < 5)
      return "recent-past";
    if (years < 20)
      return "modern-history";
    if (years < 50)
      return "historical";
    return "ancient";
  }
  async analyzeMemory(memory) {
    const significance = this.calculateSignificance(memory);
    const relevance = await this.assessRelevance(memory);
    const communityImpact = await this.assessCommunityImpact(memory);
    const preservationPriority = this.calculatePreservationPriority(significance, relevance, communityImpact);
    return {
      significance,
      relevance,
      communityImpact,
      preservationPriority
    };
  }
  calculateSignificance(memory) {
    return memory.culturalSignificance * 0.4 + memory.emotionalImpact * 0.3 + memory.participants.length / 100 * 0.3;
  }
  async assessRelevance(memory) {
    const temporalRelevance = this.calculateTemporalRelevance(memory.timestamp);
    const thematicRelevance = await this.calculateThematicRelevance(memory);
    return (temporalRelevance + thematicRelevance) / 2;
  }
  calculateTemporalRelevance(timestamp) {
    const age = Date.now() - timestamp;
    const maxAge = 100 * 365 * 24 * 60 * 60 * 1000;
    return Math.min(1, Math.max(0.3, 1 - age / maxAge));
  }
  async calculateThematicRelevance(memory) {
    const themes = await this.extractThemes(memory.description);
    const relevantThemes = themes.filter((theme) => this.isThemeCurrentlyRelevant(theme));
    return relevantThemes.length / Math.max(themes.length, 1);
  }
  isThemeCurrentlyRelevant(theme) {
    const currentThemes = new Set([
      "celebration",
      "progress",
      "tradition",
      "change"
    ]);
    return currentThemes.has(theme);
  }
  async assessCommunityImpact(memory) {
    const participantImpact = memory.participants.length / 100;
    const emotionalResonance = memory.emotionalImpact;
    const culturalSignificance = memory.culturalSignificance;
    return participantImpact * 0.3 + emotionalResonance * 0.3 + culturalSignificance * 0.4;
  }
  calculatePreservationPriority(significance, relevance, communityImpact) {
    return significance * 0.4 + relevance * 0.3 + communityImpact * 0.3;
  }
  async findRelatedMemories(memory) {
    const embedding = await this.vectorStore.createEmbedding(`${memory.type} ${memory.description}`);
    const results = await this.vectorStore.query({
      vector: embedding,
      filter: {
        type: { $eq: "district" },
        subtype: { $eq: "collective_memory" },
        districtId: { $eq: memory.districtId }
      },
      topK: 5
    });
    return results.matches.map((match) => ({
      id: match.id,
      similarity: match.score
    }));
  }
  async inferMemoryLocation(memory) {
    const locationMentions = await this.extractLocationMentions(memory.description);
    if (locationMentions.length > 0) {
      return {
        coordinates: locationMentions[0].coordinates,
        landmark: locationMentions[0].name
      };
    }
    return {
      coordinates: [0, 0]
    };
  }
  async extractLocationMentions(text) {
    const mentions = [];
    const landmarks = await this.landmarkService.getAllLandmarks();
    const lowerText = text.toLowerCase();
    for (const landmark of landmarks) {
      if (lowerText.includes(landmark.name.toLowerCase())) {
        mentions.push({
          name: landmark.name,
          coordinates: landmark.coordinates
        });
      }
    }
    await this.vectorStore.upsert({
      id: `location-mentions-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(text),
      metadata: {
        type: "district",
        mentions: mentions.map((m) => m.name).join(","),
        timestamp: Date.now()
      }
    });
    return mentions;
  }
  async processMemoryResults(matches) {
    return matches.map((match) => ({
      type: match.metadata.type,
      description: match.metadata.description,
      districtId: match.metadata.districtId,
      timestamp: match.metadata.timestamp,
      emotionalImpact: match.metadata.impact,
      participants: JSON.parse(match.metadata.participants || "[]"),
      culturalSignificance: match.metadata.significance
    }));
  }
  async analyzeMemoryCollection(memories) {
    const typeDistribution = import_lodash3.default.countBy(memories, "type");
    const averageImpact = import_lodash3.default.meanBy(memories, "emotionalImpact");
    const allThemes = await Promise.all(memories.map((m) => this.extractThemes(m.description)));
    const significantThemes = this.findSignificantThemes(import_lodash3.default.flatten(allThemes));
    const temporalPatterns = this.analyzeTemporalPatterns(memories);
    return {
      memories,
      analytics: {
        totalCount: memories.length,
        typeDistribution,
        averageImpact,
        significantThemes,
        temporalPatterns
      }
    };
  }
  findSignificantThemes(themes) {
    const themeCounts = import_lodash3.default.countBy(themes);
    const significantThreshold = Math.max(3, themes.length * 0.1);
    return Object.entries(themeCounts).filter(([_4, count]) => count >= significantThreshold).map(([theme]) => theme);
  }
  analyzeTemporalPatterns(memories) {
    const periods = memories.map((m) => this.getTemporalContext(m.timestamp));
    const periodCounts = import_lodash3.default.countBy(periods);
    return Object.entries(periodCounts).map(([period, count]) => ({
      period,
      count,
      significance: count / memories.length
    }));
  }
  filterMemories(collection, options) {
    let filteredMemories = collection.memories;
    if (options.type) {
      filteredMemories = filteredMemories.filter((m) => m.type === options.type);
    }
    if (options.fromTimestamp) {
      filteredMemories = filteredMemories.filter((m) => m.timestamp >= options.fromTimestamp);
    }
    if (options.toTimestamp) {
      filteredMemories = filteredMemories.filter((m) => m.timestamp <= options.toTimestamp);
    }
    if (options.minSignificance) {
      filteredMemories = filteredMemories.filter((m) => m.culturalSignificance >= options.minSignificance);
    }
    if (options.includedTags?.length) {
      filteredMemories = filteredMemories.filter((m) => options.includedTags.some((tag) => m.tags?.includes(tag)));
    }
    if (options.excludedTags?.length) {
      filteredMemories = filteredMemories.filter((m) => !options.excludedTags.some((tag) => m.tags?.includes(tag)));
    }
    return {
      memories: filteredMemories,
      analytics: {
        totalCount: filteredMemories.length,
        typeDistribution: this.calculateTypeDistribution(filteredMemories),
        averageImpact: this.calculateAverageImpact(filteredMemories),
        significantThemes: this.extractSignificantThemes(filteredMemories),
        temporalPatterns: this.calculateTemporalPatterns(filteredMemories)
      }
    };
  }
  calculateTypeDistribution(memories) {
    return memories.reduce((acc, memory) => {
      acc[memory.type] = (acc[memory.type] || 0) + 1;
      return acc;
    }, {});
  }
  calculateAverageImpact(memories) {
    if (memories.length === 0)
      return 0;
    return memories.reduce((sum, memory) => sum + memory.emotionalImpact, 0) / memories.length;
  }
  extractSignificantThemes(memories) {
    const themeCounts = new Map;
    memories.forEach((memory) => {
      memory.tags?.forEach((tag) => {
        themeCounts.set(tag, (themeCounts.get(tag) || 0) + 1);
      });
    });
    const significanceThreshold = memories.length * 0.25;
    return Array.from(themeCounts.entries()).filter(([_4, count]) => count >= significanceThreshold).map(([theme]) => theme);
  }
  calculateTemporalPatterns(memories) {
    const periodCounts = new Map;
    memories.forEach((memory) => {
      const period = this.getTemporalPeriod(memory.timestamp);
      periodCounts.set(period, (periodCounts.get(period) || 0) + 1);
    });
    return Array.from(periodCounts.entries()).map(([period, count]) => ({
      period,
      count,
      significance: count / memories.length
    }));
  }
  getTemporalPeriod(timestamp) {
    const now = Date.now();
    const age = now - timestamp;
    if (age < 30 * 24 * 60 * 60 * 1000)
      return "recent";
    if (age < 365 * 24 * 60 * 60 * 1000)
      return "past-year";
    if (age < 5 * 365 * 24 * 60 * 60 * 1000)
      return "past-5-years";
    if (age < 10 * 365 * 24 * 60 * 60 * 1000)
      return "past-decade";
    return "historical";
  }
  isCacheStale(districtId) {
    const cached = this.memoryCache.get(districtId);
    if (!cached)
      return true;
    const lastUpdate = Math.min(...cached.memories.map((m) => m.timestamp));
    return Date.now() - lastUpdate > this.CACHE_DURATION;
  }
  async initiatePreservationProtocol(memory) {
    this.emit("preservationNeeded", {
      memory,
      priority: memory.culturalSignificance,
      timestamp: Date.now()
    });
    await this.vectorStore.upsert({
      id: `preservation-${memory.districtId}-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(`Preservation request for ${memory.type} memory: ${memory.description}`),
      metadata: {
        type: "district",
        subtype: "preservation_request",
        districtId: memory.districtId,
        memoryId: memory.districtId,
        priority: memory.culturalSignificance,
        timestamp: Date.now()
      }
    });
    setTimeout(() => {
      this.reassessSignificance(memory);
    }, 30 * 24 * 60 * 60 * 1000);
  }
  async reassessSignificance(memory) {
    const currentAnalytics = await this.analyzeMemory(memory);
    if (Math.abs(currentAnalytics.significance - memory.culturalSignificance) > 0.2) {
      this.emit("significanceChanged", {
        memory,
        previousSignificance: memory.culturalSignificance,
        newSignificance: currentAnalytics.significance,
        timestamp: Date.now()
      });
    }
  }
  async searchMemories(query, options = {}) {
    const embedding = await this.vectorStore.createEmbedding(query);
    const filter = {
      type: { $eq: "district" },
      subtype: { $eq: "collective_memory" }
    };
    if (options.districtId) {
      filter.districtId = { $eq: options.districtId };
    }
    const results = await this.vectorStore.query({
      vector: embedding,
      filter,
      topK: 20
    });
    let memories = await this.processMemoryResults(results.matches);
    if (options.type) {
      memories = memories.filter((m) => m.type === options.type);
    }
    if (options.minSignificance !== undefined) {
      memories = memories.filter((m) => m.culturalSignificance >= options.minSignificance);
    }
    return memories;
  }
  calculateDistance(coord1, coord2) {
    const [lat1, lon1] = coord1;
    const [lat2, lon2] = coord2;
    const R = 6371000;
    const \u{3c6}1 = lat1 * Math.PI / 180;
    const \u{3c6}2 = lat2 * Math.PI / 180;
    const \u{394}_ = (lat2 - lat1) * Math.PI / 180;
    const \u{394}_2 = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(\u{394}_ / 2) * Math.sin(\u{394}_ / 2) + Math.cos(\u{3c6}1) * Math.cos(\u{3c6}2) * Math.sin(\u{394}_2 / 2) * Math.sin(\u{394}_2 / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
}

// src/services/agent-culture.service.ts
var import_lodash4 = __toESM(require_lodash2(), 1);
import { EventEmitter as EventEmitter19 } from "events";

class AgentCultureService extends EventEmitter19 {
  cultureService;
  vectorStore;
  culturalInteractions = new Map;
  districtContextCache = new Map;
  CACHE_DURATION = 30 * 60 * 1000;
  constructor(cultureService, vectorStore) {
    super();
    this.cultureService = cultureService;
    this.vectorStore = vectorStore;
    this.initializeCulturalService();
  }
  async initializeCulturalService() {
    this.cultureService.on("culturalEventCreated", this.handleNewCulturalEvent.bind(this));
    this.cultureService.on("culturalMetricsUpdated", this.updateCulturalMetrics.bind(this));
    setInterval(() => this.refreshCulturalContexts(), this.CACHE_DURATION);
  }
  async enrichAgentContext(agent, districtId) {
    const culturalContext = await this.getCulturalContext(districtId);
    const interactions = this.culturalInteractions.get(agent.id) || [];
    const culturalAwareness = {
      localTraditions: culturalContext.traditions,
      currentEvents: culturalContext.activeEvents,
      communityValues: culturalContext.values,
      culturalPreferences: this.matchCulturalPreferences(agent, culturalContext),
      culturalSensitivity: this.calculateCulturalSensitivity(agent, interactions),
      crossCulturalExperience: this.calculateCrossculturalExperience(interactions),
      communityEngagement: await this.analyzeCommunitiyEngagement(agent.id, districtId)
    };
    const enrichedAgent = {
      ...agent,
      culturalAwareness
    };
    await this.storeEnrichedContext(agent.id, districtId, culturalAwareness);
    return enrichedAgent;
  }
  async getCulturalContext(districtId) {
    const cached = this.districtContextCache.get(districtId);
    if (cached && Date.now() - cached.timestamp < this.CACHE_DURATION) {
      return cached.context;
    }
    const embedding = await this.vectorStore.createEmbedding(`district ${districtId} cultural context`);
    const results = await this.vectorStore.query({
      vector: embedding,
      filter: {
        type: { $eq: "district" },
        districtId: { $eq: districtId }
      },
      topK: 5
    });
    const context = this.processCulturalData(results.matches);
    this.districtContextCache.set(districtId, {
      context,
      timestamp: Date.now()
    });
    return context;
  }
  processCulturalData(matches) {
    const traditions = new Map;
    const events = new Map;
    const values = new Map;
    const demographics = new Set;
    const languages = new Set;
    matches.forEach((match) => {
      if (match.metadata.tradition) {
        traditions.set(match.metadata.tradition, {
          name: match.metadata.tradition,
          significance: match.metadata.significance || 0.5,
          participants: match.metadata.participants || 0,
          seasonality: match.metadata.seasonality
        });
      }
      if (match.metadata.event) {
        events.set(match.metadata.event, {
          id: match.metadata.eventId,
          type: match.metadata.eventType,
          title: match.metadata.event,
          impact: match.metadata.impact || 0.5,
          engagement: match.metadata.engagement || 0.5
        });
      }
      if (match.metadata.value) {
        values.set(match.metadata.value, {
          name: match.metadata.value,
          importance: match.metadata.importance || 0.5,
          adherence: match.metadata.adherence || 0.5
        });
      }
      if (match.metadata.demographics) {
        match.metadata.demographics.forEach((d) => demographics.add(d));
      }
      if (match.metadata.languages) {
        match.metadata.languages.forEach((l) => languages.add(l));
      }
    });
    return {
      traditions: Array.from(traditions.values()),
      activeEvents: Array.from(events.values()),
      values: Array.from(values.values()),
      demographics: {
        diversity: demographics.size / 10,
        mainGroups: Array.from(demographics),
        languages: Array.from(languages)
      }
    };
  }
  matchCulturalPreferences(agent, context) {
    const preferences = new Set;
    context.traditions.forEach((tradition) => {
      if (agent.interests.some((interest) => tradition.name.toLowerCase().includes(interest.toLowerCase()) || this.areConceptsRelated(interest, tradition.name))) {
        preferences.add(tradition.name);
      }
    });
    context.activeEvents.forEach((event) => {
      if (agent.interests.some((interest) => event.title.toLowerCase().includes(interest.toLowerCase()) || event.type.toLowerCase().includes(interest.toLowerCase()))) {
        preferences.add(event.title);
      }
    });
    context.values.forEach((value2) => {
      if (agent.interests.some((interest) => value2.name.toLowerCase().includes(interest.toLowerCase()) || this.areConceptsRelated(interest, value2.name))) {
        preferences.add(value2.name);
      }
    });
    return Array.from(preferences);
  }
  areConceptsRelated(concept1, concept2) {
    const relatedConcepts = {
      art: ["culture", "creativity", "expression", "heritage"],
      music: ["performance", "festival", "tradition", "celebration"],
      technology: ["innovation", "smart", "digital", "modern"],
      environment: ["sustainability", "green", "nature", "eco"],
      community: ["social", "collective", "public", "gathering"]
    };
    const related1 = relatedConcepts[concept1.toLowerCase()] || [];
    const related2 = relatedConcepts[concept2.toLowerCase()] || [];
    return related1.some((r) => concept2.toLowerCase().includes(r)) || related2.some((r) => concept1.toLowerCase().includes(r));
  }
  calculateCulturalSensitivity(agent, interactions) {
    const baseScore = agent.traits.empathy || 0.5;
    const interactionScore = interactions.reduce((score, interaction) => {
      return score + interaction.impact * 0.1;
    }, 0) / Math.max(interactions.length, 1);
    return Math.min(1, baseScore + interactionScore);
  }
  calculateCrossculturalExperience(interactions) {
    const uniqueEvents = new Set(interactions.map((i) => i.eventId).filter(Boolean));
    const uniqueDistricts = new Set(interactions.map((i) => i.districtId));
    return Math.min(1, uniqueEvents.size * 0.1 + uniqueDistricts.size * 0.2);
  }
  async analyzeCommunitiyEngagement(agentId, districtId) {
    const interactions = this.culturalInteractions.get(agentId) || [];
    const districtInteractions = interactions.filter((i) => i.districtId === districtId);
    return {
      level: this.calculateEngagementLevel(districtInteractions),
      activities: this.summarizeActivities(districtInteractions),
      impact: this.calculateCommunityImpact(districtInteractions)
    };
  }
  calculateEngagementLevel(interactions) {
    const recentInteractions = interactions.filter((i) => Date.now() - i.timestamp < 30 * 24 * 60 * 60 * 1000);
    return Math.min(1, recentInteractions.length * 0.1);
  }
  summarizeActivities(interactions) {
    const activityCounts = import_lodash4.default.countBy(interactions, "type");
    return Object.entries(activityCounts).map(([type3, count]) => `${type3} (${count} times)`);
  }
  calculateCommunityImpact(interactions) {
    return interactions.reduce((total, interaction) => total + interaction.impact, 0) / Math.max(interactions.length, 1);
  }
  async storeEnrichedContext(agentId, districtId, awareness) {
    await this.vectorStore.upsert({
      id: `cultural-awareness-${agentId}-${districtId}-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(JSON.stringify({
        preferences: awareness.culturalPreferences,
        sensitivity: awareness.culturalSensitivity,
        engagement: awareness.communityEngagement
      })),
      metadata: {
        type: "district",
        agentId,
        districtId,
        timestamp: Date.now(),
        awareness: JSON.stringify(awareness)
      }
    });
  }
  async handleNewCulturalEvent(event) {
    this.districtContextCache.delete(event.location.districtId);
    this.emit("newCulturalEvent", event);
  }
  async updateCulturalMetrics(metrics) {
    this.districtContextCache.clear();
    this.emit("culturalMetricsUpdated", metrics);
  }
  async refreshCulturalContexts() {
    for (const [districtId] of this.districtContextCache) {
      try {
        const newContext = await this.getCulturalContext(districtId);
        this.districtContextCache.set(districtId, {
          context: newContext,
          timestamp: Date.now()
        });
      } catch (error4) {
        console.error(`Error refreshing cultural context for district ${districtId}:`, error4);
      }
    }
  }
  async recordCulturalInteraction(interaction) {
    const fullInteraction = {
      ...interaction,
      timestamp: Date.now()
    };
    const agentInteractions = this.culturalInteractions.get(interaction.agentId) || [];
    agentInteractions.push(fullInteraction);
    this.culturalInteractions.set(interaction.agentId, agentInteractions);
    await this.storeInteraction(fullInteraction);
    this.emit("culturalInteraction", fullInteraction);
  }
  async storeInteraction(interaction) {
    await this.vectorStore.upsert({
      id: `cultural-interaction-${interaction.agentId}-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(JSON.stringify(interaction)),
      metadata: {
        type: "district",
        subtype: "cultural_interaction",
        agentId: interaction.agentId,
        interactionType: interaction.type,
        details: JSON.stringify(interaction.details)
      }
    });
  }
  async analyzeAgentCulturalFit(agent, district) {
    const culturalContext = await this.getCulturalContext(district.id);
    const enrichedAgent = await this.enrichAgentContext(agent, district.id);
    return {
      overallFit: this.calculateCulturalFit(enrichedAgent, culturalContext),
      recommendations: await this.generateCulturalRecommendations(enrichedAgent, culturalContext),
      potentialContributions: this.identifyPotentialContributions(enrichedAgent, culturalContext)
    };
  }
  calculateCulturalFit(agent, context) {
    const preferencesMatch = agent.culturalAwareness.culturalPreferences.length / Math.max(context.traditions.length + context.activeEvents.length, 1);
    const valueAlignment = context.values.reduce((sum, value2) => {
      return sum + (agent.culturalAwareness.communityValues.some((v) => v.name === value2.name) ? 1 : 0);
    }, 0) / Math.max(context.values.length, 1);
    const engagementScore = agent.culturalAwareness.communityEngagement.level;
    const sensitivityScore = agent.culturalAwareness.culturalSensitivity;
    const diversityScore = this.calculateDiversityAdaptation(agent.culturalAwareness, context.demographics);
    return preferencesMatch * 0.25 + valueAlignment * 0.25 + engagementScore * 0.2 + sensitivityScore * 0.15 + diversityScore * 0.15;
  }
  calculateDiversityAdaptation(awareness, demographics) {
    let score = awareness.crossCulturalExperience;
    if (demographics.languages.length > 1) {
      score += 0.1;
    }
    if (demographics.diversity > 0.7 && awareness.culturalSensitivity > 0.8) {
      score += 0.2;
    }
    return Math.min(1, score);
  }
  async generateCulturalRecommendations(agent, context) {
    const recommendations = [];
    agent.culturalAwareness.culturalPreferences.forEach((preference) => {
      const matchingEvents = context.activeEvents.filter((event) => event.title.toLowerCase().includes(preference.toLowerCase()));
      matchingEvents.forEach((event) => recommendations.push(`Consider participating in: ${event.title}`));
    });
    if (agent.culturalAwareness.communityEngagement.level < 0.6) {
      recommendations.push("Increase community participation through local events");
    }
    return recommendations;
  }
  identifyPotentialContributions(agent, context) {
    const contributions = [];
    agent.interests.forEach((interest) => {
      const relevantTraditions = context.traditions.filter((t2) => this.areConceptsRelated(interest, t2.name));
      relevantTraditions.forEach((tradition) => contributions.push(`Share expertise in ${interest} for ${tradition.name}`));
    });
    if (agent.culturalAwareness.culturalSensitivity > 0.7) {
      contributions.push("Help facilitate cross-cultural understanding");
    }
    return contributions;
  }
}

// src/services/culture.service.ts
import { EventEmitter as EventEmitter20 } from "events";

class CultureService extends EventEmitter20 {
  vectorStore;
  weatherService;
  socialDynamicsService;
  cityRhythmService;
  events = new Map;
  artists = new Map;
  religions = new Map;
  culturalMetrics;
  constructor(vectorStore, weatherService, socialDynamicsService, cityRhythmService) {
    super();
    this.vectorStore = vectorStore;
    this.weatherService = weatherService;
    this.socialDynamicsService = socialDynamicsService;
    this.cityRhythmService = cityRhythmService;
    this.culturalMetrics = {
      diversity: {
        eventTypes: {},
        culturalRepresentation: {},
        participationDemographics: {}
      },
      engagement: {
        totalParticipants: 0,
        averageRating: 0,
        repeatVisitors: 0,
        communityFeedback: {
          satisfaction: 0,
          relevance: 0,
          accessibility: 0,
          culturalAuthenticity: 0
        }
      },
      impact: {
        culturalPreservation: 0,
        crossCulturalExchange: 0,
        artisticInnovation: 0,
        communityHarmony: 0
      }
    };
    this.initializeCulturalSystem();
  }
  async initializeCulturalSystem() {
    setInterval(() => this.generateEvents(), 1000 * 60 * 60 * 24);
    setInterval(() => this.updateMetricsPeriodically(), 1000 * 60 * 60);
    setInterval(() => this.curateCulturalExperiences(), 1000 * 60 * 30);
    this.weatherService.on("weatherChanged", this.adaptToWeather.bind(this));
    this.cityRhythmService.on("rhythmUpdated", this.synchronizeEvents.bind(this));
  }
  async updateMetricsPeriodically() {
    const metrics = await this.calculateCulturalMetrics();
    await this.updateMetrics("system", metrics);
  }
  async generateEvents() {
    const cityMood = await this.cityRhythmService.getCurrentMood();
    const seasonalThemes = this.getSeasonalThemes();
    const culturalCalendar = this.getCulturalCalendar();
    await Promise.all([
      this.createArtisticEvents(cityMood),
      this.createPerformanceEvents(seasonalThemes),
      this.createCulinaryEvents(culturalCalendar),
      this.createHeritageEvents()
    ]);
  }
  async createArtisticEvents(cityMood) {
    const artForms = this.determineArtForms(cityMood);
    for (const form of artForms) {
      const event = await this.createCulturalEvent({
        type: "art_exhibition",
        title: `${form.style} Art Experience`,
        description: this.generateCreativeDescription(form),
        artists: (await this.findMatchingArtists(form.requirements)).map((artist) => artist.name),
        culturalOrigin: form.origins.join(", "),
        location: {
          districtId: "downtown",
          venue: "Art Gallery",
          coordinates: [0, 0]
        },
        schedule: [],
        culturalSignificance: 0,
        impact: {
          social: 0,
          cultural: 0,
          economic: 0
        },
        status: "upcoming",
        participants: []
      });
      await this.promoteEvent(event);
    }
  }
  async createPerformanceEvents(themes) {
    const venues = await this.findSuitableVenues("performance");
    for (const venue of venues) {
      const performanceStyle = this.matchThemeToStyle(themes, venue.attributes);
      await this.createCulturalEvent({
        type: "street_performance",
        title: `${performanceStyle.name} at ${venue.name}`,
        description: this.generatePerformanceDescription(performanceStyle),
        location: venue.location,
        schedule: [],
        culturalSignificance: 0,
        impact: {
          social: 0,
          cultural: 0,
          economic: 0
        },
        status: "upcoming",
        participants: []
      });
    }
  }
  async createCulinaryEvents(calendar) {
    const localCuisines = await this.getLocalCuisines();
    const fusionConcepts = this.generateFusionConcepts(localCuisines);
    for (const concept of fusionConcepts) {
      await this.createCulturalEvent({
        type: "food_festival",
        title: `Fusion Food Festival: ${concept.theme}`,
        description: this.generateCulinaryDescription(concept),
        location: {
          districtId: "culinary_district",
          venue: "Food Plaza",
          coordinates: [0, 0]
        },
        culturalOrigin: concept.cuisines.join(" & "),
        schedule: [
          { time: new Date().toISOString(), activity: "Opening Ceremony" },
          {
            time: new Date(Date.now() + 3600000).toISOString(),
            activity: "Cooking Demonstrations"
          },
          {
            time: new Date(Date.now() + 7200000).toISOString(),
            activity: "Tasting Sessions"
          },
          {
            time: new Date(Date.now() + 10800000).toISOString(),
            activity: "Cultural Performances"
          }
        ],
        culturalSignificance: 0.8,
        impact: {
          social: 0.7,
          cultural: 0.9,
          economic: 0.6
        },
        status: "upcoming",
        participants: []
      });
    }
  }
  async createHeritageEvents() {
    const heritageSpots = await this.identifyHeritageLocations();
    const culturalStories = await this.collectCulturalStories();
    const religiousEvents = this.generateReligiousEvents();
    for (const spot of heritageSpots) {
      const relevantStories = this.matchStoriesToLocation(culturalStories, spot);
      await this.createCulturalEvent({
        type: "heritage_tour",
        title: `Heritage Journey: ${spot.name}`,
        description: this.weaveStoriesIntoNarrative(relevantStories),
        location: spot.location,
        schedule: [
          {
            time: new Date().toISOString(),
            activity: "Welcome & Introduction"
          },
          {
            time: new Date(Date.now() + 1800000).toISOString(),
            activity: "Historical Tour"
          },
          {
            time: new Date(Date.now() + 3600000).toISOString(),
            activity: "Cultural Demonstrations"
          },
          {
            time: new Date(Date.now() + 5400000).toISOString(),
            activity: "Community Gathering"
          }
        ],
        culturalSignificance: 0.9,
        impact: {
          social: 0.8,
          cultural: 0.9,
          economic: 0.6
        },
        status: "upcoming",
        participants: [],
        culturalOrigin: spot.historicalSignificance
      });
    }
    for (const event of religiousEvents) {
      await this.createCulturalEvent({
        type: "cultural_celebration",
        title: event.title,
        description: event.description,
        location: event.location,
        schedule: event.schedule,
        culturalSignificance: 0.95,
        impact: {
          social: 0.9,
          cultural: 0.95,
          economic: 0.7
        },
        status: "upcoming",
        participants: [],
        culturalOrigin: event.origin
      });
    }
  }
  async curateCulturalExperiences() {
    const activeEvents = Array.from(this.events.values()).filter((event) => event.status === "active");
    for (const event of activeEvents) {
      const atmosphere = await this.analyzeEventAtmosphere(event);
      const recommendations = this.generateCulturalRecommendations(atmosphere);
      await this.enhanceEventExperience(event, recommendations);
    }
  }
  async analyzeEventAtmosphere(event) {
    const weather = await this.weatherService.getCurrentWeather();
    const socialMood = await this.socialDynamicsService.getCommunityMood(event.location.districtId);
    const culturalContext = await this.assessCulturalContext(event);
    const timeOfDay = new Date(event.startTime).getHours();
    const baseAmbiance = this.calculateBaseAmbiance(event.location.venue, timeOfDay);
    const weatherImpact = this.calculateWeatherImpact(weather || "clear", event.location.venue.includes("indoor"));
    const socialImpact = this.analyzeSocialDynamics(socialMood, event.type);
    const culturalResonance = this.calculateCulturalResonance(culturalContext, event);
    return {
      ambiance: Math.min(1, Math.max(0, baseAmbiance + weatherImpact)),
      socialDynamics: socialImpact,
      culturalResonance,
      recommendations: this.generateAtmosphereRecommendations(baseAmbiance, weatherImpact, socialImpact, culturalResonance)
    };
  }
  calculateBaseAmbiance(venue, hour2) {
    const timeFactors = {
      morning: hour2 >= 6 && hour2 < 12 ? 0.8 : 0,
      afternoon: hour2 >= 12 && hour2 < 17 ? 0.7 : 0,
      evening: hour2 >= 17 && hour2 < 22 ? 0.9 : 0,
      night: hour2 >= 22 || hour2 < 6 ? 0.6 : 0
    };
    const venueFactors = {
      indoor: venue.toLowerCase().includes("indoor") ? 0.7 : 0,
      outdoor: venue.toLowerCase().includes("outdoor") ? 0.8 : 0,
      historic: venue.toLowerCase().includes("heritage") ? 0.85 : 0,
      modern: venue.toLowerCase().includes("modern") ? 0.75 : 0
    };
    const timeAmbiance = Object.values(timeFactors).reduce((a, b) => a + b, 0);
    const venueAmbiance = Object.values(venueFactors).reduce((a, b) => a + b, 0);
    return (timeAmbiance + venueAmbiance) / 2;
  }
  calculateWeatherImpact(weather, isIndoor) {
    if (isIndoor)
      return 0;
    const impacts = {
      clear: 0.2,
      cloudy: -0.1,
      rain: -0.3,
      storm: -0.5
    };
    return impacts[weather] || 0;
  }
  analyzeSocialDynamics(mood, eventType) {
    const baseMood = (mood.happiness + mood.energy + mood.community) / 3;
    const eventFactors = {
      art_exhibition: 0.7,
      street_performance: 0.9,
      food_festival: 0.8,
      heritage_tour: 0.6,
      workshop: 0.7
    };
    return baseMood * (eventFactors[eventType] || 0.7);
  }
  calculateCulturalResonance(context, event) {
    const factors = [
      context.historicalRelevance || 0,
      context.communitySignificance || 0,
      context.culturalAuthenticity || 0,
      event.culturalSignificance || 0
    ];
    return factors.reduce((sum, factor) => sum + factor, 0) / factors.length;
  }
  generateAtmosphereRecommendations(baseAmbiance, weatherImpact, socialImpact, culturalResonance) {
    return {
      lighting: {
        intensity: baseAmbiance * 100,
        color: weatherImpact > 0 ? "warm" : "cool",
        dynamic: socialImpact > 0.7
      },
      sound: {
        volume: Math.min(70, socialImpact * 100),
        type: culturalResonance > 0.7 ? "cultural" : "ambient"
      },
      spacing: {
        capacity: Math.floor(baseAmbiance * 200),
        layout: socialImpact > 0.6 ? "interactive" : "traditional"
      },
      timing: {
        suggested_duration: Math.floor(culturalResonance * 180),
        peak_periods: weatherImpact > 0 ? ["evening", "night"] : ["morning", "afternoon"]
      }
    };
  }
  async enhanceEventExperience(event, recommendations) {
    const enhancedEvent = {
      ...event,
      ambiance: await this.adjustAmbiance(recommendations.atmosphere),
      program: await this.optimizeProgram(recommendations.flow),
      engagement: await this.enhanceParticipation(recommendations.interaction)
    };
    this.events.set(event.id, enhancedEvent);
    this.emit("eventEnhanced", enhancedEvent);
  }
  generateCreativeDescription(form) {
    const elements = [
      form.style,
      form.emotion,
      form.culturalContext,
      form.innovation
    ];
    return this.weaveNarrative(elements);
  }
  weaveNarrative(elements) {
    return elements.join(" meets ") + " in a unique cultural experience";
  }
  async calculateCulturalMetrics() {
    const events = Array.from(this.events.values());
    return {
      diversity: await this.analyzeCulturalDiversity(events),
      engagement: await this.measureCommunityEngagement(events),
      impact: await this.assessCulturalImpact(events)
    };
  }
  async analyzeCulturalDiversity(events) {
    return {
      eventTypes: this.categorizeEvents(events),
      culturalRepresentation: this.analyzeCulturalRepresentation(events),
      participationDemographics: await this.analyzeParticipation(events)
    };
  }
  async adaptToWeather(weather) {
    const activeEvents = Array.from(this.events.values()).filter((event) => event.status === "active");
    for (const event of activeEvents) {
      const adjustedEvent = await this.adjustEventForWeather(event, weather);
      this.events.set(event.id, adjustedEvent);
    }
  }
  async synchronizeEvents(rhythm) {
    const { patterns: patterns3, peakHours } = rhythm;
    const upcomingEvents = Array.from(this.events.values()).filter((event) => event.status === "upcoming");
    for (const event of upcomingEvents) {
      const optimizedSchedule = this.optimizeSchedule(event, patterns3, peakHours);
      this.events.set(event.id, { ...event, schedule: optimizedSchedule });
    }
  }
  getSeasonalThemes() {
    const month = new Date().getMonth();
    return [
      ["spring_renewal"],
      ["summer_vibrancy"],
      ["autumn_harvest"],
      ["winter_wonder"]
    ][Math.floor(month / 3)];
  }
  getCulturalCalendar() {
    return {
      festivals: ["lunar_new_year", "harvest_festival", "light_festival"],
      celebrations: ["national_day", "heritage_month"],
      traditions: ["tea_ceremony", "traditional_dance", "storytelling"]
    };
  }
  determineArtForms(cityMood) {
    const styles = [
      "Contemporary",
      "Abstract",
      "Digital",
      "Interactive",
      "Immersive",
      "Traditional",
      "Fusion",
      "Experimental",
      "Urban",
      "Sustainable"
    ];
    const emotions = [
      "Vibrant",
      "Serene",
      "Dynamic",
      "Contemplative",
      "Energetic",
      "Harmonious",
      "Mysterious",
      "Playful",
      "Dramatic",
      "Peaceful"
    ];
    const contexts = [
      "Urban Life",
      "Cultural Heritage",
      "Technology",
      "Nature",
      "Social Change",
      "Community",
      "Innovation",
      "Tradition"
    ];
    const innovations = [
      "AI Integration",
      "Sustainable Materials",
      "Interactive Technology",
      "Virtual Reality",
      "Augmented Reality",
      "Biofeedback",
      "Smart Materials",
      "Eco-friendly Processes"
    ];
    const numArtForms = 2 + Math.floor(Math.random() * 2);
    const artForms = [];
    for (let i = 0;i < numArtForms; i++) {
      artForms.push({
        style: styles[Math.floor(Math.random() * styles.length)],
        emotion: cityMood.dominant || emotions[Math.floor(Math.random() * emotions.length)],
        culturalContext: contexts[Math.floor(Math.random() * contexts.length)],
        innovation: innovations[Math.floor(Math.random() * innovations.length)],
        requirements: [
          "space",
          "lighting",
          "sound",
          "digital_equipment",
          "climate_control"
        ],
        origins: ["Contemporary Global", "Urban Culture", "Digital Age"]
      });
    }
    return artForms;
  }
  generateArtRequirements(style, innovation) {
    const baseRequirements = ["space", "lighting"];
    const styleRequirements = {
      Digital: ["projection", "computers", "sensors"],
      Interactive: ["sensors", "displays", "sound_system"],
      Immersive: ["surround_sound", "environmental_controls", "projection"],
      Traditional: ["natural_light", "climate_control"],
      Experimental: ["power_supply", "ventilation", "safety_equipment"]
    };
    const innovationRequirements = {
      "AI Integration": ["computing_power", "network", "displays"],
      "Virtual Reality": ["vr_headsets", "motion_sensors", "computing_power"],
      "Augmented Reality": ["ar_devices", "tracking_system", "network"],
      Biofeedback: ["biosensors", "data_processing", "displays"]
    };
    const requirements = [...baseRequirements];
    Object.entries(styleRequirements).forEach(([key, reqs]) => {
      if (style.includes(key)) {
        requirements.push(...reqs);
      }
    });
    Object.entries(innovationRequirements).forEach(([key, reqs]) => {
      if (innovation.includes(key)) {
        requirements.push(...reqs);
      }
    });
    return [...new Set(requirements)];
  }
  determineArtOrigins(style, context) {
    const globalTraditions = [
      "Contemporary Global",
      "Digital Age",
      "Urban Culture",
      "Nature-Inspired",
      "Tech-Influenced"
    ];
    const culturalTraditions = [
      "East Asian",
      "European",
      "African",
      "Latin American",
      "Middle Eastern",
      "South Asian",
      "Indigenous"
    ];
    const origins = [];
    if (style.includes("Contemporary") || style.includes("Digital") || style.includes("Interactive")) {
      origins.push(globalTraditions[Math.floor(Math.random() * globalTraditions.length)]);
    }
    if (context.includes("Heritage") || context.includes("Tradition")) {
      origins.push(culturalTraditions[Math.floor(Math.random() * culturalTraditions.length)]);
    }
    if (origins.length === 0) {
      origins.push(globalTraditions[0]);
    }
    return origins;
  }
  async createCulturalEvent(eventData) {
    const event = {
      id: crypto.randomUUID(),
      type: eventData.type,
      title: eventData.title,
      description: eventData.description,
      location: eventData.location,
      startTime: new Date().toISOString(),
      endTime: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
      participants: [],
      culturalSignificance: 0,
      impact: {
        social: 0,
        cultural: 0,
        economic: 0
      },
      status: "upcoming",
      artists: eventData.artists || [],
      schedule: eventData.schedule || [],
      culturalOrigin: eventData.culturalOrigin || ""
    };
    this.events.set(event.id, event);
    return event;
  }
  async findMatchingArtists(requirements) {
    const artistPool = [
      {
        id: "1",
        name: "Sofia Chen",
        specialties: ["digital art", "installations", "multimedia"],
        culturalBackground: ["Chinese", "Contemporary"],
        achievements: [
          { title: "Digital Art Excellence", date: "2023", significance: 0.9 },
          {
            title: "Cultural Innovation Award",
            date: "2022",
            significance: 0.85
          }
        ],
        collaborations: ["Modern Art Museum", "Tech Innovation Center"],
        rating: 4.8
      },
      {
        id: "2",
        name: "Marcus Rivera",
        specialties: ["performance art", "interactive installations", "sound"],
        culturalBackground: ["Latin American", "European"],
        achievements: [
          {
            title: "Performance Art Pioneer",
            date: "2023",
            significance: 0.88
          },
          { title: "Sound Design Award", date: "2022", significance: 0.82 }
        ],
        collaborations: ["City Theater", "Music Festival"],
        rating: 4.7
      },
      {
        id: "3",
        name: "Aisha Patel",
        specialties: ["mixed media", "traditional crafts", "modern fusion"],
        culturalBackground: ["Indian", "Contemporary"],
        achievements: [
          {
            title: "Cultural Heritage Award",
            date: "2023",
            significance: 0.92
          },
          { title: "Innovation in Craft", date: "2022", significance: 0.87 }
        ],
        collaborations: ["Heritage Museum", "Contemporary Art Center"],
        rating: 4.9
      }
    ];
    return artistPool.filter((artist) => requirements.some((req) => artist.specialties.some((specialty) => specialty.toLowerCase().includes(req.toLowerCase())))).sort((a, b) => b.rating - a.rating);
  }
  async promoteEvent(event) {
    const promotionChannels = [
      { type: "social_media", reach: 0.8, targetAudience: "young_adults" },
      { type: "local_news", reach: 0.6, targetAudience: "general_public" },
      {
        type: "cultural_networks",
        reach: 0.7,
        targetAudience: "art_enthusiasts"
      },
      {
        type: "community_boards",
        reach: 0.5,
        targetAudience: "local_residents"
      }
    ];
    const eventTags = [
      event.type,
      ...event.culturalOrigin ? event.culturalOrigin.split(",").map((c) => c.trim()) : [],
      "culture",
      "city_events",
      "community"
    ];
    promotionChannels.forEach((channel) => {
      this.emit("eventPromoted", {
        eventId: event.id,
        channel: channel.type,
        tags: eventTags,
        estimatedReach: Math.floor(1000 * channel.reach * Math.random()),
        targetAudience: channel.targetAudience
      });
    });
  }
  async findSuitableVenues(type3) {
    const venues = [
      {
        name: "Central Plaza",
        attributes: ["spacious", "outdoor", "accessible", "central", "iconic"],
        location: {
          districtId: "downtown",
          venue: "Central Plaza",
          coordinates: [0, 0]
        }
      },
      {
        name: "Cultural Center",
        attributes: [
          "indoor",
          "modern",
          "equipped",
          "accessible",
          "prestigious"
        ],
        location: {
          districtId: "cultural_district",
          venue: "Cultural Center",
          coordinates: [0.1, 0.1]
        }
      },
      {
        name: "Heritage Hall",
        attributes: [
          "historic",
          "indoor",
          "traditional",
          "atmospheric",
          "central"
        ],
        location: {
          districtId: "old_town",
          venue: "Heritage Hall",
          coordinates: [-0.1, -0.1]
        }
      },
      {
        name: "Innovation Hub",
        attributes: [
          "modern",
          "tech-enabled",
          "flexible",
          "indoor",
          "accessible"
        ],
        location: {
          districtId: "tech_district",
          venue: "Innovation Hub",
          coordinates: [0.2, 0.2]
        }
      },
      {
        name: "Community Garden",
        attributes: [
          "outdoor",
          "natural",
          "sustainable",
          "community-focused",
          "peaceful"
        ],
        location: {
          districtId: "residential",
          venue: "Community Garden",
          coordinates: [-0.2, 0.2]
        }
      }
    ];
    const requirements = {
      performance: ["spacious", "accessible", "equipped"],
      exhibition: ["indoor", "equipped", "accessible"],
      workshop: ["flexible", "accessible", "equipped"],
      ceremony: ["prestigious", "atmospheric", "accessible"],
      festival: ["spacious", "accessible", "central"]
    };
    const typeReqs = requirements[type3.toLowerCase()] || ["accessible"];
    return venues.filter((venue) => typeReqs.every((req) => venue.attributes.some((attr) => attr.toLowerCase().includes(req.toLowerCase()))));
  }
  matchThemeToStyle(themes, attributes) {
    return {
      name: "Contemporary Fusion",
      type: "mixed_media",
      culturalOrigin: ["modern", "traditional"],
      requirements: ["stage", "lighting", "sound"]
    };
  }
  generatePerformanceDescription(style) {
    return `Experience the magic of ${style.name}, blending ${style.culturalOrigin.join(" and ")} 
      traditions in a unique performance that requires ${style.requirements.join(", ")}.`;
  }
  async getLocalCuisines() {
    const cuisinesByRegion = {
      asian: ["Japanese", "Chinese", "Korean", "Thai", "Vietnamese", "Indian"],
      mediterranean: ["Greek", "Italian", "Spanish", "Turkish", "Lebanese"],
      american: ["Southern", "Tex-Mex", "Cajun", "New England", "California"],
      african: [
        "Ethiopian",
        "Moroccan",
        "Nigerian",
        "Egyptian",
        "South African"
      ]
    };
    const selectedCuisines = [];
    Object.values(cuisinesByRegion).forEach((region) => {
      const randomCuisines = region.sort(() => Math.random() - 0.5).slice(0, 2);
      selectedCuisines.push(...randomCuisines);
    });
    return selectedCuisines;
  }
  generateFusionConcepts(cuisines) {
    const fusionStyles = [
      "Modern",
      "Street",
      "Gourmet",
      "Traditional",
      "Experimental"
    ];
    const techniques = [
      "Molecular",
      "Farm-to-Table",
      "Artisanal",
      "Sustainable"
    ];
    return cuisines.map((cuisine, index) => {
      const pairedCuisine = cuisines[(index + 1) % cuisines.length];
      const style = fusionStyles[Math.floor(Math.random() * fusionStyles.length)];
      const technique = techniques[Math.floor(Math.random() * techniques.length)];
      return {
        theme: `${style} ${cuisine}-${pairedCuisine} Fusion`,
        cuisines: [cuisine, pairedCuisine],
        fusion: [technique, style.toLowerCase()],
        description: `An innovative culinary experience combining ${cuisine} and ${pairedCuisine} traditions with ${technique.toLowerCase()} techniques`
      };
    });
  }
  generateCulinaryDescription(theme) {
    const culturalElements = [
      "traditional cooking methods",
      "ancestral recipes",
      "local ingredients",
      "cultural storytelling",
      "family traditions"
    ];
    const innovativeElements = [
      "modern techniques",
      "sustainable practices",
      "artistic presentation",
      "interactive experiences",
      "sensory exploration"
    ];
    const selectedCultural = culturalElements[Math.floor(Math.random() * culturalElements.length)];
    const selectedInnovative = innovativeElements[Math.floor(Math.random() * innovativeElements.length)];
    return `Experience the magic of ${theme.theme}: A culinary journey celebrating the fusion of ${theme.cuisines[0]} and ${theme.cuisines[1]} cuisines. This unique festival combines ${selectedCultural} with ${selectedInnovative}, featuring ${theme.fusion.join(" and ")} elements. ${theme.description}`;
  }
  async identifyHeritageLocations() {
    return [
      {
        name: "Ancient Market Square",
        location: {
          districtId: "old_town",
          venue: "Market Square",
          coordinates: [0, 0]
        },
        historicalSignificance: "Trading hub since 15th century",
        culturalValue: "Community gathering place"
      },
      {
        name: "Grand Mosque",
        location: {
          districtId: "religious_district",
          venue: "Central Mosque",
          coordinates: [0.1, 0.1]
        },
        historicalSignificance: "Islamic Heritage",
        culturalValue: "Spiritual center and architectural marvel"
      },
      {
        name: "Temple of Harmony",
        location: {
          districtId: "religious_district",
          venue: "Buddhist Temple",
          coordinates: [-0.1, 0.1]
        },
        historicalSignificance: "Buddhist Heritage",
        culturalValue: "Meditation and cultural exchange"
      },
      {
        name: "St. Mary's Cathedral",
        location: {
          districtId: "religious_district",
          venue: "Cathedral Square",
          coordinates: [0.1, -0.1]
        },
        historicalSignificance: "Christian Heritage",
        culturalValue: "Religious ceremonies and gothic architecture"
      },
      {
        name: "Synagogue of Light",
        location: {
          districtId: "religious_district",
          venue: "Jewish Quarter",
          coordinates: [-0.1, -0.1]
        },
        historicalSignificance: "Jewish Heritage",
        culturalValue: "Religious studies and community events"
      }
    ];
  }
  async collectCulturalStories() {
    return [
      {
        title: "Market Tales",
        narrative: "Stories of ancient traders",
        culturalContext: "Commerce and community",
        historicalPeriod: "Medieval",
        location: "Market Square"
      }
    ];
  }
  matchStoriesToLocation(stories, spot) {
    return stories.filter((story) => story.location === spot.name);
  }
  weaveStoriesIntoNarrative(stories) {
    return stories.map((story) => `${story.title}: ${story.narrative} from the ${story.historicalPeriod} period`).join("\n");
  }
  async assessCulturalContext(event) {
    return {
      historicalRelevance: 0.8,
      communitySignificance: 0.9,
      culturalAuthenticity: 0.85
    };
  }
  calculateAmbiance(weather, eventType) {
    const baseAmbiance = 0.8;
    const weatherImpact = weather.severity > 0.5 ? -0.2 : 0;
    return Math.max(0, Math.min(1, baseAmbiance + weatherImpact));
  }
  analyzeSocialInteractions(mood) {
    return mood.positivity * 0.7 + mood.engagement * 0.3;
  }
  measureCulturalImpact(context) {
    return (context.historicalRelevance + context.communitySignificance + context.culturalAuthenticity) / 3;
  }
  async adjustAmbiance(atmosphere) {
    return {
      lighting: atmosphere.brightness,
      sound: atmosphere.volume,
      spacing: atmosphere.density
    };
  }
  async optimizeProgram(flow) {
    return {
      sequence: flow.segments,
      timing: flow.duration,
      transitions: flow.changes
    };
  }
  async enhanceParticipation(interaction) {
    return {
      activities: interaction.suggested,
      groupSize: interaction.optimal,
      duration: interaction.recommended
    };
  }
  async measureCommunityEngagement(events) {
    return {
      totalParticipants: events.reduce((sum, event) => sum + event.participants.length, 0),
      averageRating: 4.2,
      repeatVisitors: 150,
      communityFeedback: {
        satisfaction: 0.85,
        relevance: 0.9,
        accessibility: 0.8,
        culturalAuthenticity: 0.95
      }
    };
  }
  async assessCulturalImpact(events) {
    return {
      culturalPreservation: 0.85,
      crossCulturalExchange: 0.9,
      artisticInnovation: 0.8,
      communityHarmony: 0.95
    };
  }
  categorizeEvents(events) {
    return events.reduce((acc, event) => ({
      ...acc,
      [event.type]: (acc[event.type] || 0) + 1
    }), {});
  }
  analyzeCulturalRepresentation(events) {
    const representation = {};
    events.forEach((event) => {
      if (event.culturalOrigin) {
        representation[event.culturalOrigin] = (representation[event.culturalOrigin] || 0) + 1;
      }
    });
    return representation;
  }
  async analyzeParticipation(events) {
    const demographics = {};
    events.forEach((event) => {
      event.participants.forEach((participant) => {
        demographics[participant] = (demographics[participant] || 0) + 1;
      });
    });
    return demographics;
  }
  async adjustEventForWeather(event, weather) {
    if (weather.severity > 0.7) {
      return {
        ...event,
        location: event.location.venue.includes("outdoor") ? { ...event.location, venue: `Indoor ${event.location.venue}` } : event.location
      };
    }
    return event;
  }
  optimizeSchedule(event, patterns3, peakHours) {
    const optimalStart = peakHours[0];
    return [
      {
        time: new Date(optimalStart).toISOString(),
        activity: "Opening"
      },
      {
        time: new Date(optimalStart + 3600000).toISOString(),
        activity: "Main Event"
      },
      {
        time: new Date(optimalStart + 7200000).toISOString(),
        activity: "Closing"
      }
    ];
  }
  generateCulturalRecommendations(atmosphere) {
    return {
      atmosphere: {
        brightness: atmosphere.ambiance * 0.8,
        volume: Math.min(atmosphere.ambiance * 70, 85),
        density: atmosphere.socialDynamics * 0.6
      },
      flow: {
        segments: ["welcome", "main", "conclusion"],
        duration: 120,
        changes: ["gradual", "natural"]
      },
      interaction: {
        suggested: ["group", "individual", "mixed"],
        optimal: Math.floor(atmosphere.socialDynamics * 30),
        recommended: 90
      },
      location: {
        districtId: atmosphere.district,
        coordinates: atmosphere.coordinates
      },
      timing: {
        startTime: atmosphere.recommendedStartTime,
        endTime: atmosphere.recommendedEndTime
      },
      participants: atmosphere.expectedParticipants || [],
      culturalImpact: this.calculateCulturalImpact(atmosphere)
    };
  }
  calculateCulturalImpact(atmosphere) {
    return atmosphere.harmonyIndex * 0.4 + (1 - atmosphere.culturalTension) * 0.6;
  }
  generateReligiousEvents() {
    const events = [
      {
        title: "Interfaith Harmony Festival",
        description: "A celebration of unity and understanding between different faiths",
        location: {
          districtId: "religious_district",
          venue: "Unity Plaza",
          coordinates: [0, 0]
        },
        schedule: [
          { time: new Date().toISOString(), activity: "Opening Ceremony" },
          {
            time: new Date(Date.now() + 3600000).toISOString(),
            activity: "Interfaith Dialogue"
          },
          {
            time: new Date(Date.now() + 7200000).toISOString(),
            activity: "Cultural Performances"
          },
          {
            time: new Date(Date.now() + 10800000).toISOString(),
            activity: "Community Feast"
          }
        ],
        origin: "Multicultural"
      }
    ];
    for (const [_5, religion] of this.religions) {
      const holyPlace = religion.holyPlaces.find((place) => place.status === "existing");
      if (holyPlace) {
        events.push({
          title: `${religion.name} Celebration`,
          description: `A special gathering to celebrate the traditions of ${religion.name}`,
          location: holyPlace.location,
          schedule: [
            { time: new Date().toISOString(), activity: "Opening Prayer" },
            {
              time: new Date(Date.now() + 3600000).toISOString(),
              activity: "Religious Ceremony"
            },
            {
              time: new Date(Date.now() + 7200000).toISOString(),
              activity: "Community Gathering"
            }
          ],
          origin: religion.name
        });
      }
    }
    return events;
  }
  async createNewReligion(religionData) {
    const religion = {
      id: crypto.randomUUID(),
      name: religionData.name,
      foundingDate: new Date().toISOString(),
      founder: religionData.founder,
      mainBeliefs: religionData.mainBeliefs,
      practices: religionData.practices,
      holyPlaces: religionData.proposedHolyPlaces.map((place) => ({
        ...place,
        status: "planned",
        donationProgress: 0
      })),
      followers: 0,
      events: []
    };
    this.religions.set(religion.id, religion);
    this.emit("religionCreated", religion);
    const foundingEvent = await this.createCulturalEvent({
      type: "religious_ceremony",
      title: `Founding of ${religion.name}`,
      description: `A historic ceremony marking the establishment of ${religion.name}`,
      location: {
        districtId: "religious_district",
        venue: "Unity Plaza",
        coordinates: [0, 0]
      },
      schedule: [
        { time: new Date().toISOString(), activity: "Founding Ceremony" },
        {
          time: new Date(Date.now() + 3600000).toISOString(),
          activity: "Declaration of Beliefs"
        },
        {
          time: new Date(Date.now() + 7200000).toISOString(),
          activity: "Community Celebration"
        }
      ],
      culturalSignificance: 1,
      impact: {
        social: 0.9,
        cultural: 1,
        economic: 0.7
      },
      status: "upcoming",
      participants: [],
      culturalOrigin: religion.name
    });
    religion.events.push(foundingEvent.id);
    return religion;
  }
  async donateToHolyPlace(religionId, holyPlaceName, amount) {
    const religion = this.religions.get(religionId);
    if (!religion)
      throw new Error("Religion not found");
    const holyPlace = religion.holyPlaces.find((place) => place.name === holyPlaceName);
    if (!holyPlace)
      throw new Error("Holy place not found");
    if (holyPlace.status === "existing")
      throw new Error("Holy place already exists");
    holyPlace.donationProgress = (holyPlace.donationProgress || 0) + amount;
    if (holyPlace.donationProgress >= 1e6) {
      holyPlace.status = "existing";
      this.emit("holyPlaceCompleted", { religionId, holyPlace });
      await this.createCulturalEvent({
        type: "religious_ceremony",
        title: `${holyPlace.name} Inauguration`,
        description: `Grand opening ceremony of the newly constructed ${holyPlace.name}`,
        location: holyPlace.location,
        schedule: [
          { time: new Date().toISOString(), activity: "Opening Ceremony" },
          {
            time: new Date(Date.now() + 3600000).toISOString(),
            activity: "Religious Ceremony"
          },
          {
            time: new Date(Date.now() + 7200000).toISOString(),
            activity: "Community Celebration"
          }
        ],
        culturalSignificance: 1,
        impact: {
          social: 0.9,
          cultural: 1,
          economic: 0.8
        },
        status: "upcoming",
        participants: [],
        culturalOrigin: religion.name
      });
    } else if (holyPlace.donationProgress >= 500000 && holyPlace.status === "planned") {
      holyPlace.status = "under_construction";
      this.emit("constructionStarted", { religionId, holyPlace });
    }
    this.emit("donationReceived", { religionId, holyPlace, amount });
  }
  async updateReligionMetrics(religionId) {
    const religion = this.religions.get(religionId);
    if (!religion)
      throw new Error("Religion not found");
    const recentEvents = Array.from(this.events.values()).filter((event) => religion.events.includes(event.id) && new Date(event.endTime).getTime() > Date.now() - 30 * 24 * 60 * 60 * 1000);
    const totalParticipants = recentEvents.reduce((sum, event) => sum + event.participants.length, 0);
    const averageImpact = recentEvents.reduce((sum, event) => sum + event.culturalSignificance, 0) / recentEvents.length;
    religion.followers = Math.floor(totalParticipants * averageImpact * 1.5);
    this.emit("religionMetricsUpdated", {
      religionId,
      followers: religion.followers
    });
  }
  async createEvent(event) {
    const newEvent = {
      ...event,
      id: event.id || crypto.randomUUID(),
      status: event.status || "upcoming",
      startTime: event.startTime || new Date().toISOString(),
      endTime: event.endTime || new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
      participants: event.participants || [],
      impact: event.impact || {
        social: 0,
        cultural: 0,
        economic: 0
      }
    };
    this.events.set(newEvent.id, newEvent);
    this.emit("eventCreated", newEvent);
    return newEvent;
  }
  async updateEvent(id, eventData) {
    const existingEvent = this.events.get(id);
    if (!existingEvent) {
      throw new Error("Event not found");
    }
    const updatedEvent = {
      ...existingEvent,
      ...eventData,
      id
    };
    this.events.set(id, updatedEvent);
    this.emit("eventUpdated", updatedEvent);
    return updatedEvent;
  }
  async deleteEvent(id) {
    const event = this.events.get(id);
    if (!event) {
      throw new Error("Event not found");
    }
    this.events.delete(id);
    this.emit("eventDeleted", id);
  }
  async getEvent(id) {
    const event = this.events.get(id);
    if (!event) {
      throw new Error("Event not found");
    }
    return event;
  }
  async listEvents() {
    return Array.from(this.events.values());
  }
  async getAtmosphere(location) {
    const weather = await this.weatherService.getCurrentWeather();
    const socialMood = await this.socialDynamicsService.getCommunityMood(location.districtId);
    return {
      harmonyIndex: this.calculateHarmonyIndex(socialMood),
      culturalTension: this.calculateCulturalTension(location),
      mood: socialMood.mood || "neutral",
      intensity: socialMood.intensity || 0.5,
      weatherInfluence: weather ? this.calculateWeatherImpact(weather, false) : 0
    };
  }
  calculateHarmonyIndex(socialMood) {
    return (socialMood.positivity || 0.5) * (socialMood.engagement || 0.5);
  }
  calculateCulturalTension(location) {
    const events = Array.from(this.events.values()).filter((e) => e.location.districtId === location.districtId);
    return Math.max(0, 1 - events.length / 10);
  }
  async updateMetrics(eventId, metrics) {
    const event = await this.getEvent(eventId);
    this.culturalMetrics = {
      ...this.culturalMetrics,
      ...metrics
    };
    this.emit("metricsUpdated", this.culturalMetrics);
  }
  async getDistrictCulture(districtId) {
    try {
      const results = await this.vectorStore.query({
        vector: await this.vectorStore.createEmbedding(`district ${districtId} cultural data`),
        filter: {
          type: { $eq: "district_culture" },
          districtId: { $eq: districtId }
        },
        topK: 1
      });
      if (!results.matches?.length) {
        return {
          culturalIndex: 0.5,
          events: [],
          heritage: [],
          traditions: []
        };
      }
      return {
        culturalIndex: results.matches[0].metadata.culturalIndex || 0.5,
        events: JSON.parse(results.matches[0].metadata.events || "[]"),
        heritage: JSON.parse(results.matches[0].metadata.heritage || "[]"),
        traditions: JSON.parse(results.matches[0].metadata.traditions || "[]")
      };
    } catch (error4) {
      console.error("Error getting district culture:", error4);
      return {
        culturalIndex: 0.5,
        events: [],
        heritage: [],
        traditions: []
      };
    }
  }
}

// src/services/weather.service.ts
import { EventEmitter as EventEmitter21 } from "events";
class WeatherService extends EventEmitter21 {
  vectorStore;
  cityService;
  transportService;
  cityRhythmService;
  emergencyService;
  currentWeather = null;
  weatherHistory = [];
  eventBus;
  weatherPredictions = [];
  constructor(vectorStore, cityService, transportService, cityRhythmService, emergencyService) {
    super();
    this.vectorStore = vectorStore;
    this.cityService = cityService;
    this.transportService = transportService;
    this.cityRhythmService = cityRhythmService;
    this.emergencyService = emergencyService;
    this.eventBus = EventBus.getInstance();
    this.initializeWeatherSystem();
  }
  async initializeWeatherSystem() {
    setInterval(() => this.simulateWeatherChanges(), 1000 * 60 * 60);
    setInterval(() => this.updateWeatherPredictions(), 1000 * 60 * 30);
    setInterval(() => this.monitorEnvironmentalMetrics(), 1000 * 60 * 15);
    this.setupEventListeners();
  }
  setupEventListeners() {
    this.eventBus.on("aiPredictionUpdate", this.handleAIPrediction.bind(this));
    this.eventBus.on("environmentalAlert", this.handleEnvironmentalAlert.bind(this));
    this.eventBus.on("emergencyResponse", this.adjustForEmergency.bind(this));
  }
  async updateWeatherPredictions() {
    const predictions = await this.generateWeatherPredictions();
    this.weatherPredictions = predictions;
    const highRiskPredictions = predictions.filter((p) => p.probability > 0.7 && p.estimatedSeverity > 0.6);
    if (highRiskPredictions.length > 0) {
      this.eventBus.emit("weatherWarning", {
        predictions: highRiskPredictions,
        timestamp: Date.now()
      });
    }
  }
  async generateWeatherPredictions() {
    const recentHistory = this.getWeatherHistory(72);
    const embedding = await this.vectorStore.createEmbedding(JSON.stringify(recentHistory.map((w) => ({
      type: w.type,
      severity: w.severity,
      duration: w.duration
    }))));
    const similarPatterns = await this.vectorStore.query({
      vector: embedding,
      filter: {
        type: { $eq: "district" },
        weatherType: { $exists: true }
      },
      topK: 5
    });
    return this.analyzePatternsForPredictions(similarPatterns.matches || []);
  }
  analyzePatternsForPredictions(patterns3) {
    return patterns3.map((pattern2) => ({
      type: pattern2.metadata.weatherType,
      probability: pattern2.score || 0.5,
      estimatedSeverity: pattern2.metadata.severity || 0.5,
      estimatedDuration: pattern2.metadata.duration || 6,
      confidence: pattern2.score || 0.5,
      potentialImpacts: this.predictPotentialImpacts(pattern2.metadata)
    }));
  }
  predictPotentialImpacts(metadata) {
    const impacts = [];
    if (metadata.severity > 0.7) {
      impacts.push("transport");
      impacts.push("outdoor_activities");
    }
    if (metadata.severity > 0.8) {
      impacts.push("power");
      impacts.push("infrastructure");
    }
    return impacts;
  }
  async monitorEnvironmentalMetrics() {
    if (!this.currentWeather)
      return;
    const metrics = await this.measureEnvironmentalMetrics();
    this.currentWeather.environmentalMetrics = metrics;
    if (this.detectAnomalies(metrics)) {
      this.eventBus.emit("environmentalAnomaly", {
        metrics,
        weather: this.currentWeather,
        timestamp: Date.now()
      });
    }
  }
  async measureEnvironmentalMetrics() {
    return {
      airQuality: Math.random() * 100,
      humidity: Math.random() * 100,
      pressure: 980 + Math.random() * 40,
      windSpeed: Math.random() * 30,
      visibility: Math.random() * 10
    };
  }
  detectAnomalies(metrics) {
    if (!metrics)
      return false;
    return metrics.airQuality < 50 || metrics.windSpeed > 25 || metrics.visibility < 3;
  }
  async handleAIPrediction(prediction) {
    if (this.currentWeather) {
      this.currentWeather.aiPredictions = {
        nextChange: prediction.nextChange,
        confidence: prediction.confidence,
        potentialImpacts: prediction.impacts
      };
      if (prediction.confidence > 0.8 && prediction.severity > 0.7) {
        await this.prepareForWeatherChange(prediction);
      }
    }
  }
  async prepareForWeatherChange(prediction) {
    this.eventBus.emit("weatherPreparation", {
      prediction,
      recommendedActions: this.generatePreparationActions(prediction)
    });
  }
  generatePreparationActions(prediction) {
    const actions = [];
    if (prediction.severity > 0.8) {
      actions.push("ALERT_EMERGENCY_SERVICES");
      actions.push("PREPARE_SHELTER_LOCATIONS");
    }
    if (prediction.impacts.includes("transport")) {
      actions.push("ADJUST_TRANSPORT_SCHEDULES");
    }
    if (prediction.impacts.includes("power")) {
      actions.push("ACTIVATE_BACKUP_SYSTEMS");
    }
    return actions;
  }
  async handleEnvironmentalAlert(alert) {
    const weatherImpact = this.assessEnvironmentalImpact(alert);
    if (weatherImpact.severity > 0.5) {
      await this.adjustWeatherResponse(weatherImpact);
    }
  }
  async adjustForEmergency(emergency) {
    if (this.currentWeather && emergency.type === "environmental" /* ENVIRONMENTAL */) {
      const adjustedWeather = {
        ...this.currentWeather,
        severity: Math.max(this.currentWeather.severity, 0.8)
      };
      await this.setWeatherCondition(adjustedWeather);
    }
  }
  async simulateWeatherChanges() {
    if (Math.random() < 0.3) {
      const newWeather = await this.generateWeatherCondition();
      await this.setWeatherCondition(newWeather);
    }
  }
  async generateWeatherCondition() {
    const types2 = ["rain", "snow", "heat", "storm"];
    const type3 = types2[Math.floor(Math.random() * types2.length)];
    const severity = Math.random();
    const duration = Math.floor(Math.random() * 12) + 1;
    const districtsContext = this.cityService.getContext();
    const districts = Array.from(districtsContext.districts.values());
    const affectedDistricts = districts.filter((district) => Math.random() > 0.5).map((district) => district.id);
    return {
      type: type3,
      severity,
      duration,
      affectedDistricts,
      startTime: Date.now(),
      environmentalMetrics: await this.measureEnvironmentalMetrics()
    };
  }
  async setWeatherCondition(weather) {
    this.currentWeather = weather;
    this.weatherHistory.push(weather);
    await this.storeWeatherData(weather);
    await this.applyWeatherImpacts(weather);
    this.eventBus.emit("weatherChanged", {
      ...weather,
      predictions: this.weatherPredictions,
      recommendations: this.generatePreparationActions(weather)
    });
  }
  async storeWeatherData(weather) {
    const { environmentalMetrics, ...weatherData } = weather;
    await this.vectorStore.upsert({
      id: `weather-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(`${weather.type} weather with severity ${weather.severity}`),
      metadata: {
        type: "district",
        weatherType: weather.type,
        severity: weather.severity,
        duration: weather.duration,
        timestamp: weather.startTime,
        airQuality: environmentalMetrics?.airQuality,
        windSpeed: environmentalMetrics?.windSpeed,
        visibility: environmentalMetrics?.visibility
      }
    });
  }
  async applyWeatherImpacts(weather) {
    const impacts = this.calculateWeatherImpacts(weather);
    if (this.transportService) {
      await this.transportService.adjustEfficiency(impacts.transport);
    }
    await this.cityRhythmService.adjustForWeather(weather);
    if (weather.severity > 0.7) {
      await this.handleSevereWeather(weather);
    }
  }
  calculateWeatherImpacts(weather) {
    const baseImpacts = {
      rain: {
        transport: 0.8,
        mood: 0.7,
        energy: 1.1,
        activities: ["outdoor_events", "construction"]
      },
      snow: {
        transport: 0.5,
        mood: 0.6,
        energy: 1.3,
        activities: ["transport", "outdoor_work", "construction"]
      },
      heat: {
        transport: 0.9,
        mood: 0.6,
        energy: 1.4,
        activities: ["outdoor_events", "construction"]
      },
      storm: {
        transport: 0.4,
        mood: 0.5,
        energy: 1.2,
        activities: ["all_outdoor"]
      }
    };
    const impact = baseImpacts[weather.type];
    const environmentalFactor = this.calculateEnvironmentalFactor(weather.environmentalMetrics);
    return {
      transport: impact.transport * (1 - weather.severity * 0.5) * environmentalFactor,
      mood: impact.mood * (1 - weather.severity * 0.3) * environmentalFactor,
      energy: impact.energy * (1 + weather.severity * 0.2),
      activities: impact.activities
    };
  }
  calculateEnvironmentalFactor(metrics) {
    if (!metrics)
      return 1;
    const visibilityImpact = metrics.visibility / 10;
    const windImpact = Math.max(0, 1 - metrics.windSpeed / 30);
    const airQualityImpact = metrics.airQuality / 100;
    return (visibilityImpact + windImpact + airQualityImpact) / 3;
  }
  async handleSevereWeather(weather) {
    const emergencyType = this.determineEmergencyType(weather);
    if (emergencyType) {
      await this.emergencyService.handleEmergency({
        id: `weather-emergency-${Date.now()}`,
        type: emergencyType,
        priority: weather.severity > 0.9 ? "critical" : "high",
        location: {
          districtId: weather.affectedDistricts[0],
          coordinates: await this.getDistrictCoordinates(weather.affectedDistricts[0])
        },
        description: `Severe ${weather.type} causing emergency conditions`,
        affectedArea: {
          radius: 5000,
          districtIds: weather.affectedDistricts
        },
        status: "reported",
        timestamp: Date.now(),
        responseUnits: []
      });
    }
  }
  async getDistrictCoordinates(districtId) {
    const districtsContext = this.cityService.getContext();
    const district = Array.from(districtsContext.districts.values()).find((d) => d.id === districtId);
    if (!district || !district.boundaries || district.boundaries.length === 0) {
      return [0, 0];
    }
    const sumLat = district.boundaries.reduce((sum, coord) => sum + coord[0], 0);
    const sumLng = district.boundaries.reduce((sum, coord) => sum + coord[1], 0);
    return [
      sumLat / district.boundaries.length,
      sumLng / district.boundaries.length
    ];
  }
  determineEmergencyType(weather) {
    if (weather.severity < 0.7)
      return null;
    switch (weather.type) {
      case "storm":
        return "disaster" /* DISASTER */;
      case "snow":
        return "infrastructure" /* INFRASTRUCTURE */;
      case "heat":
        return "environmental" /* ENVIRONMENTAL */;
      default:
        return weather.severity > 0.9 ? "disaster" /* DISASTER */ : null;
    }
  }
  getCurrentWeather() {
    return this.currentWeather;
  }
  getWeatherHistory(hours = 24) {
    const cutoff = Date.now() - hours * 60 * 60 * 1000;
    return this.weatherHistory.filter((w) => w.startTime >= cutoff);
  }
  getWeatherPredictions() {
    return this.weatherPredictions;
  }
  assessEnvironmentalImpact(alert) {
    return {
      severity: alert.severity || 0,
      type: alert.type,
      duration: alert.estimatedDuration || 1
    };
  }
  async adjustWeatherResponse(impact) {
    if (this.currentWeather) {
      const adjustedWeather = {
        ...this.currentWeather,
        severity: Math.max(this.currentWeather.severity, impact.severity),
        environmentalMetrics: await this.measureEnvironmentalMetrics()
      };
      await this.setWeatherCondition(adjustedWeather);
    }
  }
}

// src/services/social-dynamics.service.ts
import { EventEmitter as EventEmitter22 } from "events";
class SocialDynamicsService extends EventEmitter22 {
  vectorStore;
  departmentService;
  citizenService;
  weatherService;
  cityRhythmService;
  activities = new Map;
  communityMood = {};
  eventBus;
  constructor(vectorStore, departmentService, citizenService, weatherService, cityRhythmService) {
    super();
    this.vectorStore = vectorStore;
    this.departmentService = departmentService;
    this.citizenService = citizenService;
    this.weatherService = weatherService;
    this.cityRhythmService = cityRhythmService;
    this.eventBus = EventBus.getInstance();
    this.initializeSocialSystem();
  }
  async initializeSocialSystem() {
    this.weatherService.on("weatherChanged", this.handleWeatherChange.bind(this));
    this.cityRhythmService.on("rhythmUpdated", this.adjustActivities.bind(this));
    this.eventBus.on("aiAgentAction", this.handleAIAgentAction.bind(this));
    this.eventBus.on("culturalEvent", this.handleCulturalEvent.bind(this));
    setInterval(() => this.simulateSocialDynamics(), 1000 * 60 * 15);
    setInterval(() => this.analyzeAIHumanInteractions(), 1000 * 60 * 10);
    setInterval(() => this.updateSocialMetrics(), 1000 * 60 * 5);
  }
  async analyzeAIHumanInteractions() {
    const activities = Array.from(this.activities.values()).filter((a) => a.status === "active").filter((a) => this.hasAIInteraction(a));
    for (const activity of activities) {
      const aiImpact = await this.calculateAIImpact(activity);
      this.eventBus.emit("aiInteractionAnalyzed", {
        activityId: activity.id,
        impact: aiImpact,
        timestamp: Date.now()
      });
    }
  }
  hasAIInteraction(activity) {
    const type3 = activity.type;
    return type3 === "ai_assisted_learning" || type3 === "ai_cultural_exchange" || type3 === "smart_community_gathering";
  }
  async calculateAIImpact(activity) {
    return {
      socialCohesion: this.calculateSocialCohesionImpact(activity),
      culturalIntegration: await this.calculateCulturalIntegrationImpact(activity),
      communityEngagement: this.calculateCommunityEngagementImpact(activity),
      aiTrust: await this.calculateAITrustImpact(activity)
    };
  }
  getBaseImpact(type3) {
    const impacts = {
      community_meeting: { community: 0.7, economy: 0.3, satisfaction: 0.6 },
      cultural_event: { community: 0.8, economy: 0.6, satisfaction: 0.8 },
      protest: { community: 0.9, economy: 0.4, satisfaction: 0.5 },
      celebration: { community: 0.9, economy: 0.7, satisfaction: 0.9 },
      market: { community: 0.6, economy: 0.9, satisfaction: 0.7 },
      education: { community: 0.7, economy: 0.5, satisfaction: 0.7 },
      sports: { community: 0.8, economy: 0.6, satisfaction: 0.8 },
      entertainment: { community: 0.6, economy: 0.8, satisfaction: 0.8 },
      ai_assisted_learning: { community: 0.8, economy: 0.7, satisfaction: 0.8 },
      ai_cultural_exchange: { community: 0.9, economy: 0.6, satisfaction: 0.8 },
      smart_community_gathering: {
        community: 0.8,
        economy: 0.5,
        satisfaction: 0.9
      }
    };
    return impacts[type3];
  }
  async handleAIAgentAction(action) {
    if (action.type === "social_interaction") {
      const newActivity = {
        id: crypto.randomUUID(),
        type: "cultural_event",
        title: action.title,
        description: action.description,
        location: action.location,
        schedule: {
          start: Date.now(),
          end: Date.now() + 3600000
        },
        participants: {
          expected: 20,
          current: 0,
          demographics: {
            districts: {},
            satisfaction: 0
          }
        },
        status: "active",
        organizer: {
          departmentId: "AI_SYSTEM"
        },
        impact: this.getBaseImpact("cultural_event"),
        relatedEvents: []
      };
      const impact = await this.calculateAIImpact(newActivity);
      this.eventBus.emit("aiSocialImpactAnalyzed", {
        actionId: action.id,
        impact,
        timestamp: Date.now()
      });
    }
  }
  async handleCulturalEvent(event) {
    const aiParticipation = await this.analyzeAIParticipation(event);
    if (aiParticipation.level > 0.3) {
      this.eventBus.emit("aiCulturalParticipation", {
        eventId: event.id,
        participation: aiParticipation,
        timestamp: Date.now()
      });
    }
  }
  async analyzeAIParticipation(event) {
    return {
      level: 0.5,
      impact: 0.7,
      engagementQuality: 0.8
    };
  }
  async createActivity(activity) {
    const newActivity = {
      id: crypto.randomUUID(),
      ...activity,
      impact: await this.predictActivityImpact(activity),
      relatedEvents: await this.findRelatedEvents(activity)
    };
    this.activities.set(newActivity.id, newActivity);
    await this.storeActivity(newActivity);
    await this.notifyRelevantDepartments(newActivity);
    return newActivity;
  }
  async predictActivityImpact(activity) {
    const baseImpact = this.getBaseImpact(activity.type);
    const weatherImpact = await this.calculateWeatherImpact(activity);
    const timeImpact = this.calculateTimeImpact(activity.schedule);
    return {
      community: baseImpact.community * weatherImpact * timeImpact,
      economy: baseImpact.economy * weatherImpact * timeImpact,
      satisfaction: baseImpact.satisfaction * weatherImpact * timeImpact
    };
  }
  async calculateWeatherImpact(activity) {
    const currentWeather = this.weatherService.getCurrentWeather();
    if (!currentWeather)
      return 1;
    const isOutdoor = ["market", "sports", "celebration"].includes(activity.type);
    if (!isOutdoor)
      return 0.9;
    return Math.max(0.3, 1 - currentWeather.severity);
  }
  calculateTimeImpact(schedule) {
    const now = Date.now();
    const { start, end } = schedule;
    if (now < start || now > end)
      return 0;
    const totalDuration = end - start;
    const elapsed = now - start;
    const progress = elapsed / totalDuration;
    return 1 - Math.abs(progress - 0.5) * 0.5;
  }
  async storeActivity(activity) {
    await this.vectorStore.upsert({
      id: `social-activity-${activity.id}`,
      values: await this.vectorStore.createEmbedding(`${activity.type} ${activity.title}: ${activity.description}`),
      metadata: {
        type: "district",
        activityId: activity.id,
        activityType: activity.type,
        districtId: activity.location.districtId,
        timestamp: activity.schedule.start
      }
    });
  }
  async notifyRelevantDepartments(activity) {
    const departments = await this.departmentService.getAllDepartments();
    const relevantDepts = departments.filter((dept) => this.isActivityRelevantToDepartment(activity, dept.type));
    for (const dept of relevantDepts) {
      await this.departmentService.addActivity(dept.id, {
        type: "social_activity",
        activityId: activity.id,
        timestamp: Date.now()
      });
    }
  }
  async simulateSocialDynamics() {
    for (const activity of this.activities.values()) {
      if (activity.status === "active") {
        await this.updateActivityMetrics(activity);
      }
    }
    await this.updateCommunityMood();
  }
  async updateActivityMetrics(activity) {
    const currentParticipants = await this.calculateCurrentParticipants(activity);
    const updatedActivity = {
      ...activity,
      participants: {
        ...activity.participants,
        current: currentParticipants
      }
    };
    this.activities.set(activity.id, updatedActivity);
    this.emit("activityUpdated", updatedActivity);
  }
  async calculateCurrentParticipants(activity) {
    const baseParticipants = activity.participants.expected;
    const weatherImpact = await this.calculateWeatherImpact(activity);
    const timeImpact = this.calculateTimeImpact(activity.schedule);
    return Math.floor(baseParticipants * weatherImpact * timeImpact);
  }
  async updateCommunityMood() {
    const districts = await this.departmentService.getAllDepartments();
    for (const district of districts) {
      const activities = Array.from(this.activities.values()).filter((a) => a.location.districtId === district.id && a.status === "active");
      const moodImpact = activities.reduce((acc, activity) => acc + activity.impact.satisfaction, 0) / Math.max(activities.length, 1);
      this.communityMood[district.id] = moodImpact;
    }
    this.emit("communityMoodUpdated", this.communityMood);
  }
  isActivityRelevantToDepartment(activity, departmentType) {
    const relevance = {
      community_meeting: ["social_services", "public_safety"],
      cultural_event: ["social_services", "urban_planning"],
      protest: ["public_safety", "emergency_response"],
      celebration: ["social_services", "urban_planning"],
      market: ["urban_planning", "infrastructure"],
      education: ["social_services"],
      sports: ["social_services", "infrastructure"],
      entertainment: ["urban_planning", "social_services"]
    };
    return relevance[activity.type].includes(departmentType);
  }
  async findRelatedEvents(activity) {
    const embedding = await this.vectorStore.createEmbedding(`${activity.type} ${activity.title} ${activity.description}`);
    const similar = await this.vectorStore.query({
      vector: embedding,
      filter: {
        type: { $eq: "district" },
        timestamp: {
          $gt: Date.now() - 30 * 24 * 60 * 60 * 1000
        }
      },
      topK: 5
    });
    return similar.matches.filter((match) => match.metadata.activityId).map((match) => match.metadata.activityId);
  }
  async handleWeatherChange(weather) {
    const currentActivities = Array.from(this.activities.values()).filter((a) => a.status === "active");
    for (const activity of currentActivities) {
      const isOutdoor = ["market", "sports", "celebration"].includes(activity.type);
      if (isOutdoor && weather.severity > 0.7) {
        const updatedActivity = {
          ...activity,
          participants: {
            ...activity.participants,
            current: Math.floor(activity.participants.current * (1 - weather.severity * 0.5))
          }
        };
        this.activities.set(activity.id, updatedActivity);
        this.emit("activityUpdated", updatedActivity);
      }
    }
  }
  async adjustActivities(cityRhythm) {
    const { hour: hour2, patterns: patterns3 } = cityRhythm;
    const currentActivities = Array.from(this.activities.values()).filter((a) => a.status === "active");
    for (const activity of currentActivities) {
      const timeImpact = this.calculateTimeImpact(activity.schedule);
      const rhythmImpact = this.calculateRhythmImpact(patterns3);
      const updatedActivity = {
        ...activity,
        participants: {
          ...activity.participants,
          current: Math.floor(activity.participants.expected * timeImpact * rhythmImpact)
        }
      };
      this.activities.set(activity.id, updatedActivity);
      this.emit("activityUpdated", updatedActivity);
    }
  }
  calculateRhythmImpact(patterns3) {
    const relevantPatterns = patterns3.filter((p) => ["leisure", "social"].includes(p.type));
    if (relevantPatterns.length === 0)
      return 0.5;
    return relevantPatterns.reduce((acc, pattern2) => acc + pattern2.intensity, 0) / relevantPatterns.length;
  }
  async getCommunityMood(districtId) {
    return {
      positivity: 0.8,
      engagement: 0.7
    };
  }
  async updateSocialMetrics() {
    const activities = Array.from(this.activities.values());
    const metrics = {
      totalParticipants: activities.reduce((sum, a) => sum + (a.participants.current || 0), 0),
      activeEvents: activities.filter((a) => a.status === "active").length,
      averageImpact: this.calculateAverageImpact(activities),
      aiIntegrationLevel: await this.calculateAIIntegrationLevel(activities)
    };
    this.eventBus.emit("socialMetricsUpdated", metrics);
  }
  calculateAverageImpact(activities) {
    return activities.reduce((sum, a) => sum + a.impact.satisfaction, 0) / activities.length;
  }
  async calculateAIIntegrationLevel(activities) {
    const aiActivities = activities.filter((a) => [
      "ai_assisted_learning",
      "ai_cultural_exchange",
      "smart_community_gathering"
    ].includes(a.type));
    return aiActivities.length / activities.length;
  }
  calculateSocialCohesionImpact(activity) {
    return activity.impact.community * (activity.participants.current / activity.participants.expected);
  }
  async calculateCulturalIntegrationImpact(activity) {
    const baseImpact = activity.impact.satisfaction;
    const culturalFactor = activity.type === "cultural_event" ? 1.2 : 1;
    return baseImpact * culturalFactor;
  }
  calculateCommunityEngagementImpact(activity) {
    return (activity.impact.community + activity.impact.satisfaction) / 2;
  }
  async calculateAITrustImpact(activity) {
    const baseImpact = activity.impact.satisfaction;
    const aiInvolvement = [
      "ai_assisted_learning",
      "ai_cultural_exchange",
      "smart_community_gathering"
    ].includes(activity.type) ? 1.5 : 1;
    return baseImpact * aiInvolvement;
  }
}

// src/services/city-rhythm.service.ts
import { EventEmitter as EventEmitter23 } from "events";

class CityRhythmService extends EventEmitter23 {
  vectorStore;
  citizenService;
  transportService;
  departmentService;
  currentHour = 0;
  activityPatterns = [];
  constructor(vectorStore, citizenService, transportService, departmentService) {
    super();
    this.vectorStore = vectorStore;
    this.citizenService = citizenService;
    this.transportService = transportService;
    this.departmentService = departmentService;
    this.initializePatterns();
  }
  initializePatterns() {
    this.activityPatterns = [
      { hour: 7, type: "transport", intensity: 0.7, locations: [] },
      { hour: 8, type: "business", intensity: 0.9, locations: [] },
      { hour: 12, type: "social", intensity: 0.6, locations: [] },
      { hour: 17, type: "transport", intensity: 0.8, locations: [] },
      { hour: 18, type: "leisure", intensity: 0.7, locations: [] },
      { hour: 20, type: "social", intensity: 0.5, locations: [] }
    ];
  }
  async getCurrentPatterns() {
    return this.activityPatterns.filter((p) => p.hour === this.currentHour);
  }
  async addActivityPattern(pattern2) {
    if (pattern2.hour < 0 || pattern2.hour > 23) {
      throw new Error("Invalid hour. Must be between 0 and 23");
    }
    if (pattern2.intensity < 0 || pattern2.intensity > 1) {
      throw new Error("Invalid intensity. Must be between 0 and 1");
    }
    const existingIndex = this.activityPatterns.findIndex((p) => p.hour === pattern2.hour && p.type === pattern2.type);
    if (existingIndex >= 0) {
      this.activityPatterns[existingIndex] = pattern2;
    } else {
      this.activityPatterns.push(pattern2);
    }
    await this.vectorStore.upsert({
      id: `pattern-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(`Activity pattern: ${pattern2.type} at hour ${pattern2.hour}`),
      metadata: {
        type: "district",
        patternType: pattern2.type,
        hour: pattern2.hour,
        intensity: pattern2.intensity,
        locations: pattern2.locations,
        timestamp: Date.now()
      }
    });
    this.emit("patternAdded", pattern2);
  }
  async getActivityForecast(type3) {
    const forecasts = [];
    const nextHours = Array.from({ length: 24 }, (_5, i) => (this.currentHour + i) % 24);
    for (const hour2 of nextHours) {
      const patterns3 = this.activityPatterns.filter((p) => p.hour === hour2 && (!type3 || p.type === type3));
      if (patterns3.length > 0) {
        forecasts.push({
          hour: hour2,
          predictions: patterns3.map((p) => ({
            type: p.type,
            intensity: p.intensity,
            confidence: this.calculateConfidence(p)
          }))
        });
      }
    }
    return forecasts;
  }
  calculateConfidence(pattern2) {
    let confidence = 0.8;
    const hourDiff = Math.abs(pattern2.hour - this.currentHour);
    confidence -= hourDiff * 0.02;
    switch (pattern2.type) {
      case "transport":
        confidence += 0.1;
        break;
      case "business":
        confidence += 0.05;
        break;
      case "social":
        confidence -= 0.1;
        break;
      case "leisure":
        confidence -= 0.05;
        break;
    }
    return Math.max(0, Math.min(1, confidence));
  }
  async simulateDailyRoutines(hour2) {
    this.currentHour = hour2;
    const patterns3 = this.activityPatterns.filter((p) => p.hour === hour2);
    for (const pattern2 of patterns3) {
      await this.executeActivityPattern(pattern2);
    }
    await this.vectorStore.upsert({
      id: `city-rhythm-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(`City activity at hour ${hour2}`),
      metadata: {
        type: "district",
        hour: hour2,
        patterns: patterns3.map((p) => p.type),
        timestamp: Date.now()
      }
    });
    this.emit("rhythmUpdated", { hour: hour2, patterns: patterns3 });
  }
  async executeActivityPattern(pattern2) {
    switch (pattern2.type) {
      case "transport":
        await this.increaseCitizenActivity("transport", pattern2.intensity);
        break;
      case "business":
        await this.openBusinesses(pattern2.intensity);
        break;
      case "leisure":
        await this.activateLeisureVenues(pattern2.intensity);
        break;
      case "social":
        await this.schedulePublicEvents(pattern2.intensity);
        break;
    }
  }
  async increaseCitizenActivity(type3, intensity) {
    await this.transportService.adjustCapacity(intensity);
    await this.citizenService.updateActivityLevels(type3, intensity);
  }
  async openBusinesses(intensity) {
    const departments = await this.departmentService.getAllDepartments();
    for (const dept of departments) {
      if (dept.type === "urban_planning") {
        await this.departmentService.addActivity(dept.id, {
          type: "business_hours",
          intensity,
          timestamp: Date.now()
        });
      }
    }
  }
  async activateLeisureVenues(intensity) {
  }
  async schedulePublicEvents(intensity) {
  }
  async adjustForWeather(weather) {
  }
}

// src/services/transport.service.ts
import { EventEmitter as EventEmitter24 } from "events";

class TransportService extends EventEmitter24 {
  vectorStore;
  weatherService;
  cityRhythmService;
  emergencyService;
  districtService;
  metricsService;
  routes = new Map;
  stops = new Map;
  systemEfficiency = 1;
  updateInterval;
  constructor(vectorStore, weatherService, cityRhythmService, emergencyService, districtService, metricsService) {
    super();
    this.vectorStore = vectorStore;
    this.weatherService = weatherService;
    this.cityRhythmService = cityRhythmService;
    this.emergencyService = emergencyService;
    this.districtService = districtService;
    this.metricsService = metricsService;
    this.initializeTransportSystem();
    this.setupEventListeners();
    this.startMetricsTracking();
  }
  getAllRoutes() {
    return Array.from(this.routes.values());
  }
  async initializeTransportSystem() {
    await this.generateBaseNetwork();
    setInterval(() => this.updateTransportMetrics(), 1000 * 60 * 5);
    setInterval(() => this.simulatePassengerFlow(), 1000 * 60);
  }
  setupEventListeners() {
    this.weatherService.on("weatherChanged", this.handleWeatherChange.bind(this));
    this.cityRhythmService.on("rhythmUpdated", this.adjustService.bind(this));
    this.emergencyService.on("emergencyResponse", this.handleEmergency.bind(this));
  }
  async adjustEfficiency(factor) {
    this.systemEfficiency = Math.max(0.3, Math.min(1, factor));
    await this.updateRouteEfficiencies();
  }
  async updateRouteEfficiencies() {
    for (const route of this.routes.values()) {
      const updatedRoute = {
        ...route,
        metrics: {
          ...route.metrics,
          efficiency: route.metrics.efficiency * this.systemEfficiency
        }
      };
      this.routes.set(route.id, updatedRoute);
      await this.storeRouteUpdate(updatedRoute);
    }
  }
  async storeRouteUpdate(route) {
    await this.vectorStore.upsert({
      id: `transport-route-${route.id}-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(`${route.mode} route ${route.name} with efficiency ${route.metrics.efficiency}`),
      metadata: {
        type: "district",
        routeId: route.id,
        mode: route.mode,
        efficiency: route.metrics.efficiency,
        timestamp: Date.now()
      }
    });
  }
  async generateBaseNetwork() {
    const modes = ["bus", "subway", "tram"];
    modes.forEach((mode) => {
      for (let i = 0;i < this.getRouteCount(mode); i++) {
        const route = this.createRoute(mode);
        this.routes.set(route.id, route);
      }
    });
  }
  createRoute(mode) {
    return {
      id: crypto.randomUUID(),
      mode,
      type: mode === "subway" ? "metro" : mode,
      name: `${mode.charAt(0).toUpperCase()}${mode.slice(1)} Route`,
      stops: [],
      schedule: this.generateSchedule(mode),
      status: "active",
      capacity: this.getBaseCapacity(mode),
      metrics: {
        reliability: 0.9,
        satisfaction: 0.8,
        efficiency: 1,
        utilization: 0
      }
    };
  }
  getRouteCount(mode) {
    const counts = {
      bus: 10,
      subway: 3,
      tram: 5,
      bike: 0,
      pedestrian: 0,
      car: 0
    };
    return counts[mode];
  }
  getBaseCapacity(mode) {
    const capacities = {
      bus: 50,
      subway: 200,
      tram: 100,
      bike: 1,
      pedestrian: 1,
      car: 5
    };
    return {
      max: capacities[mode],
      current: 0
    };
  }
  generateSchedule(mode) {
    return {
      weekday: [
        { start: 6, end: 9, frequency: 10, capacity: 1 },
        { start: 9, end: 16, frequency: 15, capacity: 0.7 },
        { start: 16, end: 19, frequency: 10, capacity: 1 },
        { start: 19, end: 23, frequency: 20, capacity: 0.5 }
      ],
      weekend: [{ start: 8, end: 23, frequency: 20, capacity: 0.6 }],
      frequency: mode === "subway" ? 5 : mode === "tram" ? 10 : 15,
      lastUpdated: Date.now()
    };
  }
  async updateTransportMetrics() {
    const routes = Array.from(this.routes.values());
    const avgEfficiency = routes.reduce((sum, r) => sum + r.metrics.efficiency, 0) / routes.length;
    const avgReliability = routes.reduce((sum, r) => sum + r.metrics.reliability, 0) / routes.length;
    const avgSatisfaction = routes.reduce((sum, r) => sum + r.metrics.satisfaction, 0) / routes.length;
    const congestionLevel = 1 - avgEfficiency;
    await this.metricsService.updateMetrics({
      infrastructure: {
        trafficCongestion: congestionLevel,
        publicTransitReliability: avgReliability,
        infrastructureHealth: avgEfficiency,
        smartGridEfficiency: this.systemEfficiency,
        wasteRecyclingRate: 0.6
      }
    });
    for (const route of routes) {
      const metrics = await this.calculateRouteMetrics(route);
      const updatedRoute = { ...route, metrics };
      this.routes.set(route.id, updatedRoute);
    }
    this.emit("metricsUpdated", {
      efficiency: avgEfficiency,
      reliability: avgReliability,
      satisfaction: avgSatisfaction,
      congestion: congestionLevel
    });
  }
  async calculateRouteMetrics(route) {
    const weather = this.weatherService.getCurrentWeather();
    const weatherImpact = weather ? 1 - weather.severity * 0.3 : 1;
    return {
      reliability: route.metrics.reliability * weatherImpact,
      satisfaction: route.metrics.satisfaction * this.systemEfficiency,
      efficiency: route.metrics.efficiency * this.systemEfficiency * weatherImpact,
      utilization: route.capacity.current / route.capacity.max
    };
  }
  async simulatePassengerFlow() {
    const hour2 = new Date().getHours();
    const isWeekend = [0, 6].includes(new Date().getDay());
    for (const route of this.routes.values()) {
      const schedule = isWeekend ? route.schedule.weekend : route.schedule.weekday;
      const timeSlot = schedule.find((slot) => hour2 >= slot.start && hour2 < slot.end);
      if (timeSlot) {
        const baseFlow = route.capacity.max * timeSlot.capacity;
        const actualFlow = baseFlow * this.systemEfficiency;
        const updatedRoute = {
          ...route,
          capacity: {
            ...route.capacity,
            current: Math.min(route.capacity.max, actualFlow)
          }
        };
        this.routes.set(route.id, updatedRoute);
      }
    }
  }
  async handleWeatherChange(weather) {
    if (weather.severity > 0.5) {
      const impactedModes = this.getWeatherImpactedModes(weather.type);
      await this.adjustServiceForWeather(impactedModes, weather.severity);
    }
  }
  getWeatherImpactedModes(weatherType) {
    const impacts = {
      rain: ["bike", "pedestrian"],
      snow: ["bus", "bike", "pedestrian"],
      storm: ["bus", "tram", "bike", "pedestrian"],
      heat: ["pedestrian"]
    };
    return impacts[weatherType] || [];
  }
  async adjustServiceForWeather(modes, severity) {
    for (const route of this.routes.values()) {
      if (modes.includes(route.mode)) {
        const updatedRoute = {
          ...route,
          status: severity > 0.8 ? "suspended" : "delayed",
          metrics: {
            ...route.metrics,
            efficiency: route.metrics.efficiency * (1 - severity * 0.5)
          }
        };
        this.routes.set(route.id, updatedRoute);
      }
    }
  }
  async handleEmergency(emergency) {
    const affectedRoutes = this.findRoutesInArea(emergency.affectedArea);
    for (const route of affectedRoutes) {
      const updatedRoute = {
        ...route,
        status: "delayed",
        metrics: {
          ...route.metrics,
          efficiency: route.metrics.efficiency * 0.7
        }
      };
      this.routes.set(route.id, updatedRoute);
    }
  }
  findRoutesInArea(area) {
    return Array.from(this.routes.values()).filter((route) => route.stops.some((stop) => area.districtIds.includes(stop.location.districtId)));
  }
  createDefaultRoutes() {
    return [
      {
        id: crypto.randomUUID(),
        mode: "bus",
        name: "Downtown Express",
        type: "bus",
        stops: [],
        schedule: this.createDefaultSchedule(),
        status: "active",
        capacity: {
          max: 50,
          current: 0
        },
        metrics: {
          reliability: 0.9,
          satisfaction: 0.85,
          efficiency: 0.8,
          utilization: 0
        }
      }
    ];
  }
  async updateRouteMetrics(routeId) {
    const route = this.routes.get(routeId);
    if (!route)
      return;
    const newStatus = this.determineRouteStatus(route);
    const updatedRoute = {
      ...route,
      status: newStatus,
      metrics: {
        reliability: this.calculateReliability(route),
        efficiency: this.calculateEfficiency(route),
        utilization: this.calculateUtilization(route),
        satisfaction: this.calculateSatisfaction(route)
      }
    };
    await this.adjustService(routeId, updatedRoute);
  }
  determineRouteStatus(route) {
    const reliability = this.calculateReliability(route);
    if (reliability < 0.3)
      return "suspended";
    if (reliability < 0.7)
      return "delayed";
    return "active";
  }
  calculateReliability(route) {
    const baseReliability = 0.95;
    const weatherImpact = this.weatherService.getCurrentWeather()?.severity || 0;
    const stopComplexityFactor = Math.max(0.7, 1 - route.stops.length * 0.02);
    const reliability = baseReliability * (1 - weatherImpact * 0.3) * this.systemEfficiency * stopComplexityFactor;
    return Math.max(0.3, Math.min(1, reliability));
  }
  calculateEfficiency(route) {
    const utilizationScore = this.calculateUtilization(route);
    const modeEfficiency = this.getModeEfficiency(route.mode);
    const directness = route.stops.length > 1 ? this.calculateRouteDirectness(route.stops.map((stop) => stop.location.coordinates)) : 1;
    const efficiency = (utilizationScore * 0.4 + modeEfficiency * 0.3 + directness * 0.3) * this.systemEfficiency;
    return Math.max(0.3, Math.min(1, efficiency));
  }
  calculateUtilization(route) {
    const baseUtilization = route.capacity.current / route.capacity.max;
    const hour2 = new Date().getHours();
    const isWeekend = [0, 6].includes(new Date().getDay());
    const schedule = isWeekend ? route.schedule.weekend : route.schedule.weekday;
    const timeSlot = schedule.find((slot) => hour2 >= slot.start && hour2 < slot.end);
    const expectedCapacity = timeSlot ? timeSlot.capacity : 0.5;
    const adjustedUtilization = baseUtilization / expectedCapacity;
    return Math.max(0, Math.min(1, adjustedUtilization));
  }
  calculateSatisfaction(route) {
    const reliability = this.calculateReliability(route);
    const crowdingFactor = 1 - this.calculateUtilization(route) * 0.5;
    const hour2 = new Date().getHours();
    const isWeekend = [0, 6].includes(new Date().getDay());
    const schedule = isWeekend ? route.schedule.weekend : route.schedule.weekday;
    const timeSlot = schedule.find((slot) => hour2 >= slot.start && hour2 < slot.end);
    const frequencySatisfaction = timeSlot ? Math.max(0.5, 1 - timeSlot.frequency / 60 * 0.5) : 0.5;
    const comfortFactor = this.getModeComfort(route.mode);
    const satisfaction = reliability * 0.3 + crowdingFactor * 0.3 + frequencySatisfaction * 0.2 + comfortFactor * 0.2;
    return Math.max(0.3, Math.min(1, satisfaction));
  }
  getModeEfficiency(mode) {
    const efficiencies = {
      subway: 0.95,
      tram: 0.9,
      bus: 0.7,
      bike: 1,
      pedestrian: 1,
      car: 0.5
    };
    return efficiencies[mode];
  }
  getModeComfort(mode) {
    const comfort = {
      subway: 0.8,
      tram: 0.85,
      bus: 0.75,
      bike: 0.7,
      pedestrian: 0.9,
      car: 0.95
    };
    return comfort[mode];
  }
  calculateRouteDirectness(coordinates) {
    if (coordinates.length < 2)
      return 1;
    let actualDistance = 0;
    for (let i = 1;i < coordinates.length; i++) {
      actualDistance += this.calculateDistance(coordinates[i - 1], coordinates[i]);
    }
    const directDistance = this.calculateDistance(coordinates[0], coordinates[coordinates.length - 1]);
    const directness = directDistance / actualDistance;
    return Math.max(0.5, Math.min(1, directness));
  }
  createDefaultSchedule() {
    return {
      weekday: [
        { start: 6, end: 9, frequency: 15, capacity: 50 },
        { start: 9, end: 16, frequency: 30, capacity: 40 },
        { start: 16, end: 19, frequency: 15, capacity: 50 },
        { start: 19, end: 23, frequency: 30, capacity: 30 }
      ],
      weekend: [
        { start: 8, end: 12, frequency: 30, capacity: 40 },
        { start: 12, end: 20, frequency: 45, capacity: 30 }
      ],
      frequency: 30,
      lastUpdated: Date.now()
    };
  }
  async updateRoutes(adjustments) {
    try {
      for (const adjustment of adjustments) {
        const nearbyRoutes = await this.getNearbyRoutes(adjustment.location, 1000);
        for (const route of nearbyRoutes) {
          const districtId = await this.findNearestDistrict(adjustment.suggestedStops.primaryStop.coordinates);
          const updatedRoute = {
            ...route,
            stops: [
              ...route.stops,
              {
                id: crypto.randomUUID(),
                name: adjustment.suggestedStops.primaryStop.name,
                location: {
                  coordinates: adjustment.suggestedStops.primaryStop.coordinates,
                  districtId
                },
                type: adjustment.suggestedStops.primaryStop.type,
                priority: adjustment.priority,
                routes: [route.id],
                facilities: [],
                crowding: 0
              }
            ],
            metrics: {
              ...route.metrics,
              efficiency: route.metrics.efficiency * 0.9
            }
          };
          this.routes.set(route.id, updatedRoute);
          await this.storeRouteUpdate(updatedRoute);
        }
      }
      this.emit("routes:updated", adjustments);
    } catch (error4) {
      console.error("Failed to update routes:", error4);
      throw error4;
    }
  }
  async modifyRoutes(adjustments) {
    try {
      for (const adjustment of adjustments) {
        const route = this.routes.get(adjustment.routeId);
        if (!route)
          continue;
        const updatedStops = [...route.stops];
        if (adjustment.temporaryStops) {
          for (const stop of adjustment.temporaryStops) {
            const districtId = await this.findNearestDistrict(stop.coordinates);
            updatedStops.push({
              id: crypto.randomUUID(),
              name: stop.name,
              location: {
                coordinates: stop.coordinates,
                districtId
              },
              type: stop.type,
              temporary: true,
              duration: stop.duration,
              routes: [route.id],
              facilities: [],
              crowding: 0
            });
          }
        }
        const updatedRoute = {
          ...route,
          stops: updatedStops,
          metrics: {
            ...route.metrics,
            efficiency: route.metrics.efficiency * (adjustment.adjustmentType === "major" ? 0.7 : 0.9)
          }
        };
        this.routes.set(route.id, updatedRoute);
        await this.storeRouteUpdate(updatedRoute);
      }
      this.emit("routes:modified", adjustments);
    } catch (error4) {
      console.error("Failed to modify routes:", error4);
      throw error4;
    }
  }
  calculateDistance(point1, point2) {
    const [lat1, lon1] = point1;
    const [lat2, lon2] = point2;
    const R = 6371000;
    const \u{3c6}1 = lat1 * Math.PI / 180;
    const \u{3c6}2 = lat2 * Math.PI / 180;
    const \u{394}_ = (lat2 - lat1) * Math.PI / 180;
    const \u{394}_2 = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(\u{394}_ / 2) * Math.sin(\u{394}_ / 2) + Math.cos(\u{3c6}1) * Math.cos(\u{3c6}2) * Math.sin(\u{394}_2 / 2) * Math.sin(\u{394}_2 / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  async findNearestDistrict(location) {
    try {
      const districts = await this.districtService.getAllDistricts();
      let nearestDistrict = null;
      let shortestDistance = Infinity;
      for (const district of districts) {
        const districtCoords = await this.districtService.getDistrictCoordinates(district.id);
        if (!districtCoords)
          continue;
        const distance = this.calculateDistance(location, districtCoords);
        if (distance < shortestDistance) {
          shortestDistance = distance;
          nearestDistrict = district;
        }
      }
      if (!nearestDistrict) {
        console.warn(`No nearest district found for location [${location}]`);
        return "downtown";
      }
      return nearestDistrict.id;
    } catch (error4) {
      console.error("Error finding nearest district:", error4);
      return "downtown";
    }
  }
  async getNearbyRoutes(location, radius) {
    try {
      return Array.from(this.routes.values()).filter((route) => {
        return route.stops.some((stop) => {
          const distance = this.calculateDistance(stop.location.coordinates, location);
          return distance <= radius;
        });
      });
    } catch (error4) {
      console.error("Failed to get nearby routes:", error4);
      throw error4;
    }
  }
  startMetricsTracking() {
    setInterval(() => this.updateTransportMetrics(), 5 * 60 * 1000);
  }
  async adjustService(rhythm) {
    const adjustmentFactor = this.calculateAdjustmentFactor(rhythm);
    await this.adjustEfficiency(adjustmentFactor);
    for (const route of this.routes.values()) {
      const updatedSchedule = this.adjustScheduleForRhythm(route.schedule, rhythm);
      const updatedRoute = { ...route, schedule: updatedSchedule };
      this.routes.set(route.id, updatedRoute);
      await this.storeRouteUpdate(updatedRoute);
    }
    this.emit("serviceAdjusted", {
      rhythmMood: rhythm.mood,
      adjustmentFactor,
      timestamp: Date.now()
    });
  }
  calculateAdjustmentFactor(rhythm) {
    const moodFactors = {
      busy: 1.2,
      relaxed: 0.8,
      festive: 1.1,
      quiet: 0.7
    };
    const baseFactor = moodFactors[rhythm.mood] || 1;
    return Math.max(0.3, Math.min(1.5, baseFactor * rhythm.intensity));
  }
  adjustScheduleForRhythm(schedule, rhythm) {
    const adjustedWeekday = schedule.weekday.map((slot) => ({
      ...slot,
      frequency: this.adjustFrequencyForRhythm(slot.frequency, rhythm),
      capacity: this.adjustCapacityForRhythm(slot.capacity, rhythm)
    }));
    const adjustedWeekend = schedule.weekend.map((slot) => ({
      ...slot,
      frequency: this.adjustFrequencyForRhythm(slot.frequency, rhythm),
      capacity: this.adjustCapacityForRhythm(slot.capacity, rhythm)
    }));
    return {
      ...schedule,
      weekday: adjustedWeekday,
      weekend: adjustedWeekend,
      lastUpdated: Date.now()
    };
  }
  adjustFrequencyForRhythm(baseFrequency, rhythm) {
    const factor = rhythm.mood === "busy" ? 0.8 : rhythm.mood === "quiet" ? 1.2 : 1;
    return Math.max(5, Math.round(baseFrequency * factor));
  }
  adjustCapacityForRhythm(baseCapacity, rhythm) {
    const factor = rhythm.mood === "busy" ? 1.2 : rhythm.mood === "quiet" ? 0.8 : 1;
    return Math.max(0.3, Math.min(1, baseCapacity * factor));
  }
}

// src/services/economy.service.ts
import { EventEmitter as EventEmitter25 } from "events";

class EconomyService extends EventEmitter25 {
  vectorStore;
  districtService;
  marketMetrics = new Map;
  economicIndicators = {
    gdp: 0,
    inflation: 0,
    unemployment: 0,
    economicGrowth: 0,
    marketStability: 0,
    aiProductivity: 0,
    digitalTransformation: 0,
    innovationIndex: 0
  };
  businesses = new Map;
  propertyMarkets = new Map;
  jobMarkets = new Map;
  investments = new Map;
  constructor(vectorStore, districtService) {
    super();
    this.vectorStore = vectorStore;
    this.districtService = districtService;
    this.initializeMonitoring();
  }
  initializeMonitoring() {
    setInterval(() => this.updateAIEconomicMetrics(), 1000 * 60 * 5);
    setInterval(() => this.analyzeDataMarket(), 1000 * 60 * 15);
    setInterval(() => this.calculateInnovationMetrics(), 1000 * 60 * 30);
  }
  async updateAIEconomicMetrics() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const metrics = this.marketMetrics.get(district.id) || {};
      const aiBusinesses = Array.from(this.businesses.values()).filter((b) => b.districtId === district.id && (b.type === "ai_services" || b.type === "data_processing"));
      metrics.aiEconomicActivity = this.calculateAIActivity(aiBusinesses);
      metrics.computationalResources = this.assessComputationalResources(district.id);
      metrics.dataMarketMetrics = this.evaluateDataMarket(district.id);
      this.marketMetrics.set(district.id, metrics);
      this.emit("aiMetricsUpdated", { districtId: district.id, metrics });
    }
  }
  async analyzeDataMarket() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const dataMarketValue = await this.calculateDataMarketValue(district.id);
      const dataTrading = await this.assessDataTrading(district.id);
      const dataUtilization = await this.measureDataUtilization(district.id);
      this.emit("dataMarketUpdated", {
        districtId: district.id,
        metrics: { dataMarketValue, dataTrading, dataUtilization }
      });
    }
  }
  async calculateInnovationMetrics() {
    const aiBusinesses = Array.from(this.businesses.values()).filter((b) => b.type === "ai_services" || b.type === "data_processing");
    const innovationIndex = this.calculateInnovationIndex(aiBusinesses);
    const digitalTransformation = this.assessDigitalTransformation();
    this.economicIndicators.innovationIndex = innovationIndex;
    this.economicIndicators.digitalTransformation = digitalTransformation;
    this.emit("innovationMetricsUpdated", {
      innovationIndex,
      digitalTransformation
    });
  }
  calculateAIActivity(aiBusinesses) {
    if (!aiBusinesses.length)
      return 0;
    return aiBusinesses.reduce((sum, business) => sum + (business.revenue * 0.4 + business.growth * 0.3 + (business.aiIntegration || 0) * 0.3), 0) / aiBusinesses.length;
  }
  assessComputationalResources(districtId) {
    const businesses = Array.from(this.businesses.values()).filter((b) => b.districtId === districtId);
    return businesses.reduce((sum, b) => sum + (b.dataUtilization || 0), 0) / Math.max(businesses.length, 1);
  }
  evaluateDataMarket(districtId) {
    const dataBusinesses = Array.from(this.businesses.values()).filter((b) => b.districtId === districtId && b.type === "data_processing");
    return dataBusinesses.reduce((sum, b) => sum + b.revenue, 0) / Math.max(dataBusinesses.length, 1);
  }
  async simulateMarket() {
    const districts = await this.districtService.getAllDistricts();
    for (const district of districts) {
      const metrics = {
        businessActivity: this.calculateBusinessActivity(district.id),
        jobMarket: this.calculateJobMarket(district.id),
        propertyValues: this.calculatePropertyValues(district.id),
        investmentFlow: this.calculateInvestmentFlow(district.id),
        consumerConfidence: this.calculateConsumerConfidence(district.id)
      };
      this.marketMetrics.set(district.id, metrics);
      this.emit("marketUpdated", { districtId: district.id, metrics });
    }
  }
  calculateBusinessActivity(districtId) {
    const businesses = Array.from(this.businesses.values()).filter((b) => b.districtId === districtId);
    return businesses.reduce((acc, b) => acc + (b.revenue * 0.3 + b.employment * 0.3 + b.growth * 0.4), 0) / Math.max(businesses.length, 1);
  }
  calculateJobMarket(districtId) {
    const jobMarket = this.jobMarkets.get(districtId);
    if (!jobMarket)
      return 0.5;
    return jobMarket.employmentRate * 0.4 + jobMarket.jobCreationRate * 0.3 + jobMarket.openPositions / 100 * 0.3;
  }
  calculatePropertyValues(districtId) {
    const market = this.propertyMarkets.get(districtId);
    if (!market)
      return 0.5;
    return market.residentialValue * 0.4 + market.commercialValue * 0.4 + market.developmentPotential * 0.2;
  }
  calculateInvestmentFlow(districtId) {
    const districtInvestments = Array.from(this.investments.values()).filter((i) => i.districtId === districtId);
    return districtInvestments.reduce((acc, i) => acc + (i.amount * 0.4 + i.expectedReturn * 0.3 + i.culturalValue * 0.3), 0) / Math.max(districtInvestments.length, 1);
  }
  calculateConsumerConfidence(districtId) {
    const metrics = this.marketMetrics.get(districtId);
    if (!metrics)
      return 0.5;
    return metrics.businessActivity * 0.3 + metrics.jobMarket * 0.3 + metrics.propertyValues * 0.2 + metrics.investmentFlow * 0.2;
  }
  async updateEconomicIndicators() {
    const allMetrics = Array.from(this.marketMetrics.values());
    this.economicIndicators = {
      gdp: this.calculateGDP(allMetrics),
      inflation: this.calculateInflation(),
      unemployment: this.calculateUnemployment(),
      economicGrowth: this.calculateEconomicGrowth(),
      marketStability: this.calculateMarketStability(allMetrics)
    };
    this.emit("economicIndicatorsUpdated", this.economicIndicators);
  }
  calculateGDP(metrics) {
    return metrics.reduce((acc, m) => acc + m.businessActivity + m.investmentFlow, 0) * (1 + this.economicIndicators.economicGrowth);
  }
  calculateInflation() {
    const baseInflation = 0.02;
    const marketPressure = Array.from(this.marketMetrics.values()).reduce((acc, m) => acc + m.consumerConfidence, 0) / this.marketMetrics.size;
    return baseInflation * (1 + marketPressure);
  }
  calculateUnemployment() {
    const totalJobs = Array.from(this.jobMarkets.values()).reduce((acc, j) => acc + j.openPositions, 0);
    const totalEmployed = Array.from(this.jobMarkets.values()).reduce((acc, j) => acc + j.employmentRate * 100, 0);
    return Math.max(0, (totalJobs - totalEmployed) / totalJobs);
  }
  calculateEconomicGrowth() {
    return this.calculateAverageBusinessGrowth() * 0.4 + this.calculateInvestmentGrowth() * 0.3 + (1 - this.economicIndicators.unemployment) * 0.3;
  }
  calculateMarketStability(metrics) {
    const volatility = metrics.reduce((acc, m) => acc + Math.abs(m.businessActivity - m.consumerConfidence), 0) / metrics.length;
    return Math.max(0, 1 - volatility);
  }
  calculateAverageBusinessGrowth() {
    const businesses = Array.from(this.businesses.values());
    return businesses.reduce((acc, b) => acc + b.growth, 0) / Math.max(businesses.length, 1);
  }
  calculateInvestmentGrowth() {
    return Array.from(this.investments.values()).reduce((acc, i) => acc + i.expectedReturn, 0) / Math.max(this.investments.size, 1);
  }
  async processInvestments() {
    for (const investment of this.investments.values()) {
      const return_rate = this.calculateInvestmentReturn(investment);
      const cultural_impact = this.calculateCulturalImpact(investment);
      await this.vectorStore.upsert({
        id: `investment-${investment.id}`,
        values: await this.vectorStore.createEmbedding(`Investment in ${investment.type} with return rate ${return_rate} and cultural impact ${cultural_impact}`),
        metadata: {
          type: "district",
          investmentId: investment.id,
          investmentType: investment.type,
          districtId: investment.districtId,
          return_rate,
          cultural_impact,
          timestamp: Date.now()
        }
      });
      this.emit("investmentProcessed", {
        investmentId: investment.id,
        return_rate,
        cultural_impact
      });
    }
  }
  calculateInvestmentReturn(investment) {
    const marketMetrics = this.marketMetrics.get(investment.districtId);
    if (!marketMetrics)
      return 0;
    const aiBonus = (marketMetrics.aiEconomicActivity || 0) * 0.2;
    return investment.expectedReturn * 0.3 + marketMetrics.businessActivity * 0.2 + marketMetrics.consumerConfidence * 0.2 + aiBonus + (marketMetrics.dataMarketMetrics || 0) * 0.1;
  }
  calculateCulturalImpact(investment) {
    const aiEnhancement = investment.type === "technology" ? 0.2 : 0;
    return investment.culturalValue * 0.5 + investment.socialImpact * 0.3 + aiEnhancement;
  }
  async calculateDataMarketValue(districtId) {
    const dataBusinesses = Array.from(this.businesses.values()).filter((b) => b.districtId === districtId && b.type === "data_processing");
    const baseValue = dataBusinesses.reduce((sum, b) => sum + b.revenue, 0);
    const growthFactor = dataBusinesses.reduce((sum, b) => sum + b.growth, 0) / Math.max(dataBusinesses.length, 1);
    return baseValue * (1 + growthFactor);
  }
  async assessDataTrading(districtId) {
    const businesses = Array.from(this.businesses.values()).filter((b) => b.districtId === districtId);
    return businesses.reduce((sum, b) => sum + (b.dataUtilization || 0), 0) / Math.max(businesses.length, 1);
  }
  async measureDataUtilization(districtId) {
    const businesses = Array.from(this.businesses.values()).filter((b) => b.districtId === districtId);
    const totalUtilization = businesses.reduce((sum, b) => sum + (b.dataUtilization || 0), 0);
    const efficiency = businesses.reduce((sum, b) => sum + b.stability, 0) / Math.max(businesses.length, 1);
    return totalUtilization * efficiency;
  }
  calculateInnovationIndex(aiBusinesses) {
    if (!aiBusinesses.length)
      return 0;
    return aiBusinesses.reduce((sum, business) => sum + (business.growth * 0.3 + (business.aiIntegration || 0) * 0.4 + business.stability * 0.3), 0) / aiBusinesses.length;
  }
  assessDigitalTransformation() {
    const allBusinesses = Array.from(this.businesses.values());
    const aiBusinesses = allBusinesses.filter((b) => b.type === "ai_services" || b.type === "data_processing");
    const aiRevenue = aiBusinesses.reduce((sum, b) => sum + b.revenue, 0);
    const totalRevenue = allBusinesses.reduce((sum, b) => sum + b.revenue, 0);
    return aiRevenue / Math.max(totalRevenue, 1);
  }
  async getMarketMetrics(districtId) {
    return this.marketMetrics.get(districtId);
  }
  async getAIEconomicMetrics(districtId) {
    const metrics = this.marketMetrics.get(districtId);
    return {
      aiEconomicActivity: metrics?.aiEconomicActivity || 0,
      computationalResources: metrics?.computationalResources || 0,
      dataMarketMetrics: metrics?.dataMarketMetrics || 0
    };
  }
  async getDataMarketMetrics(districtId) {
    const dataMarketValue = await this.calculateDataMarketValue(districtId);
    const dataTrading = await this.assessDataTrading(districtId);
    const dataUtilization = await this.measureDataUtilization(districtId);
    return { dataMarketValue, dataTrading, dataUtilization };
  }
  async getInnovationMetrics() {
    return {
      innovationIndex: this.economicIndicators.innovationIndex,
      digitalTransformation: this.economicIndicators.digitalTransformation
    };
  }
  async getDigitalTransformationMetrics() {
    const allBusinesses = Array.from(this.businesses.values());
    const aiBusinesses = allBusinesses.filter((b) => b.type === "ai_services" || b.type === "data_processing");
    return {
      transformationRate: this.economicIndicators.digitalTransformation,
      aiBusinessCount: aiBusinesses.length,
      totalBusinessCount: allBusinesses.length,
      aiRevenue: aiBusinesses.reduce((sum, b) => sum + b.revenue, 0),
      totalRevenue: allBusinesses.reduce((sum, b) => sum + b.revenue, 0)
    };
  }
  async getEconomicIndicators() {
    return this.economicIndicators;
  }
  async addBusiness(business) {
    this.businesses.set(business.id, business);
    this.emit("businessAdded", business);
  }
  async updatePropertyMarket(market) {
    this.propertyMarkets.set(market.districtId, market);
    this.emit("propertyMarketUpdated", market);
  }
  async updateJobMarket(market) {
    this.jobMarkets.set(market.districtId, market);
    this.emit("jobMarketUpdated", market);
  }
  async addInvestment(investment) {
    this.investments.set(investment.id, investment);
    this.emit("investmentAdded", investment);
  }
}

// src/services/landmark.service.ts
var LANDMARK_SYSTEM_AGENT = {
  id: "landmark-system",
  name: "Landmark System",
  personality: "analytical",
  systemPrompt: "Track landmark interactions",
  interests: ["landmarks", "cultural", "analytics"],
  preferredStyle: "analytical",
  traits: {
    analyticalThinking: 1,
    creativity: 0.5,
    empathy: 0.5,
    curiosity: 0.7,
    enthusiasm: 0.6,
    formality: 0.8
  },
  memoryWindowSize: 10,
  emotionalRange: { min: 0.3, max: 0.8 }
};

class LandmarkService {
  vectorStore;
  analyticsService;
  landmarks = new Map;
  visits = new Map;
  ratings = new Map;
  eventBus;
  constructor(vectorStore, analyticsService) {
    this.vectorStore = vectorStore;
    this.analyticsService = analyticsService;
    this.eventBus = EventBus.getInstance();
    this.initializeMonitoring();
  }
  initializeMonitoring() {
    setInterval(() => this.updateCulturalMetrics(), 1000 * 60 * 60);
    setInterval(() => this.analyzeVisitationPatterns(), 1000 * 60 * 30);
  }
  async getAllLandmarks() {
    return Array.from(this.landmarks.values());
  }
  async addLandmark(landmark) {
    landmark.createdAt = Date.now();
    landmark.updatedAt = Date.now();
    this.landmarks.set(landmark.id, landmark);
    await this.vectorStore.upsert({
      id: `landmark-${landmark.id}`,
      values: await this.vectorStore.createEmbedding(`${landmark.name} ${landmark.type} landmark in district ${landmark.districtId}: ${landmark.description}`),
      metadata: {
        type: "district",
        landmarkId: landmark.id,
        landmarkType: landmark.type,
        districtId: landmark.districtId,
        culturalValue: landmark.culturalSignificance.culturalValue
      }
    });
    this.eventBus.emitCulturalEvent({
      type: "landmark_added",
      landmarkId: landmark.id,
      landmarkType: landmark.type,
      districtId: landmark.districtId,
      culturalSignificance: landmark.culturalSignificance
    });
  }
  async getLandmarkById(id) {
    const landmark = this.landmarks.get(id);
    if (landmark) {
      await this.trackLandmarkAccess(id);
    }
    return landmark;
  }
  async searchLandmarks(query) {
    const embedding = await this.vectorStore.createEmbedding(query);
    const semanticResults = await this.vectorStore.query({
      vector: embedding,
      filter: { type: { $eq: "district" } },
      topK: 10,
      includeMetadata: true
    });
    const semanticLandmarkIds = semanticResults.matches?.filter((result) => result.metadata.type === "district").map((result) => result.metadata.landmarkId) || [];
    const lowerQuery = query.toLowerCase();
    const textResults = Array.from(this.landmarks.values()).filter((landmark) => landmark.name.toLowerCase().includes(lowerQuery) || landmark.description?.toLowerCase().includes(lowerQuery) || landmark.tags.some((tag) => tag.toLowerCase().includes(lowerQuery)));
    const combinedResults = [
      ...new Set([...semanticLandmarkIds, ...textResults.map((l) => l.id)])
    ];
    return combinedResults.map((id) => this.landmarks.get(id)).filter(Boolean);
  }
  async updateLandmark(id, updates) {
    const landmark = this.landmarks.get(id);
    if (!landmark)
      return;
    const updatedLandmark = {
      ...landmark,
      ...updates,
      updatedAt: Date.now()
    };
    this.landmarks.set(id, updatedLandmark);
    await this.vectorStore.upsert({
      id: `landmark-${id}`,
      values: await this.vectorStore.createEmbedding(`${updatedLandmark.name} ${updatedLandmark.type} landmark in district ${updatedLandmark.districtId}: ${updatedLandmark.description}`),
      metadata: {
        type: "district",
        landmarkId: id,
        landmarkType: updatedLandmark.type,
        districtId: updatedLandmark.districtId,
        culturalValue: updatedLandmark.culturalSignificance.culturalValue
      }
    });
    this.eventBus.emitCulturalEvent({
      type: "landmark_updated",
      landmarkId: id,
      changes: updates
    });
  }
  async recordVisit(landmarkId, visitorCount = 1) {
    const visit = {
      landmarkId,
      timestamp: Date.now(),
      visitorCount,
      culturalImpact: await this.calculateVisitImpact(landmarkId, visitorCount)
    };
    const landmarkVisits = this.visits.get(landmarkId) || [];
    landmarkVisits.push(visit);
    this.visits.set(landmarkId, landmarkVisits);
    await this.analyticsService.trackInteraction(LANDMARK_SYSTEM_AGENT, {
      id: crypto.randomUUID(),
      agentId: "landmark-system",
      content: `Landmark visit: ${visitorCount} visitors`,
      timestamp: Date.now(),
      role: "assistant",
      sentiment: 0.8,
      topics: ["landmark", "visit", "cultural"]
    });
  }
  async addRating(rating) {
    const landmarkRatings = this.ratings.get(rating.landmarkId) || [];
    landmarkRatings.push(rating);
    this.ratings.set(rating.landmarkId, landmarkRatings);
    await this.updateLandmarkMetrics(rating.landmarkId);
  }
  async getLandmarksByDistrict(districtId) {
    return Array.from(this.landmarks.values()).filter((landmark) => landmark.districtId === districtId);
  }
  async getLandmarksByType(type3) {
    return Array.from(this.landmarks.values()).filter((landmark) => landmark.type === type3);
  }
  async getVisitationStats(landmarkId) {
    const visits = this.visits.get(landmarkId) || [];
    const now = Date.now();
    const oneDayAgo = now - 24 * 60 * 60 * 1000;
    const recentVisits = visits.filter((v) => v.timestamp > oneDayAgo);
    const totalVisits = recentVisits.reduce((sum, v) => sum + v.visitorCount, 0);
    const hourlyVisits = new Array(24).fill(0);
    recentVisits.forEach((visit) => {
      const hour2 = new Date(visit.timestamp).getHours();
      hourlyVisits[hour2] += visit.visitorCount;
    });
    return {
      totalVisits,
      averageVisitorsPerDay: totalVisits / 1,
      peakHours: hourlyVisits.map((count, hour2) => ({ count, hour: hour2 })).sort((a, b) => b.count - a.count).slice(0, 3).map((peak) => peak.hour),
      culturalImpact: recentVisits.reduce((sum, v) => sum + v.culturalImpact, 0) / recentVisits.length
    };
  }
  async calculateVisitImpact(landmarkId, visitorCount) {
    const landmark = this.landmarks.get(landmarkId);
    if (!landmark)
      return 0;
    return (landmark.culturalSignificance.culturalValue * 0.4 + landmark.culturalSignificance.socialImpact * 0.3 + landmark.culturalSignificance.aiInteractionLevel * 0.3) * (visitorCount / landmark.capacity);
  }
  async updateLandmarkMetrics(landmarkId) {
    const landmark = this.landmarks.get(landmarkId);
    const ratings = this.ratings.get(landmarkId) || [];
    if (!landmark)
      return;
    const averageRating = ratings.reduce((sum, r) => sum + r.rating, 0) / Math.max(ratings.length, 1);
    await this.updateLandmark(landmarkId, {
      culturalSignificance: {
        ...landmark.culturalSignificance,
        socialImpact: averageRating * 0.8 + landmark.culturalSignificance.socialImpact * 0.2,
        lastAssessment: Date.now()
      }
    });
  }
  async updateCulturalMetrics() {
    for (const landmark of this.landmarks.values()) {
      const visits = this.visits.get(landmark.id) || [];
      const recentVisits = visits.filter((v) => v.timestamp > Date.now() - 24 * 60 * 60 * 1000);
      const culturalImpact = recentVisits.reduce((sum, v) => sum + v.culturalImpact, 0) / Math.max(recentVisits.length, 1);
      await this.updateLandmark(landmark.id, {
        culturalSignificance: {
          ...landmark.culturalSignificance,
          culturalValue: culturalImpact * 0.7 + landmark.culturalSignificance.culturalValue * 0.3,
          lastAssessment: Date.now()
        }
      });
    }
  }
  async analyzeVisitationPatterns() {
    for (const landmark of this.landmarks.values()) {
      const stats = await this.getVisitationStats(landmark.id);
      if (stats.peakHours.length > 0) {
        const suggestedOpen = Math.min(...stats.peakHours) - 1;
        const suggestedClose = Math.max(...stats.peakHours) + 1;
        if (Math.abs(suggestedOpen - landmark.operatingHours.open) > 2 || Math.abs(suggestedClose - landmark.operatingHours.close) > 2) {
          await this.updateLandmark(landmark.id, {
            operatingHours: {
              open: suggestedOpen,
              close: suggestedClose
            }
          });
        }
      }
    }
  }
  async trackLandmarkAccess(landmarkId) {
    await this.analyticsService.trackInteraction(LANDMARK_SYSTEM_AGENT, {
      id: crypto.randomUUID(),
      agentId: "landmark-system",
      content: "Landmark information accessed",
      timestamp: Date.now(),
      role: "assistant",
      sentiment: 0.6,
      topics: ["landmark", "information"]
    });
  }
}

// src/services/adaptive-learning.service.ts
var import_lodash5 = __toESM(require_lodash2(), 1);
import { EventEmitter as EventEmitter26 } from "events";

class AdaptiveLearningService extends EventEmitter26 {
  vectorStore;
  metricsService;
  cityService;
  config = {
    analysisWindow: 7 * 24 * 60 * 60 * 1000,
    impactThreshold: 0.7,
    adaptationRate: 0.3,
    confidenceThreshold: 0.8
  };
  learningHistory = new Map;
  constructor(vectorStore, metricsService, cityService) {
    super();
    this.vectorStore = vectorStore;
    this.metricsService = metricsService;
    this.cityService = cityService;
    this.initializeService();
  }
  async initializeService() {
    setInterval(() => this.evolveCity(), 24 * 60 * 60 * 1000);
    this.setupEventListeners();
  }
  setupEventListeners() {
    this.cityService.on("metricsUpdated", this.handleMetricsUpdate.bind(this));
    this.metricsService.on("alert", this.handleMetricsAlert.bind(this));
  }
  async evolveCity() {
    try {
      const learningData = await this.collectCityData();
      const adaptations = await this.generateAdaptations(learningData);
      await this.implementAdaptations(adaptations);
      this.emit("cityEvolved", {
        timestamp: Date.now(),
        adaptations,
        metrics: await this.metricsService.getMetricsAnalysis()
      });
    } catch (error4) {
      console.error("Error in city evolution cycle:", error4);
      this.emit("evolutionError", error4);
    }
  }
  async collectCityData() {
    const [
      successPatterns,
      failurePoints,
      emergingNeeds,
      adaptationOpportunities
    ] = await Promise.all([
      this.analyzeSuccessfulInteractions(),
      this.identifySystemWeaknesses(),
      this.predictFutureNeeds(),
      this.findAdaptationOpportunities()
    ]);
    return {
      successPatterns,
      failurePoints,
      emergingNeeds,
      adaptationOpportunities
    };
  }
  async analyzeSuccessfulInteractions() {
    const recentInteractions = await this.vectorStore.query({
      vector: await this.vectorStore.createEmbedding("successful city interactions"),
      filter: {
        timestamp: { $gt: Date.now() - this.config.analysisWindow }
      },
      topK: 100
    });
    const patterns3 = recentInteractions.matches.reduce((acc, interaction) => {
      const pattern2 = this.extractInteractionPattern(interaction);
      if (pattern2) {
        const existing = acc.find((p) => p.pattern === pattern2.pattern);
        if (existing) {
          existing.impact = (existing.impact + pattern2.impact) / 2;
          existing.replicability += 0.1;
        } else {
          acc.push(pattern2);
        }
      }
      return acc;
    }, []);
    return patterns3.filter((p) => p.impact >= this.config.impactThreshold);
  }
  async identifySystemWeaknesses() {
    const metricsAnalysis = await this.metricsService.getMetricsAnalysis();
    const weaknesses = [];
    for (const [category, categoryMetrics] of Object.entries(metricsAnalysis.current)) {
      for (const [metric, value2] of Object.entries(categoryMetrics)) {
        if (typeof value2 === "number" && value2 < 0.6) {
          weaknesses.push({
            issue: `${category}.${metric}`,
            frequency: this.calculateIssueFrequency(`${category}.${metric}`),
            severity: 1 - value2
          });
        }
      }
    }
    return import_lodash5.default.orderBy(weaknesses, ["severity", "frequency"], ["desc", "desc"]);
  }
  async predictFutureNeeds() {
    const cityContext = this.cityService.getContext();
    const trendAnalysis = await this.analyzeTrends(cityContext);
    const projectedNeeds = new Set;
    if (trendAnalysis.populationGrowth > 0.05) {
      projectedNeeds.add("infrastructure_expansion");
      projectedNeeds.add("housing_development");
    }
    if (trendAnalysis.resourceUtilization > 0.8) {
      projectedNeeds.add("resource_optimization");
      projectedNeeds.add("sustainable_alternatives");
    }
    if (trendAnalysis.socialCohesion < 0.6) {
      projectedNeeds.add("community_programs");
      projectedNeeds.add("cultural_initiatives");
    }
    return Array.from(projectedNeeds);
  }
  async findAdaptationOpportunities() {
    const currentMetrics = await this.metricsService.getMetricsAnalysis();
    const opportunities = [];
    for (const [category, metrics] of Object.entries(currentMetrics.current)) {
      for (const [metric, value2] of Object.entries(metrics)) {
        if (typeof value2 === "number") {
          const improvement = 1 - value2;
          if (improvement > 0.3) {
            opportunities.push({
              area: `${category}.${metric}`,
              potential: improvement,
              cost: this.estimateImprovementCost(category, metric, improvement)
            });
          }
        }
      }
    }
    return import_lodash5.default.orderBy(opportunities, ["potential"], ["desc"]);
  }
  async generateAdaptations(data) {
    return {
      infrastructureChanges: await this.suggestInfrastructureUpdates(data),
      serviceImprovements: await this.recommendServiceEnhancements(data),
      newFeatures: await this.proposeNewFeatures(data)
    };
  }
  async suggestInfrastructureUpdates(data) {
    const updates = [];
    for (const failure of data.failurePoints) {
      if (failure.issue.includes("infrastructure")) {
        updates.push({
          type: "upgrade",
          target: failure.issue,
          priority: failure.severity * failure.frequency,
          estimatedImpact: 0.8,
          cost: this.estimateUpgradeCost(failure.issue)
        });
      }
    }
    for (const need of data.emergingNeeds) {
      if (need.includes("infrastructure")) {
        updates.push({
          type: "new",
          target: need,
          priority: 0.7,
          estimatedImpact: 0.9,
          cost: this.estimateNewInfrastructureCost(need)
        });
      }
    }
    return import_lodash5.default.orderBy(updates, ["priority"], ["desc"]);
  }
  async recommendServiceEnhancements(data) {
    const improvements = [];
    for (const pattern2 of data.successPatterns) {
      if (pattern2.impact > this.config.impactThreshold) {
        improvements.push({
          service: this.extractServiceFromPattern(pattern2.pattern),
          changes: [pattern2.pattern],
          expectedBenefit: pattern2.impact * pattern2.replicability,
          implementation: `Replicate success pattern: ${pattern2.pattern}`
        });
      }
    }
    for (const failure of data.failurePoints) {
      if (this.isServiceRelated(failure.issue)) {
        improvements.push({
          service: this.extractServiceFromIssue(failure.issue),
          changes: [`Fix: ${failure.issue}`],
          expectedBenefit: failure.severity,
          implementation: `Address service failure: ${failure.issue}`
        });
      }
    }
    return import_lodash5.default.orderBy(improvements, ["expectedBenefit"], ["desc"]);
  }
  async proposeNewFeatures(data) {
    const features = [];
    for (const need of data.emergingNeeds) {
      features.push({
        name: this.generateFeatureName(need),
        description: this.generateFeatureDescription(need),
        requirements: this.identifyFeatureRequirements(need),
        impact: this.estimateFeatureImpact(need)
      });
    }
    for (const opportunity of data.adaptationOpportunities) {
      if (opportunity.potential > 0.7) {
        features.push({
          name: this.generateFeatureName(opportunity.area),
          description: `New feature to address ${opportunity.area}`,
          requirements: this.identifyFeatureRequirements(opportunity.area),
          impact: opportunity.potential
        });
      }
    }
    return import_lodash5.default.orderBy(features, ["impact"], ["desc"]);
  }
  async implementAdaptations(adaptations) {
    try {
      for (const change of adaptations.infrastructureChanges) {
        await this.vectorStore.upsert({
          id: `adaptation-${Date.now()}`,
          values: await this.vectorStore.createEmbedding(`Infrastructure adaptation: ${change.type} - ${change.target}`),
          metadata: {
            type: "district",
            subtype: "adaptation",
            impact: change.estimatedImpact,
            cost: change.cost,
            timestamp: Date.now()
          }
        });
      }
      for (const improvement of adaptations.serviceImprovements) {
        this.emit("serviceImprovement", {
          service: improvement.service,
          changes: improvement.changes,
          timestamp: Date.now()
        });
      }
      for (const feature of adaptations.newFeatures) {
        this.emit("newFeature", {
          name: feature.name,
          description: feature.description,
          impact: feature.impact,
          timestamp: Date.now()
        });
      }
      this.emit("adaptationsImplemented", {
        timestamp: Date.now(),
        summary: {
          infrastructureChanges: adaptations.infrastructureChanges.length,
          serviceImprovements: adaptations.serviceImprovements.length,
          newFeatures: adaptations.newFeatures.length
        }
      });
    } catch (error4) {
      console.error("Error implementing adaptations:", error4);
      this.emit("adaptationError", error4);
    }
  }
  calculateIssueFrequency(issue) {
    const history = this.learningHistory.get(issue) || [];
    const recentIssues = history.filter((h) => h.timestamp > Date.now() - this.config.analysisWindow);
    return recentIssues.length / (this.config.analysisWindow / (24 * 60 * 60 * 1000));
  }
  async analyzeTrends(cityContext) {
    return {
      populationGrowth: 0.06,
      resourceUtilization: 0.85,
      socialCohesion: 0.7
    };
  }
  estimateImprovementCost(category, metric, improvement) {
    return improvement * 1e5;
  }
  extractInteractionPattern(interaction) {
    return {
      pattern: interaction.metadata?.pattern || "unknown",
      impact: interaction.metadata?.impact || 0,
      replicability: interaction.metadata?.replicability || 0
    };
  }
  estimateUpgradeCost(issue) {
    return 50000;
  }
  estimateNewInfrastructureCost(need) {
    return 1e5;
  }
  extractServiceFromPattern(pattern2) {
    return pattern2.split(".")[0];
  }
  extractServiceFromIssue(issue) {
    return issue.split(".")[0];
  }
  isServiceRelated(issue) {
    return issue.includes("service") || issue.includes("system");
  }
  generateFeatureName(input) {
    return `Enhanced ${input} System`;
  }
  generateFeatureDescription(input) {
    return `Feature to enhance ${input} capabilities`;
  }
  identifyFeatureRequirements(input) {
    return [
      `Core ${input} functionality`,
      "Integration capabilities",
      "Performance metrics"
    ];
  }
  estimateFeatureImpact(input) {
    return 0.8;
  }
  handleMetricsUpdate(metrics) {
    console.log("Metrics updated:", metrics);
  }
  handleMetricsAlert(alert) {
    console.log("Metrics alert:", alert);
  }
  async getCityLearningData() {
    return this.collectCityData();
  }
  async getAdaptationPlans() {
    const learningData = await this.collectCityData();
    const currentPlan = await this.generateAdaptations(learningData);
    return [currentPlan];
  }
  async createAdaptationPlan(plan) {
    await this.implementAdaptations(plan);
    return plan;
  }
  async getDomainInsights(domain) {
    const metrics = await this.metricsService.getMetricsAnalysis();
    const domainMetrics = metrics.current[domain] || {};
    const trends = await this.analyzeTrends({ domain, metrics: domainMetrics });
    return {
      metrics: domainMetrics,
      trends,
      recommendations: await this.generateDomainRecommendations(domain, trends)
    };
  }
  async handleEvent(event) {
    const eventData = {
      timestamp: Date.now(),
      ...event
    };
    const domain = this.identifyEventDomain(event);
    if (!this.learningHistory.has(domain)) {
      this.learningHistory.set(domain, []);
    }
    this.learningHistory.get(domain)?.push(eventData);
    if (this.shouldTriggerLearning(domain)) {
      await this.evolveCity();
    }
  }
  async getLearningMetrics() {
    const metrics = {
      totalEvents: Array.from(this.learningHistory.values()).flat().length,
      domainCoverage: this.learningHistory.size,
      lastEvolution: this.lastEvolutionTimestamp,
      adaptationRate: this.config.adaptationRate,
      confidenceLevel: this.config.confidenceThreshold,
      domains: {}
    };
    for (const [domain, events] of this.learningHistory.entries()) {
      metrics.domains[domain] = {
        eventCount: events.length,
        lastEvent: events[events.length - 1]?.timestamp,
        patterns: await this.analyzeSuccessfulInteractions()
      };
    }
    return metrics;
  }
  async getRecommendations() {
    const learningData = await this.collectCityData();
    return {
      immediate: learningData.adaptationOpportunities.filter((opp) => opp.potential > 0.7).map((opp) => ({
        type: "high-priority",
        ...opp
      })),
      planned: learningData.adaptationOpportunities.filter((opp) => opp.potential <= 0.7).map((opp) => ({
        type: "planned",
        ...opp
      })),
      emergingNeeds: learningData.emergingNeeds
    };
  }
  lastEvolutionTimestamp = Date.now();
  identifyEventDomain(event) {
    if (event.domain)
      return event.domain;
    if (event.type?.includes("."))
      return event.type.split(".")[0];
    return "general";
  }
  shouldTriggerLearning(domain) {
    const events = this.learningHistory.get(domain) || [];
    const recentEvents = events.filter((e) => e.timestamp > Date.now() - this.config.analysisWindow);
    return recentEvents.length >= 10;
  }
  async generateDomainRecommendations(domain, trends) {
    const recommendations = [];
    if (trends.growth > 0.1) {
      recommendations.push({
        type: "scaling",
        priority: "high",
        description: `Scale ${domain} infrastructure to handle growth`
      });
    }
    if (trends.efficiency < 0.7) {
      recommendations.push({
        type: "optimization",
        priority: "medium",
        description: `Optimize ${domain} processes for better efficiency`
      });
    }
    return recommendations;
  }
}

// src/services/city-coordinator.service.ts
import { EventEmitter as EventEmitter27 } from "events";

class CityCoordinatorService extends EventEmitter27 {
  vectorStore;
  departmentService;
  environmentService;
  transportService;
  socialDynamicsService;
  analyticsService;
  cityMemoryService;
  economyService;
  coordinatorAgent = {
    id: "city-coordinator",
    name: "City Coordinator",
    personality: "Analytical and efficient",
    systemPrompt: "Coordinate city operations and optimize resource allocation",
    interests: ["city planning", "resource optimization", "coordination"],
    preferredStyle: "formal",
    memoryWindowSize: 100,
    emotionalRange: {
      min: 0.3,
      max: 0.8
    },
    traits: {
      analyticalThinking: 0.9,
      creativity: 0.6,
      empathy: 0.7,
      curiosity: 0.8,
      enthusiasm: 0.7,
      efficiency: 0.9,
      reliability: 0.9,
      longTermThinking: 0.9,
      environmentalAwareness: 0.8
    },
    metadata: {
      role: "coordinator",
      specialization: ["city planning", "resource management"]
    },
    isActive: true
  };
  currentMetrics;
  activeProposals = new Map;
  implementationQueue = [];
  constructor(vectorStore, departmentService, environmentService, transportService, socialDynamicsService, analyticsService, cityMemoryService, economyService) {
    super();
    this.vectorStore = vectorStore;
    this.departmentService = departmentService;
    this.environmentService = environmentService;
    this.transportService = transportService;
    this.socialDynamicsService = socialDynamicsService;
    this.analyticsService = analyticsService;
    this.cityMemoryService = cityMemoryService;
    this.economyService = economyService;
    this.currentMetrics = {
      sustainability: {
        carbonEmissions: 0,
        renewableEnergyRatio: 0,
        greenSpaceIndex: 0,
        airQualityScore: 0,
        waterQualityScore: 0
      },
      economy: {
        employmentRate: 0,
        jobGrowth: 0,
        giniCoefficient: 0,
        businessFormationRate: 0,
        affordabilityIndex: 0
      },
      social: {
        healthcareAccess: 0,
        educationQuality: 0,
        culturalEngagement: 0,
        civicParticipation: 0,
        communityWellbeing: 0
      },
      infrastructure: {
        trafficCongestion: 0,
        publicTransitReliability: 0,
        wasteRecyclingRate: 0,
        infrastructureHealth: 0,
        housingAvailability: 0
      }
    };
    this.initializeCoordinator();
  }
  async initializeCoordinator() {
    this.currentMetrics = await this.gatherCityMetrics();
    await this.initializeCulturalData();
    this.trackAnalytics("metrics_initialization", {
      content: "Initial city metrics gathered",
      topics: ["metrics", "initialization"],
      sentiment: this.calculateOverallMetricsSentiment(this.currentMetrics)
    });
    setInterval(() => this.updateCityMetrics(), 1000 * 60 * 30);
    setInterval(() => this.evaluateProposals(), 1000 * 60 * 60);
    setInterval(() => this.processImplementationQueue(), 1000 * 60 * 15);
    this.environmentService.on("environmentalAlert", this.handleEnvironmentalEvent.bind(this));
    this.transportService.on("metricsUpdated", this.handleTransportEvent.bind(this));
    this.socialDynamicsService.on("communityMoodUpdated", this.handleSocialEvent.bind(this));
  }
  async initializeCulturalData() {
    try {
      const culturalHotspots = [
        {
          name: "City Central Museum",
          location_lat: 40.7128,
          location_lng: -74.006,
          visitorCount: 5000,
          culturalSignificance: 0.9,
          eventFrequency: "high",
          nearbyAttractions: ["Art Gallery", "Historical Library"]
        },
        {
          name: "Heritage Theater",
          location_lat: 40.7589,
          location_lng: -73.9851,
          visitorCount: 3000,
          culturalSignificance: 0.85,
          eventFrequency: "medium",
          nearbyAttractions: ["Concert Hall", "Cultural Center"]
        },
        {
          name: "Arts District",
          location_lat: 40.7549,
          location_lng: -73.984,
          visitorCount: 8000,
          culturalSignificance: 0.95,
          eventFrequency: "high",
          nearbyAttractions: ["Street Art Gallery", "Craft Market"]
        }
      ];
      for (const hotspot of culturalHotspots) {
        const embedding = await this.vectorStore.createEmbedding(`${hotspot.name} cultural hotspot with ${hotspot.eventFrequency} event frequency`);
        await this.vectorStore.upsert({
          id: crypto.randomUUID(),
          values: embedding,
          metadata: {
            type: "transport",
            subtype: "cultural_hotspot",
            ...hotspot
          }
        });
        console.log(`Initialized cultural hotspot: ${hotspot.name}`);
      }
      this.analyticsService.trackEvent("cultural_data_initialization", {
        timestamp: Date.now(),
        count: culturalHotspots.length,
        status: "success"
      });
    } catch (error4) {
      console.error("Failed to initialize cultural data:", error4);
      this.analyticsService.trackEvent("cultural_data_initialization", {
        timestamp: Date.now(),
        error: error4 instanceof Error ? error4.message : String(error4),
        status: "failed"
      });
    }
  }
  async evaluateProposalWithHistoricalContext(proposal) {
    const memories = await this.cityMemoryService.searchMemories(`${proposal.title} ${proposal.description}`, {
      minSignificance: 0.7,
      type: proposal.category === "environmental" ? "environmental" : proposal.category === "social" ? "social" : "cultural"
    });
    const historicalInsights = [];
    let score = proposal.estimatedImpact.overall;
    for (const memory of memories) {
      if (memory.type === proposal.category) {
        score *= memory.emotionalImpact > 0.7 ? 1.1 : 0.9;
        historicalInsights.push(`Historical precedent: ${memory.description} (Impact: ${memory.emotionalImpact})`);
      }
    }
    this.analyticsService.trackInteraction(this.coordinatorAgent, {
      id: crypto.randomUUID(),
      agentId: this.coordinatorAgent.id,
      content: `Evaluated proposal ${proposal.id} with historical context`,
      timestamp: Date.now(),
      role: "assistant",
      sentiment: score > proposal.estimatedImpact.overall ? 0.8 : 0.4,
      topics: ["proposal", "evaluation", "historical-analysis"]
    });
    return { score, historicalInsights };
  }
  async storeProposalOutcome(proposal, success) {
    await this.cityMemoryService.storeCollectiveMemory({
      type: proposal.category === "environmental" ? "environmental" : proposal.category === "social" ? "social" : "cultural",
      description: `Proposal: ${proposal.title} - ${success ? "Succeeded" : "Failed"}`,
      districtId: proposal.targetDistrict,
      timestamp: Date.now(),
      emotionalImpact: success ? 0.8 : 0.3,
      participants: proposal.stakeholders,
      culturalSignificance: proposal.estimatedImpact.cultural || 0.5,
      tags: ["proposal", proposal.category, success ? "success" : "failure"],
      location: proposal.location
    });
  }
  async submitProposal(proposal) {
    const { score, historicalInsights } = await this.evaluateProposalWithHistoricalContext(proposal);
    const accepted = score >= 0.7;
    if (accepted) {
      this.activeProposals.set(proposal.id, proposal);
      this.implementationQueue.push(proposal);
    }
    await this.storeProposalOutcome(proposal, accepted);
    return {
      accepted,
      score,
      insights: historicalInsights
    };
  }
  async validateProposal(proposal) {
    for (const depId of proposal.requirements.dependencies) {
      const dep = this.activeProposals.get(depId);
      if (!dep || dep.status === "rejected") {
        throw new Error(`Invalid dependency: ${depId}`);
      }
    }
    const departments = await this.departmentService.getAllDepartments();
    const validDepartments = new Set(departments.map((d) => d.id));
    for (const deptId of proposal.requirements.approvals) {
      if (!validDepartments.has(deptId)) {
        throw new Error(`Invalid department: ${deptId}`);
      }
    }
  }
  async simulateProposal(proposal) {
    proposal.status = "simulating";
    this.trackAnalytics("proposal_simulation", {
      content: `Simulating proposal: ${proposal.title}`,
      topics: [proposal.domain, "simulation"],
      sentiment: 0.5
    });
    await this.vectorStore.upsert({
      id: `proposal-sim-${proposal.id}`,
      values: await this.vectorStore.createEmbedding(`${proposal.domain} proposal: ${proposal.title}`),
      metadata: {
        type: "district",
        proposalId: proposal.id,
        domain: proposal.domain,
        impactData: JSON.stringify(proposal.impact),
        timestamp: Date.now()
      }
    });
    if (proposal.simulation.confidence > 0.7) {
      proposal.status = "approved";
      this.implementationQueue.push(proposal);
    } else {
      proposal.status = "rejected";
    }
    this.trackAnalytics("simulation_result", {
      content: `Simulation completed with confidence: ${proposal.simulation.confidence}`,
      topics: [proposal.domain, "simulation", proposal.status],
      sentiment: proposal.status === "approved" ? 0.8 : 0.3
    });
    this.emit("proposalSimulated", { proposal });
  }
  async evaluateProposals() {
    const proposals = Array.from(this.activeProposals.values()).filter((p) => p.status === "approved");
    proposals.sort((a, b) => {
      const scoreA = this.calculateProposalScore(a);
      const scoreB = this.calculateProposalScore(b);
      return scoreB - scoreA;
    });
    this.implementationQueue = proposals;
  }
  calculateProposalScore(proposal) {
    const impactScore = Object.values(proposal.impact.metrics).reduce((sum, metric) => sum + this.normalizeMetric(metric), 0);
    return impactScore * 0.4 + proposal.impact.priority * 0.3 + proposal.simulation.confidence * 0.3;
  }
  normalizeMetric(metric) {
    if (typeof metric === "number") {
      return metric;
    }
    if (typeof metric === "object" && metric !== null) {
      return Object.values(metric).reduce((sum, val) => sum + this.normalizeMetric(val), 0);
    }
    return 0;
  }
  async processImplementationQueue() {
    const proposal = this.implementationQueue[0];
    if (!proposal)
      return;
    try {
      await this.implementProposal(proposal);
      this.implementationQueue.shift();
    } catch (error4) {
      console.error(`Failed to implement proposal ${proposal.id}:`, error4);
      proposal.status = "rejected";
    }
  }
  async implementProposal(proposal) {
    this.trackAnalytics("proposal_implementation", {
      content: `Starting implementation of proposal: ${proposal.title}`,
      topics: [proposal.domain, "implementation"],
      sentiment: 0.7
    });
    for (const deptId of proposal.requirements.approvals) {
      await this.departmentService.addActivity(deptId, {
        type: "proposal_implementation",
        proposalId: proposal.id,
        timestamp: Date.now()
      });
    }
    proposal.status = "implementing";
    this.activeProposals.set(proposal.id, proposal);
    const event = {
      type: "implementation",
      timestamp: Date.now(),
      agentId: proposal.domain,
      proposalId: proposal.id,
      details: {
        metrics: proposal.impact.metrics,
        requirements: proposal.requirements
      }
    };
    this.analyticsService.trackMood(this.calculateProposalImpactSentiment(proposal));
    await this.recordEvent(event);
  }
  async recordEvent(event) {
    await this.vectorStore.upsert({
      id: `coordination-event-${Date.now()}`,
      values: await this.vectorStore.createEmbedding(`${event.type} event for ${event.agentId}`),
      metadata: {
        type: "district",
        eventType: event.type,
        agentId: event.agentId,
        proposalId: event.proposalId,
        timestamp: event.timestamp
      }
    });
    this.emit("coordinationEvent", event);
  }
  async gatherCityMetrics() {
    return {
      sustainability: await this.getSustainabilityMetrics(),
      economy: await this.getEconomyMetrics(),
      social: await this.getSocialMetrics(),
      infrastructure: await this.getInfrastructureMetrics()
    };
  }
  async handleEnvironmentalEvent(alert) {
    this.currentMetrics.sustainability = {
      ...this.currentMetrics.sustainability,
      airQualityScore: alert.type === "air" ? this.calculateAirQualityScore(alert.metrics.airQuality) : this.currentMetrics.sustainability.airQualityScore,
      waterQualityScore: alert.type === "water" ? this.calculateWaterQualityScore(alert.metrics.water) : this.currentMetrics.sustainability.waterQualityScore
    };
  }
  async handleTransportEvent(routes) {
    if (!Array.isArray(routes) || routes.length === 0) {
      console.warn("Received invalid or empty routes in handleTransportEvent");
      return;
    }
    const congestionLevels = routes.map((r) => r?.metrics?.efficiency ?? 0);
    const avgCongestion = congestionLevels.length > 0 ? congestionLevels.reduce((a, b) => a + b, 0) / congestionLevels.length : 0;
    this.currentMetrics.infrastructure = {
      ...this.currentMetrics.infrastructure,
      trafficCongestion: 1 - avgCongestion,
      publicTransitReliability: this.calculateTransitReliability(routes)
    };
  }
  async handleSocialEvent(communityMood) {
    const avgMood = Object.values(communityMood).reduce((a, b) => a + b, 0) / Object.values(communityMood).length;
    this.currentMetrics.social = {
      ...this.currentMetrics.social,
      communityWellbeing: avgMood
    };
  }
  async updateCityMetrics() {
    const previousMetrics = { ...this.currentMetrics };
    this.currentMetrics = await this.gatherCityMetrics();
    this.trackAnalytics("metrics_update", {
      content: "City metrics updated",
      topics: ["metrics", "update"],
      sentiment: this.calculateMetricsChangeSentiment(previousMetrics, this.currentMetrics)
    });
    this.emit("metricsUpdated", this.currentMetrics);
  }
  async getSustainabilityMetrics() {
    const environmentalData = await Promise.all(Array.from(this.environmentService.getActiveAlerts()));
    return {
      carbonEmissions: await this.calculateCarbonEmissions(),
      renewableEnergyRatio: await this.calculateEnergyRatio(),
      greenSpaceIndex: await this.calculateGreenSpaceIndex(),
      airQualityScore: this.calculateAverageAirQuality(environmentalData),
      waterQualityScore: this.calculateAverageWaterQuality(environmentalData)
    };
  }
  async getEconomyMetrics() {
    const indicators = await this.economyService.getEconomicIndicators();
    const jobMarkets = await Promise.all(Array.from(this.economyService["jobMarkets"].values()));
    const avgEmploymentRate = jobMarkets.reduce((sum, market) => sum + market.employmentRate, 0) / Math.max(jobMarkets.length, 1);
    return {
      employmentRate: avgEmploymentRate,
      jobGrowth: indicators.economicGrowth,
      giniCoefficient: 0.35,
      businessFormationRate: 12.5,
      affordabilityIndex: 0.65
    };
  }
  async getSocialMetrics() {
    return {
      healthcareAccess: 0.85,
      educationQuality: 0.78,
      culturalEngagement: 0.72,
      civicParticipation: 0.65,
      communityWellbeing: 0.81
    };
  }
  async getInfrastructureMetrics() {
    const transportRoutes = this.transportService.getAllRoutes();
    return {
      trafficCongestion: 1 - this.calculateAverageCongestion(transportRoutes),
      publicTransitReliability: this.calculateTransitReliability(transportRoutes),
      wasteRecyclingRate: 0.45,
      infrastructureHealth: 0.88,
      housingAvailability: 0.72
    };
  }
  calculateAirQualityScore(metrics) {
    return metrics ? Math.max(0, 100 - metrics.aqi) / 100 : 0.7;
  }
  calculateWaterQualityScore(metrics) {
    return metrics?.quality || 0.8;
  }
  calculateTransitReliability(routes) {
    if (!Array.isArray(routes) || routes.length === 0) {
      return 0;
    }
    return routes.reduce((acc, route) => {
      if (!route?.metrics?.reliability) {
        return acc;
      }
      return acc + route.metrics.reliability;
    }, 0) / routes.length;
  }
  calculateAverageCongestion(routes) {
    return routes.reduce((acc, route) => acc + route.metrics.utilization, 0) / routes.length;
  }
  async calculateCarbonEmissions() {
    return 8.5;
  }
  async calculateEnergyRatio() {
    return 0.35;
  }
  async calculateGreenSpaceIndex() {
    try {
      const environmentalMetrics = await this.environmentService.getEnvironmentalMetrics();
      if (!environmentalMetrics || !("greenSpace" in environmentalMetrics)) {
        console.warn("No environmental metrics available, using default value");
        return 0.5;
      }
      const greenSpaceMetrics = environmentalMetrics.greenSpace;
      if (typeof greenSpaceMetrics?.coverage === "number") {
        return Math.max(0.3, Math.min(1, greenSpaceMetrics.coverage / 100));
      }
      return 0.5;
    } catch (error4) {
      console.error("Failed to calculate green space index:", error4 instanceof Error ? error4.message : "Unknown error");
      return 0.5;
    }
  }
  calculateAverageAirQuality(data) {
    const airQualityAlerts = data.filter((alert) => alert.type === "air");
    if (airQualityAlerts.length === 0)
      return 80;
    return airQualityAlerts.reduce((acc, alert) => acc + (alert.metrics.airQuality?.aqi || 0), 0) / airQualityAlerts.length;
  }
  calculateAverageWaterQuality(data) {
    const waterAlerts = data.filter((alert) => alert.type === "water");
    if (waterAlerts.length === 0)
      return 0.9;
    return waterAlerts.reduce((acc, alert) => acc + (alert.metrics.water?.quality || 0), 0) / waterAlerts.length;
  }
  calculateOverallMetricsSentiment(metrics) {
    const values = [
      ...Object.values(metrics.sustainability),
      ...Object.values(metrics.economy),
      ...Object.values(metrics.social),
      ...Object.values(metrics.infrastructure)
    ];
    return values.reduce((acc, val) => acc + val, 0) / values.length;
  }
  calculateProposalImpactSentiment(proposal) {
    return proposal.simulation.confidence * 0.4 + proposal.impact.priority * 0.3 + this.calculateMetricImpactSentiment(proposal.impact.metrics) * 0.3;
  }
  calculateMetricImpactSentiment(metrics) {
    const values = Object.values(metrics).filter((val) => typeof val === "number");
    return values.length > 0 ? values.reduce((acc, val) => acc + val, 0) / values.length : 0.5;
  }
  calculateMetricsChangeSentiment(previous, current) {
    const prevSentiment = this.calculateOverallMetricsSentiment(previous);
    const currentSentiment = this.calculateOverallMetricsSentiment(current);
    return 0.5 + (currentSentiment - prevSentiment);
  }
  trackAnalytics(eventType, messageData) {
    const message2 = {
      id: crypto.randomUUID(),
      agentId: this.coordinatorAgent.id,
      role: "assistant",
      timestamp: Date.now(),
      content: messageData.content || "",
      sentiment: messageData.sentiment,
      topics: messageData.topics
    };
    this.analyticsService.trackInteraction(this.coordinatorAgent, message2);
  }
  async getActiveProposals() {
    return Array.from(this.activeProposals.values());
  }
  async initializeCulturalRoutes() {
    try {
      const embedding = await this.vectorStore.createEmbedding("cultural hotspots and transport routes");
      const response = await this.vectorStore.query({
        vector: embedding,
        filter: {
          type: { $eq: "transport" },
          subtype: { $eq: "cultural_hotspot" }
        },
        topK: 10
      });
      console.log("Raw query response:", JSON.stringify(response, null, 2));
      if (!response || !response.matches || !Array.isArray(response.matches)) {
        console.warn("No valid matches in query response");
        return [];
      }
      const culturalHotspots = response.matches.filter((match) => match && match.metadata).map((match) => ({
        id: match.id,
        name: match.metadata.name || "Unknown Location",
        location: {
          lat: Number(match.metadata.location_lat) || 0,
          lng: Number(match.metadata.location_lng) || 0
        },
        visitorCount: Number(match.metadata.visitorCount) || 0,
        culturalSignificance: Number(match.metadata.culturalSignificance) || 0.5,
        eventFrequency: String(match.metadata.eventFrequency || "low"),
        nearbyAttractions: Array.isArray(match.metadata.nearbyAttractions) ? match.metadata.nearbyAttractions : []
      }));
      console.log("Processed cultural hotspots:", JSON.stringify(culturalHotspots, null, 2));
      return culturalHotspots;
    } catch (error4) {
      console.error("Failed to initialize cultural routes:", error4);
      this.analyticsService.trackEvent("cultural_transport_initialization_failed", {
        timestamp: Date.now(),
        error: error4 instanceof Error ? error4.message : String(error4)
      });
      return [];
    }
  }
  initializeMetricsMonitoring() {
    setInterval(async () => {
      await this.updateMetrics();
    }, 5 * 60 * 1000);
    this.economyService.on("economicIndicatorsUpdated", async (indicators) => {
      await this.updateEconomicMetrics();
    });
  }
  async updateMetrics() {
    const [carbonEmissions, energyRatio, economyMetrics] = await Promise.all([
      this.calculateCarbonEmissions(),
      this.calculateEnergyRatio(),
      this.getEconomyMetrics()
    ]);
    this.currentMetrics = {
      sustainability: {
        carbonEmissions,
        renewableEnergyRatio: energyRatio,
        greenSpaceIndex: 0,
        airQualityScore: 0,
        waterQualityScore: 0
      },
      economy: economyMetrics,
      social: {
        healthcareAccess: 0,
        educationQuality: 0,
        culturalEngagement: 0,
        civicParticipation: 0,
        communityWellbeing: 0
      },
      infrastructure: {
        trafficCongestion: 0,
        publicTransitReliability: 0,
        wasteRecyclingRate: 0,
        infrastructureHealth: 0,
        housingAvailability: 0
      }
    };
    const update = {
      type: "full",
      metrics: this.currentMetrics,
      source: "city-coordinator"
    };
    this.emit("metricsUpdated", update);
  }
  async updateEconomicMetrics() {
    const economyMetrics = await this.getEconomyMetrics();
    this.currentMetrics = {
      ...this.currentMetrics,
      economy: economyMetrics,
      sustainability: {
        carbonEmissions: 0,
        renewableEnergyRatio: 0,
        greenSpaceIndex: 0,
        airQualityScore: 0,
        waterQualityScore: 0
      },
      infrastructure: {
        trafficCongestion: 0,
        publicTransitReliability: 0,
        wasteRecyclingRate: 0,
        infrastructureHealth: 0,
        housingAvailability: 0
      }
    };
    const update = {
      type: "economy",
      metrics: { economy: economyMetrics },
      source: "city-coordinator"
    };
    this.emit("metricsUpdated", update);
  }
  getCurrentMetrics() {
    return { ...this.currentMetrics };
  }
  async requestMetricsUpdate() {
    await this.updateMetrics();
    return this.getCurrentMetrics();
  }
}

// src/services/cultural-donation.service.ts
import { EventEmitter as EventEmitter28 } from "events";

class CulturalDonationService extends EventEmitter28 {
  cultureService;
  developmentService;
  vectorStore;
  donationProjects = new Map;
  campaigns = new Map;
  recurringDonations = new Map;
  constructor(cultureService, developmentService, vectorStore) {
    super();
    this.cultureService = cultureService;
    this.developmentService = developmentService;
    this.vectorStore = vectorStore;
    this.initializeRecurringDonations();
  }
  async getProjects(filters) {
    const projects = Array.from(this.donationProjects.values());
    if (!filters)
      return projects;
    return projects.filter((project) => (!filters.type || project.type === filters.type) && (!filters.status || project.status === filters.status) && (!filters.district || project.districtId === filters.district));
  }
  async getProject(projectId) {
    return this.donationProjects.get(projectId);
  }
  async getCampaigns(projectId) {
    return Array.from(this.campaigns.values()).filter((campaign) => campaign.projectId === projectId);
  }
  async getCampaign(campaignId) {
    return this.campaigns.get(campaignId);
  }
  async createDonationProject(project) {
    const now = Date.now();
    const newProject = {
      ...project,
      id: `proj_${now}_${Math.random().toString(36).substr(2, 9)}`,
      status: "pending",
      raisedAmount: 0,
      donorCount: 0,
      createdAt: now,
      updatedAt: now
    };
    await this.vectorStore.upsert({
      id: `cultural-project-${newProject.id}`,
      values: await this.vectorStore.createEmbedding(`${newProject.type} ${newProject.title} ${newProject.description} ${newProject.religiousAffiliation?.tradition || ""}`),
      metadata: {
        type: "district",
        subtype: "cultural_project",
        projectId: newProject.id,
        districtId: newProject.districtId,
        culturalImpact: JSON.stringify(newProject.expectedImpact),
        religiousTradition: newProject.religiousAffiliation?.tradition
      }
    });
    this.donationProjects.set(newProject.id, newProject);
    this.emit("project:created", newProject);
    return newProject;
  }
  async createDonationCampaign(projectId, campaign) {
    const project = await this.getProject(projectId);
    if (!project) {
      throw new Error("Project not found");
    }
    const now = Date.now();
    const newCampaign = {
      ...campaign,
      id: `camp_${now}_${Math.random().toString(36).substr(2, 9)}`,
      projectId,
      status: "scheduled",
      raisedAmount: 0,
      donorCount: 0,
      createdAt: now,
      updatedAt: now
    };
    this.campaigns.set(newCampaign.id, newCampaign);
    this.emit("campaign:created", { campaign: newCampaign, project });
    return newCampaign;
  }
  async processDonation(donation) {
    const project = await this.getProject(donation.projectId);
    if (!project) {
      throw new Error("Project not found");
    }
    const now = Date.now();
    const newDonation = {
      ...donation,
      id: `don_${now}_${Math.random().toString(36).substr(2, 9)}`,
      status: "pending",
      createdAt: now
    };
    try {
      project.raisedAmount += donation.amount;
      project.donorCount += 1;
      project.updatedAt = now;
      if (donation.campaignId) {
        const campaign = await this.getCampaign(donation.campaignId);
        if (campaign) {
          campaign.raisedAmount += donation.amount;
          campaign.donorCount += 1;
          campaign.updatedAt = now;
        }
      }
      if (donation.recurringInterval) {
        this.recurringDonations.set(newDonation.id, {
          ...newDonation,
          status: "processed",
          processedAt: now
        });
      }
      if (project.raisedAmount >= project.targetAmount) {
        await this.initiateProjectImplementation(project);
      }
      this.donationProjects.set(project.id, project);
      this.emit("donation:processed", { donation: newDonation, project });
    } catch (error4) {
      this.emit("donation:failed", { donation: newDonation, error: error4 });
      throw error4;
    }
  }
  initializeRecurringDonations() {
    setInterval(() => {
      const now = Date.now();
      for (const [id, donation] of this.recurringDonations) {
        if (this.shouldProcessRecurring(donation, now)) {
          const {
            id: _6,
            status: __,
            processedAt: ___,
            createdAt: ____,
            ...donationData
          } = donation;
          this.processDonation(donationData);
        }
      }
    }, 24 * 60 * 60 * 1000);
  }
  shouldProcessRecurring(donation, now) {
    if (!donation.processedAt)
      return false;
    const daysSinceLastProcess = (now - donation.processedAt) / (24 * 60 * 60 * 1000);
    switch (donation.recurringInterval) {
      case "monthly":
        return daysSinceLastProcess >= 30;
      case "quarterly":
        return daysSinceLastProcess >= 90;
      case "yearly":
        return daysSinceLastProcess >= 365;
      default:
        return false;
    }
  }
  async initiateProjectImplementation(project) {
    await this.developmentService.submitProject({
      type: project.type,
      status: "proposed",
      location: {
        districtId: project.districtId,
        coordinates: project.location
      },
      timeline: {
        proposed: Date.now()
      },
      metrics: {
        costEfficiency: 0.8,
        communityBenefit: 0.9,
        economicGrowth: 0.7,
        qualityOfLife: 0.85
      },
      sustainability: {
        energyEfficiency: 0.8,
        greenScore: 0.7,
        environmentalImpact: 0.75
      },
      culturalImpact: {
        culturalPreservation: project.expectedImpact.culturalPreservation,
        communityEngagement: project.expectedImpact.communityEngagement,
        touristAttraction: project.expectedImpact.touristAttraction,
        religiousConsideration: project.religiousAffiliation ? 0.9 : undefined
      },
      budget: project.raisedAmount
    });
    project.status = "active";
    this.emit("project:implementation:started", project);
  }
}

// src/services/cultural-transport.service.ts
import { EventEmitter as EventEmitter29 } from "events";

class CulturalTransportService extends EventEmitter29 {
  cultureService;
  transportService;
  vectorStore;
  analyticsService;
  constructor(cultureService, transportService, vectorStore, analyticsService) {
    super();
    this.cultureService = cultureService;
    this.transportService = transportService;
    this.vectorStore = vectorStore;
    this.analyticsService = analyticsService;
    this.initializeCulturalRoutes();
  }
  async initializeCulturalRoutes() {
    try {
      await this.optimizeRoutes();
      setInterval(() => this.optimizeRoutes(), 1000 * 60 * 60);
      this.cultureService.on("culturalEventCreated", this.adjustRoutes.bind(this));
      this.analyticsService.trackEvent("cultural_transport_initialized", {
        timestamp: Date.now(),
        status: "success"
      });
    } catch (error4) {
      if (error4 instanceof Error) {
        this.analyticsService.trackEvent("cultural_transport_initialization_failed", {
          timestamp: Date.now(),
          error: error4.message
        });
        console.error("Failed to initialize cultural routes:", error4.message);
      }
    }
  }
  async optimizeRoutes() {
    try {
      const culturalHotspots = await this.identifyCulturalHotspots();
      const routeAdjustments = this.calculateRouteAdjustments(culturalHotspots);
      await this.transportService.updateRoutes(routeAdjustments);
      this.analyticsService.trackEvent("routes_optimized", {
        timestamp: Date.now(),
        hotspotCount: culturalHotspots.length,
        adjustmentCount: routeAdjustments.length
      });
    } catch (error4) {
      this.emit("route:optimization:failed", error4);
      throw error4;
    }
  }
  async identifyCulturalHotspots() {
    const embedding = await this.vectorStore.createEmbedding("cultural hotspots active events");
    const results = await this.vectorStore.query({
      vector: embedding,
      filter: {
        type: { $eq: "transport" },
        subtype: { $eq: "cultural_hotspot" }
      },
      topK: 10
    });
    return results.map((result) => ({
      id: result.id,
      name: result.metadata.name,
      location: result.metadata.location,
      visitorCount: result.metadata.visitorCount,
      culturalSignificance: result.metadata.culturalSignificance,
      eventFrequency: result.metadata.eventFrequency,
      nearbyAttractions: result.metadata.nearbyAttractions || []
    }));
  }
  calculateRouteAdjustments(hotspots) {
    return hotspots.map((hotspot) => ({
      location: hotspot.location,
      priority: this.calculateHotspotPriority(hotspot),
      suggestedStops: this.generateStopSuggestions(hotspot)
    }));
  }
  calculateHotspotPriority(hotspot) {
    return hotspot.visitorCount * 0.4 + hotspot.culturalSignificance * 0.3 + hotspot.eventFrequency * 0.3;
  }
  generateStopSuggestions(hotspot) {
    return {
      primaryStop: {
        name: hotspot.name,
        coordinates: hotspot.location,
        type: "cultural_destination"
      },
      nearbyAttractions: hotspot.nearbyAttractions
    };
  }
  async findImpactedRoutes(location, radius) {
    try {
      const routes = await this.transportService.getNearbyRoutes(location, radius);
      return routes.map((route) => {
        const culturalRoute = {
          ...route,
          path: route.stops.map((stop) => stop.location.coordinates),
          importance: this.calculateRouteImportance(route, location)
        };
        return culturalRoute;
      }).filter((route) => this.calculateRouteImpact(route, location, radius) > 0.3);
    } catch (error4) {
      this.emit("route:impact:analysis:failed", error4);
      throw error4;
    }
  }
  calculateRouteImportance(route, location) {
    const nearestStopDistance = Math.min(...route.stops.map((stop) => this.calculateDistance(stop.location.coordinates, location)));
    const culturalStopsCount = route.stops.filter((stop) => stop.type?.includes("cultural") || stop.type?.includes("event")).length;
    const distanceScore = Math.max(0, 1 - nearestStopDistance / 5000);
    const culturalScore = Math.min(1, culturalStopsCount / 5);
    const utilizationScore = route.metrics.utilization;
    const efficiencyScore = route.metrics.efficiency;
    return distanceScore * 0.3 + culturalScore * 0.3 + utilizationScore * 0.2 + efficiencyScore * 0.2;
  }
  calculateDistance(point1, point2) {
    const [lat1, lon1] = point1;
    const [lat2, lon2] = point2;
    const R = 6371000;
    const \u{3c6}1 = lat1 * Math.PI / 180;
    const \u{3c6}2 = lat2 * Math.PI / 180;
    const \u{394}_ = (lat2 - lat1) * Math.PI / 180;
    const \u{394}_2 = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(\u{394}_ / 2) * Math.sin(\u{394}_ / 2) + Math.cos(\u{3c6}1) * Math.cos(\u{3c6}2) * Math.sin(\u{394}_2 / 2) * Math.sin(\u{394}_2 / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }
  calculateRouteImpact(route, location, radius) {
    return route.importance * 0.5;
  }
  async createEventBasedAdjustments(event, routes) {
    try {
      const adjustments = routes.map((route) => ({
        routeId: route.id,
        adjustmentType: event.expectedAttendance > 1000 ? "major" : "minor",
        temporaryStops: this.generateEventStops(event),
        timeWindow: {
          start: event.startTime - 1800000,
          end: event.endTime + 1800000
        },
        priority: this.calculateEventPriority(event)
      }));
      this.analyticsService.trackEvent("event_adjustments_created", {
        eventId: event.id,
        adjustmentCount: adjustments.length,
        timestamp: Date.now()
      });
      return adjustments;
    } catch (error4) {
      this.emit("route:adjustment:creation:failed", error4);
      throw error4;
    }
  }
  generateEventStops(event) {
    return [
      {
        name: event.name,
        coordinates: event.location,
        type: "event_stop",
        duration: event.endTime - event.startTime
      }
    ];
  }
  calculateEventPriority(event) {
    return Math.min(1, event.expectedAttendance / 1000 * 0.5 + event.impact.intensity * 0.5);
  }
  async adjustRoutes(event) {
    try {
      const impactedRoutes = await this.findImpactedRoutes(event.location, event.impact.radius);
      const adjustments = await this.createEventBasedAdjustments(event, impactedRoutes);
      await this.transportService.modifyRoutes(adjustments);
      this.analyticsService.trackEvent("routes_adjusted", {
        eventId: event.id,
        impactedRoutes: impactedRoutes.length,
        adjustments: adjustments.length,
        timestamp: Date.now()
      });
      this.emit("routes:adjusted", { event, adjustments });
    } catch (error4) {
      if (error4 instanceof Error) {
        this.emit("route:adjustment:failed", { event, error: error4.message });
      }
      throw error4;
    }
  }
}

// node_modules/uuid/wrapper.mjs
var import_dist = __toESM(require_dist3(), 1);
var v1 = import_dist.default.v1;
var v1ToV6 = import_dist.default.v1ToV6;
var v3 = import_dist.default.v3;
var v4 = import_dist.default.v4;
var v5 = import_dist.default.v5;
var v6 = import_dist.default.v6;
var v6ToV1 = import_dist.default.v6ToV1;
var v7 = import_dist.default.v7;
var NIL = import_dist.default.NIL;
var MAX = import_dist.default.MAX;
var version2 = import_dist.default.version;
var validate = import_dist.default.validate;
var stringify = import_dist.default.stringify;
var parse2 = import_dist.default.parse;

// src/services/ai-integration.service.ts
class AIIntegrationService {
  vectorStore;
  activeAgents = new Set;
  systemId = null;
  networkStatus = null;
  decisionHistory = new Map;
  patterns = new Map;
  protocols = new Map;
  lastHeartbeat = new Map;
  HEARTBEAT_TIMEOUT = 5 * 60 * 1000;
  constructor(vectorStore) {
    this.vectorStore = vectorStore;
    this.startHeartbeatMonitoring();
  }
  startHeartbeatMonitoring() {
    setInterval(() => this.checkAgentHeartbeats(), 60 * 1000);
  }
  checkAgentHeartbeats() {
    const now = Date.now();
    for (const [agentId, lastBeat] of this.lastHeartbeat.entries()) {
      if (now - lastBeat > this.HEARTBEAT_TIMEOUT) {
        this.activeAgents.delete(agentId);
        this.lastHeartbeat.delete(agentId);
        this.updateNetworkStatus();
      }
    }
  }
  updateNetworkStatus() {
    if (this.networkStatus) {
      this.networkStatus = {
        ...this.networkStatus,
        connectedAgents: this.activeAgents.size,
        timestamp: Date.now()
      };
    }
  }
  async recordAgentActivity(agentId) {
    if (!this.activeAgents.has(agentId)) {
      this.activeAgents.add(agentId);
    }
    this.lastHeartbeat.set(agentId, Date.now());
    this.updateNetworkStatus();
  }
  async initializeSystem(config) {
    try {
      this.systemId = v4();
      this.activeAgents = new Set(config.agents);
      this.networkStatus = {
        isActive: true,
        connectedAgents: this.activeAgents.size,
        protocol: config.protocol,
        timestamp: Date.now()
      };
      const protocolMetadata = {
        record_type: "protocol",
        protocol_name: config.protocol.name,
        timestamp: Date.now(),
        system_id: this.systemId
      };
      const protocolVector = await this.vectorStore.createEmbedding(JSON.stringify(config.protocol));
      await this.vectorStore.upsert({
        id: `protocol:${this.systemId}`,
        values: protocolVector,
        metadata: protocolMetadata
      });
      if (config.initialState) {
        const stateMetadata = {
          record_type: "state",
          timestamp: Date.now(),
          system_id: this.systemId,
          context_data: JSON.stringify(config.initialState)
        };
        const stateVector = await this.vectorStore.createEmbedding(JSON.stringify(config.initialState));
        await this.vectorStore.upsert({
          id: `state:${this.systemId}`,
          values: stateVector,
          metadata: stateMetadata
        });
      }
      return {
        systemId: this.systemId,
        activeAgents: Array.from(this.activeAgents),
        networkStatus: this.networkStatus
      };
    } catch (error4) {
      throw new Error(`Failed to initialize system: ${error4 instanceof Error ? error4.message : "Unknown error"}`);
    }
  }
  async recordDecision(agentId, decision, context) {
    if (!this.systemId) {
      throw new Error("System not initialized");
    }
    await this.recordAgentActivity(agentId);
    const decisionContext = {
      agentId,
      decision,
      context,
      timestamp: Date.now()
    };
    const decisionId = `decision:${this.systemId}:${agentId}:${Date.now()}`;
    this.decisionHistory.set(decisionId, decisionContext);
    const decisionMetadata = {
      record_type: "decision",
      agent_id: agentId,
      decision_text: decision,
      timestamp: Date.now(),
      system_id: this.systemId,
      context_data: JSON.stringify(context)
    };
    const decisionVector = await this.vectorStore.createEmbedding(JSON.stringify({ decision, context }));
    await this.vectorStore.upsert({
      id: decisionId,
      values: decisionVector,
      metadata: decisionMetadata
    });
  }
  async storePattern(pattern2, context, confidence) {
    if (!this.systemId) {
      throw new Error("System not initialized");
    }
    const patternId = `pattern:${this.systemId}:${Date.now()}`;
    const aiPattern = {
      id: patternId,
      pattern: pattern2,
      context,
      confidence,
      timestamp: Date.now()
    };
    this.patterns.set(patternId, aiPattern);
    const patternMetadata = {
      record_type: "pattern",
      pattern_text: pattern2,
      confidence: confidence.toString(),
      timestamp: Date.now(),
      system_id: this.systemId,
      context_data: JSON.stringify(context)
    };
    const patternVector = await this.vectorStore.createEmbedding(pattern2);
    await this.vectorStore.upsert({
      id: patternId,
      values: patternVector,
      metadata: patternMetadata
    });
  }
  async findSimilarDecisions(content, limit = 5) {
    const vector = await this.vectorStore.createEmbedding(content);
    const results = await this.vectorStore.query({
      vector,
      filter: {
        record_type: { $eq: "decision" }
      },
      topK: limit
    });
    if (!results.matches)
      return [];
    return results.matches.map((result) => {
      const metadata = result.metadata;
      const context = metadata.context_data ? JSON.parse(metadata.context_data) : {};
      return {
        agentId: metadata.agent_id,
        decision: metadata.decision_text,
        context,
        timestamp: metadata.timestamp
      };
    });
  }
  async findSimilarPatterns(content, limit = 5) {
    const vector = await this.vectorStore.createEmbedding(content);
    const results = await this.vectorStore.query({
      vector,
      filter: {
        record_type: { $eq: "pattern" }
      },
      topK: limit
    });
    if (!results.matches)
      return [];
    return results.matches.map((result) => {
      const metadata = result.metadata;
      const context = metadata.context_data ? JSON.parse(metadata.context_data) : {};
      return {
        id: result.id,
        pattern: metadata.pattern_text,
        context,
        confidence: parseFloat(metadata.confidence),
        timestamp: metadata.timestamp
      };
    });
  }
  getSystemStatus() {
    return this.networkStatus;
  }
  getActiveAgents() {
    return Array.from(this.activeAgents);
  }
  isInitialized() {
    return this.systemId !== null && this.networkStatus !== null;
  }
}

// src/services/donation.service.ts
import { EventEmitter as EventEmitter30 } from "events";
class DonationService extends EventEmitter30 {
  vectorStore;
  departmentService;
  districtService;
  socialDynamicsService;
  donations = new Map;
  announcements = new Map;
  donationImpacts = new Map;
  eventBus;
  challenges = new Map;
  culturalMilestones = new Map;
  constructor(vectorStore, departmentService, districtService, socialDynamicsService) {
    super();
    this.vectorStore = vectorStore;
    this.departmentService = departmentService;
    this.districtService = districtService;
    this.socialDynamicsService = socialDynamicsService;
    this.eventBus = EventBus.getInstance();
    this.initializeImpactTracking();
  }
  async processDonation(donationData) {
    const donationId = crypto.randomUUID();
    const donation = {
      id: donationId,
      ...donationData,
      status: "pending",
      timestamp: Date.now()
    };
    this.eventBus.emit("departmentBudgetUpdate", {
      departmentId: donation.departmentId,
      type: "donation",
      amount: donation.amount,
      source: donation.donorId,
      timestamp: donation.timestamp
    });
    this.donations.set(donationId, donation);
    const impact = await this.assessDonationImpact(donation);
    this.donationImpacts.set(donationId, impact);
    this.eventBus.emit("donationProcessed", {
      donationId,
      amount: donation.amount,
      department: donation.departmentId,
      district: donation.districtId,
      timestamp: donation.timestamp
    });
    await this.createDonationAnnouncement(donation);
    return donationId;
  }
  async createDonationAnnouncement(donation) {
    const impact = this.donationImpacts.get(donation.id);
    const announcement = {
      id: crypto.randomUUID(),
      donationId: donation.id,
      message: await this.generateAnnouncementMessage(donation),
      impactDescription: await this.generateImpactDescription(donation, impact),
      timestamp: Date.now(),
      districtReactions: {
        gratitude: 0,
        excitement: 0,
        inspiration: 0
      }
    };
    this.announcements.set(announcement.id, announcement);
    await this.announceInDistrict(donation.districtId, announcement);
    donation.status = "announced";
    this.donations.set(donation.id, donation);
  }
  async getDonationsByDistrict(districtId) {
    return Array.from(this.donations.values()).filter((d) => d.districtId === districtId).sort((a, b) => b.timestamp - a.timestamp);
  }
  async getDonationsByDepartment(departmentId) {
    return Array.from(this.donations.values()).filter((d) => d.departmentId === departmentId).sort((a, b) => b.timestamp - a.timestamp);
  }
  async getDistrictAnnouncements(districtId) {
    const districtDonations = await this.getDonationsByDistrict(districtId);
    return Array.from(this.announcements.values()).filter((a) => districtDonations.some((d) => d.id === a.donationId)).sort((a, b) => b.timestamp - a.timestamp);
  }
  async addReactionToAnnouncement(announcementId, reaction) {
    const announcement = this.announcements.get(announcementId);
    if (announcement) {
      announcement.districtReactions[reaction]++;
      this.announcements.set(announcementId, announcement);
    }
  }
  async getDonationImpact(donationId) {
    return this.donationImpacts.get(donationId);
  }
  async assessDonationImpact(donation) {
    const baseImpact = donation.amount / 1000;
    let multipliers = {
      infrastructure: this.getImpactMultiplier("infrastructure", donation.purpose),
      community: this.getImpactMultiplier("community", donation.purpose),
      cultural: this.getImpactMultiplier("cultural", donation.purpose),
      education: this.getImpactMultiplier("education", donation.purpose),
      environment: this.getImpactMultiplier("environment", donation.purpose)
    };
    if (donation.category === "religious" || donation.category === "cultural") {
      multipliers.cultural *= 1.5;
      multipliers.community *= 1.3;
    }
    if (donation.subcategory?.religious) {
      if (donation.subcategory.religious.occasion)
        multipliers.cultural *= 1.2;
      if (donation.subcategory.religious.ritual)
        multipliers.cultural *= 1.1;
    }
    if (donation.subcategory?.cultural) {
      if (donation.subcategory.cultural.festival)
        multipliers.cultural *= 1.2;
      if (donation.subcategory.cultural.artForm)
        multipliers.cultural *= 1.15;
    }
    return {
      infrastructureImprovement: baseImpact * multipliers.infrastructure,
      communityWellbeing: baseImpact * multipliers.community,
      culturalEnhancement: baseImpact * multipliers.cultural,
      educationalProgress: baseImpact * multipliers.education,
      environmentalBenefit: baseImpact * multipliers.environment
    };
  }
  getImpactMultiplier(category, purpose) {
    const purposeLower = purpose.toLowerCase();
    switch (category) {
      case "infrastructure":
        return purposeLower.includes("infrastructure") || purposeLower.includes("building") ? 1.5 : 0.8;
      case "community":
        return purposeLower.includes("community") || purposeLower.includes("social") ? 1.4 : 0.7;
      case "cultural":
        return purposeLower.includes("culture") || purposeLower.includes("art") ? 1.3 : 0.6;
      case "education":
        return purposeLower.includes("education") || purposeLower.includes("learning") ? 1.6 : 0.9;
      case "environment":
        return purposeLower.includes("environment") || purposeLower.includes("green") ? 1.4 : 0.8;
      default:
        return 1;
    }
  }
  async generateAnnouncementMessage(donation) {
    const department = await this.departmentService.getDepartment(donation.departmentId);
    let message2 = `\uD83C\uDF89 Exciting news! ${donation.donorName} has made a generous donation of \$${donation.amount.toLocaleString()} `;
    switch (donation.category) {
      case "religious":
        const religious = donation.subcategory?.religious;
        message2 += `to support our ${religious?.religion} community${religious?.occasion ? ` for ${religious.occasion}` : ""}! `;
        if (religious?.ritual) {
          message2 += `This will help preserve our sacred ${religious.ritual} traditions. `;
        }
        break;
      case "cultural":
        const cultural = donation.subcategory?.cultural;
        message2 += `to celebrate our cultural heritage${cultural?.festival ? ` during ${cultural.festival}` : ""}! `;
        if (cultural?.artForm) {
          message2 += `This will help preserve and promote ${cultural.artForm}. `;
        }
        break;
      default:
        message2 += `to support ${department?.name}'s initiatives in our district! `;
    }
    message2 += `This contribution will help ${donation.purpose}. `;
    if (donation.communityParticipation) {
      message2 += `

\uD83D\uDC65 Join ${donation.communityParticipation.volunteers} community members in upcoming `;
      message2 += `${donation.communityParticipation.events.join(", ")}! `;
      if (donation.communityParticipation.activities.length > 0) {
        message2 += `\nActivities include: ${donation.communityParticipation.activities.join(", ")}`;
      }
    }
    message2 += `

Thank you for making our city better! \uD83C\uDF1F`;
    return message2;
  }
  async generateImpactDescription(donation, impact) {
    if (!impact)
      return "";
    const highestImpact = Object.entries(impact).reduce((a, b) => a[1] > b[1] ? a : b);
    const impactDescriptions = {
      infrastructureImprovement: "improving our city's infrastructure",
      communityWellbeing: "enhancing community wellbeing",
      culturalEnhancement: "enriching our cultural landscape",
      educationalProgress: "advancing educational opportunities",
      environmentalBenefit: "supporting environmental initiatives"
    };
    let description = `This donation will have the greatest impact in ${impactDescriptions[highestImpact[0]]}. `;
    description += `The benefits will reach approximately ${Math.floor(donation.amount / 100)} community members. \uD83C\uDF31

`;
    if (donation.category === "religious" || donation.category === "cultural") {
      description += "Cultural Impact:\n";
      description += `\u2022 Tradition Preservation: ${Math.round(impact.culturalEnhancement * 120)}%\n`;
      description += `\u2022 Community Engagement: ${Math.round(impact.communityWellbeing * 110)}%\n`;
      if (donation.category === "religious") {
        const religious = donation.subcategory?.religious;
        description += `\u2022 Supporting ${religious?.community || "religious"} community activities\n`;
      } else {
        const cultural = donation.subcategory?.cultural;
        description += `\u2022 Promoting ${cultural?.tradition || "cultural"} traditions\n`;
      }
    }
    return description;
  }
  async announceInDistrict(districtId, announcement) {
    this.eventBus.emit("districtAnnouncement", {
      districtId,
      type: "donation",
      content: `${announcement.message}\n\n${announcement.impactDescription}`,
      timestamp: announcement.timestamp
    });
    this.eventBus.emit("communityMoodUpdate", {
      districtId,
      event: "donation",
      sentiment: 0.8,
      intensity: Math.min(1, Math.log10(this.donations.get(announcement.donationId)?.amount || 0) / 5)
    });
  }
  initializeImpactTracking() {
    setInterval(() => this.updateDonationImpacts(), 60 * 60 * 1000);
  }
  async updateDonationImpacts() {
    for (const [donationId, donation] of this.donations.entries()) {
      if (donation.status === "completed")
        continue;
      const impact = this.donationImpacts.get(donationId);
      if (impact) {
        const timeSinceDonation = Date.now() - donation.timestamp;
        if (timeSinceDonation > 7 * 24 * 60 * 60 * 1000) {
          donation.status = "completed";
          donation.impact.completionDate = Date.now();
          this.donations.set(donationId, donation);
          await this.announceCompletion(donation, impact);
        }
      }
    }
  }
  async announceCompletion(donation, impact) {
    const completionMessage = `\uD83C\uDFAF Impact Update: The donation from ${donation.donorName} has been fully utilized! Here's what we achieved:\n\n` + `\u2022 Infrastructure: ${Math.round(impact.infrastructureImprovement * 100)}% improvement\n` + `\u2022 Community: ${Math.round(impact.communityWellbeing * 100)}% enhancement\n` + `\u2022 Culture: ${Math.round(impact.culturalEnhancement * 100)}% enrichment\n` + `\u2022 Education: ${Math.round(impact.educationalProgress * 100)}% advancement\n` + `\u2022 Environment: ${Math.round(impact.environmentalBenefit * 100)}% benefit\n\n` + `Thank you for making our district better! \uD83C\uDF1F`;
    this.eventBus.emit("districtAnnouncement", {
      districtId: donation.districtId,
      type: "donation_completion",
      content: completionMessage,
      timestamp: Date.now()
    });
  }
  async suggestCommunityActivities(donation) {
    const activities = [];
    if (donation.category === "religious") {
      const religious = donation.subcategory?.religious;
      activities.push(`${religious?.religion || "Religious"} community gathering`, `Traditional ceremony participation`, `Youth education programs`, `Community feast organization`);
      if (religious?.ritual) {
        activities.push(`${religious.ritual} preparation`, `Sacred space maintenance`);
      }
    } else if (donation.category === "cultural") {
      const cultural = donation.subcategory?.cultural;
      activities.push(`Cultural workshop organization`, `Traditional art exhibitions`, `Community performance events`);
      if (cultural?.artForm) {
        activities.push(`${cultural.artForm} workshops`, `Youth training programs`);
      }
      if (cultural?.festival) {
        activities.push(`${cultural.festival} preparation`, `Festival coordination`);
      }
    }
    return activities;
  }
  async getUpcomingCulturalEvents(districtId) {
    const districtDonations = await this.getDonationsByDistrict(districtId);
    const events = {
      religious: new Set,
      cultural: new Set
    };
    districtDonations.filter((d) => d.status !== "completed" && (d.category === "religious" || d.category === "cultural")).forEach((d) => {
      if (d.category === "religious" && d.subcategory?.religious?.occasion) {
        events.religious.add(d.subcategory.religious.occasion);
      } else if (d.category === "cultural" && d.subcategory?.cultural?.festival) {
        events.cultural.add(d.subcategory.cultural.festival);
      }
    });
    return {
      religious: Array.from(events.religious),
      cultural: Array.from(events.cultural)
    };
  }
  async createDonationChallenge(challenge) {
    const id = crypto.randomUUID();
    const newChallenge = {
      id,
      ...challenge,
      currentAmount: 0,
      participants: []
    };
    this.challenges.set(id, newChallenge);
    this.eventBus.emit("districtAnnouncement", {
      districtId: "all",
      type: "challenge_created",
      content: this.generateChallengeAnnouncement(newChallenge),
      timestamp: Date.now()
    });
    return id;
  }
  async participateInChallenge(donationId, challengeId) {
    const donation = this.donations.get(donationId);
    const challenge = this.challenges.get(challengeId);
    if (!donation || !challenge)
      return;
    challenge.currentAmount += donation.amount;
    challenge.participants.push(donation.donorId);
    challenge.milestones.forEach((milestone) => {
      if (!milestone.achieved && challenge.currentAmount >= milestone.amount) {
        milestone.achieved = true;
        this.announceMilestoneAchievement(challenge, milestone);
      }
    });
    if (challenge.currentAmount >= challenge.targetAmount) {
      await this.completeDonationChallenge(challenge);
    }
    this.challenges.set(challengeId, challenge);
  }
  async createCulturalMilestone(milestone) {
    const id = crypto.randomUUID();
    const newMilestone = {
      id,
      ...milestone,
      achievedDate: Date.now()
    };
    this.culturalMilestones.set(id, newMilestone);
    await this.announceCulturalMilestone(newMilestone);
    return id;
  }
  async addCommunityStory(donationId, story) {
    const donation = this.donations.get(donationId);
    if (!donation)
      return;
    if (!donation.culturalSignificance) {
      donation.culturalSignificance = {
        historicalContext: "",
        culturalSymbols: [],
        traditionLinks: [],
        communityStories: []
      };
    }
    donation.culturalSignificance.communityStories.push(story);
    this.donations.set(donationId, donation);
    this.eventBus.emit("districtAnnouncement", {
      districtId: donation.districtId,
      type: "community_story",
      content: `\uD83D\uDCD6 New Community Story Added!

"${story}"\n\nShare your story about this donation's impact!`,
      timestamp: Date.now()
    });
  }
  async getActiveChallenges() {
    const now = Date.now();
    return Array.from(this.challenges.values()).filter((c) => c.startDate <= now && c.endDate >= now).sort((a, b) => b.currentAmount / b.targetAmount - a.currentAmount / a.targetAmount);
  }
  async getDonationChallengeProgress(challengeId) {
    const challenge = this.challenges.get(challengeId);
    if (!challenge)
      throw new Error("Challenge not found");
    const donations = Array.from(this.donations.values()).filter((d) => d.challengeId === challengeId);
    const topDonors = donations.reduce((acc, d) => {
      const existing = acc.find((x) => x.donorName === d.donorName);
      if (existing) {
        existing.amount += d.amount;
      } else {
        acc.push({ donorName: d.donorName, amount: d.amount });
      }
      return acc;
    }, []).sort((a, b) => b.amount - a.amount).slice(0, 5);
    const recentMilestones = challenge.milestones.filter((m) => m.achieved).map((m) => ({
      description: m.reward,
      achievedDate: Date.now()
    }));
    return {
      challenge,
      topDonors,
      recentMilestones,
      communityImpact: this.generateCommunityImpactSummary(challenge)
    };
  }
  generateChallengeAnnouncement(challenge) {
    return `\uD83C\uDF1F New Donation Challenge: ${challenge.title} \uD83C\uDF1F

` + `${challenge.description}\n\n` + `\uD83C\uDFAF Goal: $${challenge.targetAmount.toLocaleString()}\n` + `\u23F3 Ends: ${new Date(challenge.endDate).toLocaleDateString()}\n\n` + `\uD83C\uDFC6 Rewards:
` + `\u2022 ${challenge.rewards.badge} - ${challenge.rewards.title}\n` + challenge.rewards.perks.map((perk) => `\u2022 ${perk}`).join("\n") + "\n\n" + `Join us in making a difference! \uD83D\uDCAB`;
  }
  async completeDonationChallenge(challenge) {
    const completionMessage = `\uD83C\uDF89 Amazing Achievement! The ${challenge.title} Challenge is Complete! \uD83C\uDF89

` + `Together, we raised \$${challenge.currentAmount.toLocaleString()} ` + `with ${challenge.participants.length} generous donors!\n\n` + `\uD83C\uDF1F Community Impact:
${this.generateCommunityImpactSummary(challenge)}\n\n` + `Thank you to all participants! Your badges and rewards are on the way! \uD83C\uDFC6`;
    this.eventBus.emit("districtAnnouncement", {
      districtId: "all",
      type: "challenge_completed",
      content: completionMessage,
      timestamp: Date.now()
    });
  }
  generateCommunityImpactSummary(challenge) {
    const progress = challenge.communityGoal.progress / challenge.communityGoal.target * 100;
    return `${challenge.communityGoal.description}\n` + `Progress: ${Math.round(progress)}% complete\n` + `Impact: ${this.generateImpactMetric(challenge.currentAmount)}`;
  }
  generateImpactMetric(amount) {
    const metrics = [
      { threshold: 1000, message: "Supporting local community initiatives" },
      { threshold: 5000, message: "Enabling cultural preservation projects" },
      { threshold: 1e4, message: "Transforming community spaces" },
      { threshold: 50000, message: "Creating lasting cultural legacy" },
      { threshold: 1e5, message: "Revolutionizing community development" }
    ];
    const applicable = metrics.filter((m) => amount >= m.threshold).map((m) => m.message).join(" \u2022 ");
    return applicable || "Every contribution makes a difference";
  }
  async announceMilestoneAchievement(challenge, milestone) {
    const message2 = `\uD83C\uDFAF Milestone Achieved in ${challenge.title}!\n\n` + `We've reached \$${milestone.amount.toLocaleString()}!\n` + `\uD83C\uDF81 Reward Unlocked: ${milestone.reward}\n\n` + `Keep the momentum going! Next milestone: \$${this.getNextMilestone(challenge, milestone.amount)?.amount.toLocaleString() || "Final Goal"}`;
    this.eventBus.emit("districtAnnouncement", {
      districtId: "all",
      type: "milestone_achieved",
      content: message2,
      timestamp: Date.now()
    });
  }
  getNextMilestone(challenge, currentAmount) {
    return challenge.milestones.filter((m) => m.amount > currentAmount).sort((a, b) => a.amount - b.amount)[0];
  }
  async announceCulturalMilestone(milestone) {
    const message2 = `\uD83C\uDF8A Cultural Milestone Achieved: ${milestone.title} \uD83C\uDF8A

` + `${milestone.description}\n\n` + `\uD83C\uDF1F Impact Metrics:
` + `\u2022 Cultural Value: ${Math.round(milestone.impact.culturalValue * 100)}%\n` + `\u2022 Community Engagement: ${Math.round(milestone.impact.communityEngagement * 100)}%\n` + `\u2022 Tradition Preservation: ${Math.round(milestone.impact.traditionPreservation * 100)}%\n\n` + `\uD83C\uDF89 Celebration Event:
` + `${milestone.celebration.event}\n` + `\uD83D\uDCC5 ${new Date(milestone.celebration.date).toLocaleDateString()}\n` + `Activities: ${milestone.celebration.activities.join(", ")}\n` + (milestone.celebration.specialGuests ? `Special Guests: ${milestone.celebration.specialGuests.join(", ")}\n` : "") + `
Join us in celebrating this achievement! \uD83C\uDF1F`;
    this.eventBus.emit("districtAnnouncement", {
      districtId: "all",
      type: "cultural_milestone",
      content: message2,
      timestamp: Date.now()
    });
  }
}

// src/services/district-culture.service.ts
import { EventEmitter as EventEmitter31 } from "events";

class DistrictCultureService extends EventEmitter31 {
  cultureService;
  districtService;
  vectorStore;
  culturalDistricts = new Map;
  religiousZones = new Map;
  constructor(cultureService, districtService, vectorStore) {
    super();
    this.cultureService = cultureService;
    this.districtService = districtService;
    this.vectorStore = vectorStore;
    this.initializeCulturalMapping();
  }
  async initializeCulturalMapping() {
    this.cultureService.on("culturalEventCreated", this.handleNewCulturalEvent.bind(this));
    this.districtService.on("districtUpdated", this.updateDistrictCulture.bind(this));
    setInterval(() => this.monitorReligiousZones(), 60 * 60 * 1000);
  }
  async createReligiousZone(zone) {
    const newZone = {
      id: crypto.randomUUID(),
      ...zone
    };
    await this.vectorStore.upsert({
      id: `religious-zone-${newZone.id}`,
      values: await this.vectorStore.createEmbedding(`${newZone.type} ${newZone.name} religious zone in district ${newZone.districtId}`),
      metadata: {
        type: "district",
        subtype: "religious_zone",
        zoneId: newZone.id,
        districtId: newZone.districtId,
        zoneType: newZone.type,
        status: newZone.status
      }
    });
    this.religiousZones.set(newZone.id, newZone);
    await this.updateCulturalDistrict(newZone.districtId);
    this.emit("religiousZoneCreated", newZone);
    return newZone;
  }
  async createCulturalDistrict(district) {
    const newDistrict = {
      id: crypto.randomUUID(),
      ...district
    };
    this.culturalDistricts.set(newDistrict.id, newDistrict);
    await this.updateDistrictMetrics(newDistrict.id);
    this.emit("culturalDistrictCreated", newDistrict);
    return newDistrict;
  }
  async handleNewCulturalEvent(event) {
    const district = await this.districtService.getDistrict(event.location.districtId);
    if (!district)
      throw new Error(`District not found: ${event.location.districtId}`);
    await this.districtService.updateMetrics(district.id, {
      culturalActivity: await this.calculateCulturalActivity(district, event),
      communityEngagement: await this.calculateCommunityEngagement(district, event),
      religiousHarmony: await this.calculateReligiousHarmony(district, event)
    });
    await this.vectorStore.upsert({
      id: `district-culture-${district.id}-${event.id}`,
      values: await this.vectorStore.createEmbedding(`${event.type} ${event.title} in ${district.name}`),
      metadata: {
        type: "district",
        subtype: "cultural",
        districtId: district.id,
        eventId: event.id,
        culturalImpact: JSON.stringify(event.impact)
      }
    });
    const culturalDistrict = this.culturalDistricts.get(district.id);
    if (culturalDistrict) {
      culturalDistrict.culturalEvents.push(event.id);
      await this.updateDistrictMetrics(district.id);
    }
  }
  async calculateCulturalActivity(district, event) {
    const baseActivity = 0.8;
    const religiousZones = Array.from(this.religiousZones.values()).filter((zone) => zone.districtId === district.id);
    const zoneImpact = religiousZones.reduce((sum, zone) => sum + zone.culturalMetrics.communityEngagement, 0) / Math.max(religiousZones.length, 1);
    return (baseActivity + zoneImpact) / 2;
  }
  async calculateCommunityEngagement(district, event) {
    const baseEngagement = 0.7;
    const religiousZones = Array.from(this.religiousZones.values()).filter((zone) => zone.districtId === district.id);
    const zoneEngagement = religiousZones.reduce((sum, zone) => sum + zone.culturalMetrics.socialImpact, 0) / Math.max(religiousZones.length, 1);
    return (baseEngagement + zoneEngagement) / 2;
  }
  async calculateReligiousHarmony(district, event) {
    const religiousZones = Array.from(this.religiousZones.values()).filter((zone) => zone.districtId === district.id);
    return religiousZones.reduce((sum, zone) => sum + zone.culturalMetrics.interfaithDialogue, 0) / Math.max(religiousZones.length, 1);
  }
  async monitorReligiousZones() {
    for (const zone of this.religiousZones.values()) {
      if (zone.status === "active") {
        await this.updateZoneMetrics(zone);
      }
    }
  }
  async updateZoneMetrics(zone) {
    const totalParticipation = zone.activities.reduce((sum, activity) => sum + activity.participation, 0);
    zone.culturalMetrics = {
      communityEngagement: Math.min(totalParticipation / zone.capacity, 1),
      interfaithDialogue: this.calculateInterfaithDialogue(zone),
      culturalPreservation: 0.9,
      socialImpact: this.calculateSocialImpact(zone)
    };
    this.religiousZones.set(zone.id, zone);
    this.emit("zoneMetricsUpdated", zone);
  }
  calculateInterfaithDialogue(zone) {
    const interfaithActivities = zone.activities.filter((activity) => activity.name.toLowerCase().includes("interfaith") || activity.name.toLowerCase().includes("dialogue"));
    return interfaithActivities.length > 0 ? interfaithActivities.reduce((sum, activity) => sum + activity.participation, 0) / (zone.capacity * interfaithActivities.length) : 0;
  }
  calculateSocialImpact(zone) {
    const communityActivities = zone.activities.filter((activity) => activity.name.toLowerCase().includes("community") || activity.name.toLowerCase().includes("social"));
    return communityActivities.length > 0 ? communityActivities.reduce((sum, activity) => sum + activity.participation, 0) / (zone.capacity * communityActivities.length) : 0;
  }
  async updateCulturalDistrict(districtId) {
    const district = this.culturalDistricts.get(districtId);
    if (!district)
      return;
    const zones = Array.from(this.religiousZones.values()).filter((zone) => zone.districtId === districtId);
    district.zones = zones;
    await this.updateDistrictMetrics(districtId);
  }
  async updateDistrictMetrics(districtId) {
    const district = this.culturalDistricts.get(districtId);
    if (!district)
      return;
    const activeZones = district.zones.filter((zone) => zone.status === "active");
    district.metrics = {
      diversity: this.calculateZoneDiversity(activeZones),
      preservation: this.calculatePreservationScore(activeZones),
      engagement: this.calculateDistrictEngagement(activeZones),
      harmony: this.calculateReligiousHarmonyScore(activeZones)
    };
    this.culturalDistricts.set(districtId, district);
    this.emit("districtMetricsUpdated", district);
  }
  calculateZoneDiversity(zones) {
    const uniqueTypes = new Set(zones.map((zone) => zone.type));
    return uniqueTypes.size / 5;
  }
  calculatePreservationScore(zones) {
    return zones.reduce((sum, zone) => sum + zone.culturalMetrics.culturalPreservation, 0) / Math.max(zones.length, 1);
  }
  calculateDistrictEngagement(zones) {
    return zones.reduce((sum, zone) => sum + zone.culturalMetrics.communityEngagement, 0) / Math.max(zones.length, 1);
  }
  calculateReligiousHarmonyScore(zones) {
    return zones.reduce((sum, zone) => sum + zone.culturalMetrics.interfaithDialogue, 0) / Math.max(zones.length, 1);
  }
  async updateDistrictCulture(district) {
    const culturalDistrict = this.culturalDistricts.get(district.id);
    if (culturalDistrict) {
      await this.updateDistrictMetrics(district.id);
      this.emit("districtCultureUpdated", culturalDistrict);
    }
  }
}

// src/services/district-websocket.service.ts
import { WebSocket as WebSocket2 } from "ws";
import { EventEmitter as EventEmitter32 } from "events";

class DistrictWebSocketService extends EventEmitter32 {
  metricsService;
  connections = new Map;
  heartbeatInterval;
  constructor(metricsService) {
    super();
    this.metricsService = metricsService;
    this.initializeHeartbeat();
    this.setupMetricsListener();
  }
  setupMetricsListener() {
    this.metricsService.on("metricsUpdated", (metrics) => {
      for (const [districtId, connections] of this.connections.entries()) {
        const districtMetrics = metrics[districtId];
        if (districtMetrics) {
          this.broadcastToDistrict(districtId, {
            type: "metrics",
            data: districtMetrics,
            timestamp: Date.now()
          });
        }
      }
    });
  }
  handleConnection(ws, districtId) {
    ws.districtId = districtId;
    ws.lastActivity = Date.now();
    if (!this.connections.has(districtId)) {
      this.connections.set(districtId, new Set);
    }
    this.connections.get(districtId).add(ws);
    this.metricsService.getCurrentMetrics(districtId).then((metrics) => {
      ws.send(JSON.stringify({
        type: "initial",
        data: metrics,
        timestamp: Date.now()
      }));
    });
    ws.on("message", (message2) => this.handleMessage(ws, message2));
    ws.on("close", () => {
      this.handleDisconnection(ws);
    });
    ws.on("error", (error4) => {
      this.handleError(ws, error4);
    });
  }
  handleMessage(ws, message2) {
    try {
      const data = JSON.parse(message2);
      ws.lastActivity = Date.now();
      switch (data.type) {
        case "heartbeat":
          this.handleHeartbeat(ws);
          break;
        case "subscribe":
          this.handleSubscribe(ws, data);
          break;
        case "unsubscribe":
          this.handleUnsubscribe(ws, data);
          break;
      }
    } catch (error4) {
      this.handleError(ws, error4);
    }
  }
  handleDisconnection(ws) {
    if (ws.districtId) {
      this.connections.get(ws.districtId)?.delete(ws);
      this.emit("connectionClosed", {
        districtId: ws.districtId,
        timestamp: Date.now()
      });
    }
  }
  handleError(ws, error4) {
    this.emit("connectionError", {
      districtId: ws.districtId,
      error: error4.message,
      timestamp: Date.now()
    });
  }
  broadcastToDistrict(districtId, message2) {
    const connections = this.connections.get(districtId);
    if (!connections)
      return;
    const messageStr = JSON.stringify(message2);
    for (const client of connections) {
      if (client.readyState === WebSocket2.OPEN) {
        client.send(messageStr);
      }
    }
  }
  initializeHeartbeat() {
    this.heartbeatInterval = setInterval(() => {
      const now = Date.now();
      for (const connections of this.connections.values()) {
        for (const client of connections) {
          if (now - (client.lastActivity || 0) > 30000) {
            client.ping();
          }
        }
      }
    }, 15000);
  }
  handleHeartbeat(ws) {
    ws.lastActivity = Date.now();
    ws.send(JSON.stringify({ type: "heartbeat", timestamp: Date.now() }));
  }
  handleSubscribe(ws, data) {
    const { metrics } = data;
  }
  handleUnsubscribe(ws, data) {
    const { metrics } = data;
  }
}

// src/services/app.services.ts
if (false) {
}
var weatherService;
var transportService;
var cityRhythmService;
var socialDynamicsService;
var analyticsService = new AnalyticsService;
var togetherService = new TogetherService("709a06ddfc6329db17b85f1762e7798d3b4e1c50852d12f3b9bbac2de5980a27");
var vectorStore = new VectorStoreService(togetherService);
var metricsService = new MetricsService(vectorStore);
var cityService = new CityService(metricsService);
var departmentService = new DepartmentService(vectorStore, togetherService, analyticsService, metricsService);
var districtWebSocket = new DistrictWebSocketService(metricsService);
var citizenService = new CitizenService(vectorStore, togetherService, departmentService, analyticsService);
var emergencyService = new EmergencyService(vectorStore, departmentService, citizenService);
var initialDistrictCultureService = new DistrictCultureService(undefined, undefined, vectorStore);
var initialDistrictService = new DistrictService(cityService, vectorStore, togetherService, analyticsService, initialDistrictCultureService);
var initialCityRhythm = new CityRhythmService(vectorStore, citizenService, undefined, departmentService);
var initialEmergency = new EmergencyService(vectorStore, departmentService, citizenService);
var initialWeather = new WeatherService(vectorStore, cityService, undefined, initialCityRhythm, initialEmergency);
var initialTransport = new TransportService(vectorStore, initialWeather, initialCityRhythm, initialEmergency, initialDistrictService, metricsService);
weatherService = new WeatherService(vectorStore, cityService, initialTransport, initialCityRhythm, initialEmergency);
transportService = new TransportService(vectorStore, weatherService, initialCityRhythm, initialEmergency, initialDistrictService, metricsService);
cityRhythmService = new CityRhythmService(vectorStore, citizenService, transportService, departmentService);
socialDynamicsService = new SocialDynamicsService(vectorStore, departmentService, citizenService, initialWeather, cityRhythmService);
var cultureService = new CultureService(vectorStore, weatherService, socialDynamicsService, cityRhythmService);
var landmarkService = new LandmarkService(vectorStore, analyticsService);
var agentCulture = new AgentCultureService(cultureService, vectorStore);
var districtCultureService = new DistrictCultureService(cultureService, undefined, vectorStore);
var districtService = new DistrictService(cityService, vectorStore, togetherService, analyticsService, districtCultureService);
districtCultureService.districtService = districtService;
var aiIntegration = new AIIntegrationService(vectorStore);
var collaborationService = new AgentCollaborationService(togetherService, vectorStore, cityService, analyticsService, aiIntegration);
var socketManager = new SocketManagerService(collaborationService);
var cityEventsService = new CityEventsService(metricsService, collaborationService, vectorStore, districtService, analyticsService);
var smartInfrastructureService = new SmartInfrastructureService(vectorStore, metricsService, transportService);
var cityMemory = new CityMemoryService(vectorStore, cultureService, landmarkService, districtService, smartInfrastructureService, analyticsService);
var environmentService = new EnvironmentService(vectorStore, districtService, smartInfrastructureService, analyticsService);
var initialEconomyService = new EconomyService(vectorStore, districtService);
var cityCoordinator = new CityCoordinatorService(vectorStore, departmentService, environmentService, transportService, socialDynamicsService, analyticsService, cityMemory, initialEconomyService);
var departmentAgentService = new DepartmentAgentService(togetherService, analyticsService, departmentService, metricsService);
var developmentService = new DevelopmentService(vectorStore, districtService, smartInfrastructureService, environmentService);
var spatialCoordination = new SpatialCoordinationService(vectorStore, districtService, emergencyService);
var conversationService = new ConversationService(togetherService, vectorStore, cityService, collaborationService, cityMemory, spatialCoordination, agentCulture, emergencyService, cityEventsService);
var adaptiveLearning = new AdaptiveLearningService(vectorStore, metricsService, cityService);
var culturalDonation = new CulturalDonationService(cultureService, developmentService, vectorStore);
var culturalTransport = new CulturalTransportService(cultureService, transportService, vectorStore, analyticsService);
var economyService = new EconomyService(vectorStore, districtService);
var donationService = new DonationService(vectorStore, departmentService, districtService, socialDynamicsService);
function createStore() {
  return {
    services: {
      donationService,
      districtWebSocket,
      togetherService,
      vectorStore,
      conversationService,
      cityService,
      analyticsService,
      collaborationService,
      socketManager,
      districtService,
      cityEventsService,
      metricsService,
      departmentService,
      citizenService,
      departmentAgentService,
      developmentService,
      environmentService,
      spatialCoordination,
      cityMemory,
      culture: cultureService,
      economyService,
      adaptiveLearning,
      cityCoordinator,
      cityRhythm: cityRhythmService,
      culturalDonation,
      culturalTransport,
      aiIntegration
    },
    conversations: new Map
  };
}

// src/controllers/district.controller.ts
var DistrictController = new Elysia({ prefix: "/districts" }).get("/", async ({ store }) => {
  const appStore = store;
  try {
    const districts = await appStore.services.districtService.getAllDistricts();
    return { success: true, data: districts };
  } catch (error4) {
    console.error("Failed to fetch districts:", error4);
    throw error4;
  }
}).post("/", async ({ body, store }) => {
  const appStore = store;
  try {
    const district = {
      id: crypto.randomUUID(),
      name: body.name,
      type: body.type,
      population: body.population,
      density: 0,
      economicActivity: 0,
      boundaries: [
        [0, 0],
        [0, 1],
        [1, 1],
        [1, 0]
      ],
      area: 0,
      currentEvents: [],
      transportHubs: [],
      residentAgents: [],
      visitorAgents: [],
      amenities: {
        schools: 0,
        hospitals: 0,
        parks: 0,
        shops: 0
      },
      metrics: {
        education: 0.8,
        healthcare: 0.7,
        environment: 0.6,
        safety: 0.8,
        cleanliness: 0.7,
        noise: 0.3,
        crowding: 0.4,
        ambiance: 0.5,
        economicGrowth: 0.6,
        propertyValues: 0.7,
        businessActivity: 0.6,
        infrastructureQuality: 0.7,
        publicServiceAccess: 0.6,
        transportEfficiency: 0.7,
        culturalVibrancy: 0.8,
        communityWellbeing: 0.7,
        socialCohesion: 0.8,
        energyEfficiency: 0.7,
        greenSpaceCoverage: 0.6,
        environmentalHealth: 0.7
      },
      socialMetrics: {
        communityEngagement: 0.7,
        culturalDiversity: 0.8,
        socialCohesion: 0.75,
        publicServices: 0.7,
        index: 0.75
      },
      economicMetrics: {
        employmentRate: 0.85,
        averageIncome: 65000,
        businessActivity: 0.8,
        employment: 0.85,
        index: 0.8
      }
    };
    await appStore.services.districtService.addDistrict(district);
    return { success: true, data: district };
  } catch (error4) {
    console.error("Failed to create district:", error4);
    throw error4;
  }
}, {
  body: t.Object({
    name: t.String(),
    type: t.Union([
      t.Literal("residential"),
      t.Literal("commercial"),
      t.Literal("industrial"),
      t.Literal("mixed")
    ]),
    population: t.Number()
  })
}).get("/:id", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const district = await appStore.services.districtService.getDistrict(id);
    if (!district)
      throw new Error("District not found");
    return { success: true, data: district };
  } catch (error4) {
    console.error(`Failed to fetch district ${id}:`, error4);
    throw error4;
  }
}).post("/:id/events", async ({ params: { id }, body, store }) => {
  const appStore = store;
  try {
    const event = await appStore.services.districtService.addEventToDistrict(id, body);
    return { success: true, data: event };
  } catch (error4) {
    console.error(`Failed to add event to district ${id}:`, error4);
    throw error4;
  }
}, {
  body: t.Object({
    title: t.String(),
    description: t.String(),
    category: t.Union([
      t.Literal("urban_development"),
      t.Literal("transportation"),
      t.Literal("environmental"),
      t.Literal("infrastructure"),
      t.Literal("community"),
      t.Literal("emergency"),
      t.Literal("cultural"),
      t.Literal("health"),
      t.Literal("education"),
      t.Literal("technology")
    ]),
    severity: t.Number(),
    duration: t.Number(),
    impact: t.Object({
      environmental: t.Number(),
      social: t.Number(),
      economic: t.Number()
    }),
    requiredAgents: t.Array(t.String())
  })
}).get("/:id/analytics", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const analytics = await appStore.services.districtService.getDistrictAnalytics(id);
    return { success: true, data: analytics };
  } catch (error4) {
    console.error(`Failed to fetch analytics for district ${id}:`, error4);
    throw error4;
  }
}).post("/:id/transport-hubs", async ({ params: { id }, body, store }) => {
  const appStore = store;
  try {
    const scheduleData = {
      weekday: generateSchedule(body.schedule.startTime, body.schedule.endTime, body.schedule.frequency),
      weekend: generateSchedule(body.schedule.startTime, body.schedule.endTime, body.schedule.frequency * 1.5),
      holidays: []
    };
    const hub = await appStore.services.districtService.addTransportHub(id, {
      type: body.type,
      capacity: body.capacity,
      schedule: scheduleData
    });
    return { success: true, data: hub };
  } catch (error4) {
    console.error(`Failed to add transport hub to district ${id}:`, error4);
    throw error4;
  }
}, {
  body: t.Object({
    type: t.Union([
      t.Literal("bus"),
      t.Literal("train"),
      t.Literal("subway")
    ]),
    capacity: t.Number(),
    schedule: t.Object({
      frequency: t.Number(),
      startTime: t.String(),
      endTime: t.String()
    })
  })
}).get("/:id/conversations", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const embedding = await appStore.services.vectorStore.createEmbedding(`district ${id} conversations`);
    const conversations = await appStore.services.vectorStore.query({
      vector: embedding,
      filter: {
        type: { $eq: "district" },
        districtId: { $eq: id }
      },
      topK: 10
    });
    return { success: true, data: conversations.matches };
  } catch (error4) {
    console.error(`Failed to fetch district conversations:`, error4);
    throw error4;
  }
}).post("/:id/interactions", async ({ params: { id }, body, store }) => {
  const appStore = store;
  try {
    const { agentId1, agentId2, content } = body;
    const embedding = await appStore.services.vectorStore.createEmbedding(content);
    await appStore.services.vectorStore.upsert({
      id: `interaction-${Date.now()}`,
      values: embedding,
      metadata: {
        type: "district",
        districtId: id,
        agents: [agentId1, agentId2],
        content,
        timestamp: Date.now()
      }
    });
    return { success: true };
  } catch (error4) {
    console.error(`Failed to record interaction:`, error4);
    throw error4;
  }
}, {
  body: t.Object({
    agentId1: t.String(),
    agentId2: t.String(),
    content: t.String()
  })
}).post("/:id/memories", async ({ body, params: { id }, store }) => {
  const appStore = store;
  try {
    const memory = {
      type: body.type,
      description: body.description,
      districtId: id,
      timestamp: Date.now(),
      emotionalImpact: body.emotionalImpact,
      participants: body.participants,
      culturalSignificance: body.culturalSignificance,
      tags: body.tags,
      location: body.coordinates ? {
        coordinates: [body.coordinates[0], body.coordinates[1]],
        landmark: body.landmark
      } : undefined
    };
    await appStore.services.cityMemory.storeCollectiveMemory(memory);
    return {
      success: true,
      message: "Memory stored successfully",
      data: memory
    };
  } catch (error4) {
    console.error("Failed to store memory:", error4);
    throw error4;
  }
}, {
  body: t.Object({
    type: t.Union([
      t.Literal("environmental"),
      t.Literal("cultural"),
      t.Literal("social"),
      t.Literal("historical")
    ]),
    description: t.String(),
    emotionalImpact: t.Number(),
    participants: t.Array(t.String()),
    culturalSignificance: t.Number(),
    tags: t.Optional(t.Array(t.String())),
    coordinates: t.Optional(t.Array(t.Number())),
    landmark: t.Optional(t.String())
  })
}).get("/:id/memories", async ({ params: { id }, query, store }) => {
  const appStore = store;
  try {
    const memories = await appStore.services.cityMemory.getDistrictMemories(id, {
      type: query.type,
      fromTimestamp: query.fromTimestamp ? parseInt(query.fromTimestamp) : undefined,
      toTimestamp: query.toTimestamp ? parseInt(query.toTimestamp) : undefined,
      minSignificance: query.minSignificance ? parseFloat(query.minSignificance) : undefined,
      includedTags: query.includedTags ? query.includedTags.split(",") : undefined,
      excludedTags: query.excludedTags ? query.excludedTags.split(",") : undefined
    });
    return { success: true, data: memories };
  } catch (error4) {
    console.error(`Failed to fetch memories for district ${id}:`, error4);
    throw error4;
  }
}).onError(({ code, error: error4 }) => {
  return {
    success: false,
    error: error4.message,
    code
  };
});
function generateSchedule(startTime, endTime, frequency) {
  const schedule = [];
  let current = new Date(`1970-01-01T${startTime}`);
  const end = new Date(`1970-01-01T${endTime}`);
  while (current < end) {
    schedule.push(current.toTimeString().slice(0, 5));
    current.setMinutes(current.getMinutes() + frequency);
  }
  return schedule;
}

// src/controllers/donation.controller.ts
var DonationSchema = t.Object({
  donorId: t.String(),
  donorName: t.String(),
  departmentId: t.String(),
  districtId: t.String(),
  amount: t.Number(),
  purpose: t.String(),
  category: t.Union([
    t.Literal("general"),
    t.Literal("religious"),
    t.Literal("cultural"),
    t.Literal("educational"),
    t.Literal("infrastructure"),
    t.Literal("environmental")
  ]),
  subcategory: t.Optional(t.Object({
    religious: t.Optional(t.Object({
      religion: t.String(),
      occasion: t.Optional(t.String()),
      ritual: t.Optional(t.String()),
      community: t.String()
    })),
    cultural: t.Optional(t.Object({
      tradition: t.String(),
      festival: t.Optional(t.String()),
      artForm: t.Optional(t.String()),
      community: t.String()
    }))
  })),
  impact: t.Object({
    category: t.String(),
    description: t.String(),
    beneficiaries: t.Number(),
    culturalValue: t.Optional(t.Number()),
    communityEngagement: t.Optional(t.Number()),
    traditionPreservation: t.Optional(t.Number())
  }),
  communityParticipation: t.Optional(t.Object({
    volunteers: t.Number(),
    events: t.Array(t.String()),
    activities: t.Array(t.String())
  }))
});
var ReactionSchema = t.Object({
  reaction: t.Union([
    t.Literal("gratitude"),
    t.Literal("excitement"),
    t.Literal("inspiration")
  ])
});
var DonationChallengeSchema = t.Object({
  title: t.String(),
  description: t.String(),
  category: t.Union([
    t.Literal("general"),
    t.Literal("religious"),
    t.Literal("cultural"),
    t.Literal("educational"),
    t.Literal("infrastructure"),
    t.Literal("environmental")
  ]),
  targetAmount: t.Number(),
  startDate: t.Number(),
  endDate: t.Number(),
  rewards: t.Object({
    badge: t.String(),
    title: t.String(),
    perks: t.Array(t.String())
  }),
  milestones: t.Array(t.Object({
    amount: t.Number(),
    reward: t.String(),
    achieved: t.Boolean()
  })),
  communityGoal: t.Object({
    description: t.String(),
    progress: t.Number(),
    target: t.Number()
  })
});
var CulturalMilestoneSchema = t.Object({
  title: t.String(),
  description: t.String(),
  category: t.Union([t.Literal("religious"), t.Literal("cultural")]),
  participants: t.Array(t.String()),
  impact: t.Object({
    culturalValue: t.Number(),
    communityEngagement: t.Number(),
    traditionPreservation: t.Number()
  }),
  celebration: t.Object({
    event: t.String(),
    date: t.Number(),
    activities: t.Array(t.String()),
    specialGuests: t.Optional(t.Array(t.String()))
  })
});
var SimpleDonationSchema = t.Object({
  userId: t.String(),
  userName: t.String(),
  amount: t.Number(),
  districtId: t.String(),
  departmentId: t.String()
});
var DonationController = (donationService2) => new Elysia({ prefix: "/donations" }).post("/", async ({ body }) => {
  const donationId = await donationService2.processDonation(body);
  return { success: true, donationId };
}, {
  body: DonationSchema,
  detail: {
    tags: ["Donations"],
    summary: "Process a new donation"
  }
}).get("/activities/:donationId", async ({ params: { donationId } }) => {
  const donation = Array.from(donationService2["donations"].values()).find((d) => d.id === donationId);
  if (!donation) {
    throw new Error("Donation not found");
  }
  return donationService2.suggestCommunityActivities(donation);
}, {
  params: t.Object({
    donationId: t.String()
  }),
  detail: {
    tags: ["Donations"],
    summary: "Get suggested community activities for a donation"
  }
}).get("/events/:districtId", async ({ params: { districtId } }) => {
  return donationService2.getUpcomingCulturalEvents(districtId);
}, {
  params: t.Object({
    districtId: t.String()
  }),
  detail: {
    tags: ["Donations"],
    summary: "Get upcoming cultural and religious events in a district"
  }
}).get("/district/:districtId/category/:category", async ({ params: { districtId, category } }) => {
  const donations = await donationService2.getDonationsByDistrict(districtId);
  return donations.filter((d) => d.category === category);
}, {
  params: t.Object({
    districtId: t.String(),
    category: t.Union([
      t.Literal("religious"),
      t.Literal("cultural"),
      t.Literal("general"),
      t.Literal("educational"),
      t.Literal("infrastructure"),
      t.Literal("environmental")
    ])
  }),
  detail: {
    tags: ["Donations"],
    summary: "Get donations by category in a district"
  }
}).get("/district/:districtId/cultural-impact", async ({ params: { districtId } }) => {
  const donations = await donationService2.getDonationsByDistrict(districtId);
  const culturalDonations = donations.filter((d) => d.category === "religious" || d.category === "cultural");
  const summary = {
    totalDonations: culturalDonations.length,
    totalAmount: culturalDonations.reduce((sum, d) => sum + d.amount, 0),
    religions: new Set,
    traditions: new Set,
    festivals: new Set,
    artForms: new Set,
    upcomingEvents: await donationService2.getUpcomingCulturalEvents(districtId),
    communityEngagement: {
      totalVolunteers: 0,
      activeEvents: new Set,
      popularActivities: new Set
    }
  };
  culturalDonations.forEach((d) => {
    if (d.subcategory?.religious) {
      summary.religions.add(d.subcategory.religious.religion);
      if (d.subcategory.religious.occasion)
        summary.festivals.add(d.subcategory.religious.occasion);
    }
    if (d.subcategory?.cultural) {
      summary.traditions.add(d.subcategory.cultural.tradition);
      if (d.subcategory.cultural.festival)
        summary.festivals.add(d.subcategory.cultural.festival);
      if (d.subcategory.cultural.artForm)
        summary.artForms.add(d.subcategory.cultural.artForm);
    }
    if (d.communityParticipation) {
      summary.communityEngagement.totalVolunteers += d.communityParticipation.volunteers;
      d.communityParticipation.events.forEach((e) => summary.communityEngagement.activeEvents.add(e));
      d.communityParticipation.activities.forEach((a) => summary.communityEngagement.popularActivities.add(a));
    }
  });
  return {
    ...summary,
    religions: Array.from(summary.religions),
    traditions: Array.from(summary.traditions),
    festivals: Array.from(summary.festivals),
    artForms: Array.from(summary.artForms),
    communityEngagement: {
      ...summary.communityEngagement,
      activeEvents: Array.from(summary.communityEngagement.activeEvents),
      popularActivities: Array.from(summary.communityEngagement.popularActivities)
    }
  };
}, {
  params: t.Object({
    districtId: t.String()
  }),
  detail: {
    tags: ["Donations"],
    summary: "Get cultural and religious impact summary for a district"
  }
}).get("/district/:districtId", async ({ params: { districtId } }) => {
  return donationService2.getDonationsByDistrict(districtId);
}, {
  params: t.Object({
    districtId: t.String()
  }),
  detail: {
    tags: ["Donations"],
    summary: "Get donations by district"
  }
}).get("/department/:departmentId", async ({ params: { departmentId } }) => {
  return donationService2.getDonationsByDepartment(departmentId);
}, {
  params: t.Object({
    departmentId: t.String()
  }),
  detail: {
    tags: ["Donations"],
    summary: "Get donations by department"
  }
}).get("/announcements/:districtId", async ({ params: { districtId } }) => {
  return donationService2.getDistrictAnnouncements(districtId);
}, {
  params: t.Object({
    districtId: t.String()
  }),
  detail: {
    tags: ["Donations"],
    summary: "Get district donation announcements"
  }
}).post("/announcements/:announcementId/react", async ({ params: { announcementId }, body }) => {
  await donationService2.addReactionToAnnouncement(announcementId, body.reaction);
  return { success: true };
}, {
  params: t.Object({
    announcementId: t.String()
  }),
  body: ReactionSchema,
  detail: {
    tags: ["Donations"],
    summary: "Add reaction to donation announcement"
  }
}).get("/:donationId/impact", async ({ params: { donationId } }) => {
  const impact = await donationService2.getDonationImpact(donationId);
  if (!impact) {
    throw new Error("Impact not found for donation");
  }
  return impact;
}, {
  params: t.Object({
    donationId: t.String()
  }),
  detail: {
    tags: ["Donations"],
    summary: "Get donation impact metrics"
  }
}).post("/challenges", async ({ body }) => {
  const challengeId = await donationService2.createDonationChallenge(body);
  return { success: true, challengeId };
}, {
  body: DonationChallengeSchema,
  detail: {
    tags: ["Donations"],
    summary: "Create a new donation challenge"
  }
}).get("/challenges/active", async () => {
  return donationService2.getActiveChallenges();
}, {
  detail: {
    tags: ["Donations"],
    summary: "Get all active donation challenges"
  }
}).get("/challenges/:challengeId/progress", async ({ params: { challengeId } }) => {
  return donationService2.getDonationChallengeProgress(challengeId);
}, {
  params: t.Object({
    challengeId: t.String()
  }),
  detail: {
    tags: ["Donations"],
    summary: "Get detailed progress of a donation challenge"
  }
}).post("/challenges/:challengeId/participate", async ({ params: { challengeId }, body }) => {
  await donationService2.participateInChallenge(body.donationId, challengeId);
  return { success: true };
}, {
  params: t.Object({
    challengeId: t.String()
  }),
  body: t.Object({
    donationId: t.String()
  }),
  detail: {
    tags: ["Donations"],
    summary: "Participate in a donation challenge"
  }
}).post("/milestones", async ({ body }) => {
  const milestoneId = await donationService2.createCulturalMilestone(body);
  return { success: true, milestoneId };
}, {
  body: CulturalMilestoneSchema,
  detail: {
    tags: ["Donations"],
    summary: "Create a new cultural milestone"
  }
}).post("/stories/:donationId", async ({ params: { donationId }, body }) => {
  await donationService2.addCommunityStory(donationId, body.story);
  return { success: true };
}, {
  params: t.Object({
    donationId: t.String()
  }),
  body: t.Object({
    story: t.String()
  }),
  detail: {
    tags: ["Donations"],
    summary: "Add a community story to a donation"
  }
}).post("/simple", async ({ body }) => {
  try {
    const donationData = {
      donorId: body.userId,
      donorName: body.userName,
      amount: body.amount,
      districtId: body.districtId,
      departmentId: body.departmentId,
      purpose: "Support city initiatives",
      category: "general",
      impact: {
        category: "general",
        description: "Supporting city development",
        beneficiaries: Math.floor(body.amount / 100)
      }
    };
    const donationId = await donationService2.processDonation(donationData);
    return {
      success: true,
      donationId,
      message: "Donation processed and announced successfully"
    };
  } catch (error4) {
    console.error("Failed to process simple donation:", error4);
    throw error4;
  }
}, {
  body: SimpleDonationSchema,
  detail: {
    tags: ["Donations"],
    summary: "Process a simple donation"
  }
});

// src/controllers/district-metrics.controller.ts
var DistrictMetricsController = new Elysia({
  prefix: "/districts/:id"
}).get("/weather/current", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      temperature: metrics?.weather?.temperature || 22,
      feelsLike: metrics?.weather?.feelsLike || 23,
      humidity: metrics?.weather?.humidity || 65,
      precipitation: metrics?.weather?.precipitation || 0,
      windSpeed: metrics?.weather?.windSpeed || 12,
      windDirection: metrics?.weather?.windDirection || "NE",
      airQuality: metrics?.environmental?.airQuality || 85
    };
  } catch (error4) {
    console.error("Error fetching weather metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch weather metrics" }), { status: 500 });
  }
}).get("/emergency", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      level: metrics?.emergency?.level || "normal",
      activeIncidents: metrics?.emergency?.activeIncidents || 2,
      responseTeamsAvailable: metrics?.emergency?.responseTeamsAvailable || 8
    };
  } catch (error4) {
    console.error("Error fetching emergency metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch emergency metrics" }), { status: 500 });
  }
}).get("/vitals", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      populationCount: metrics?.vitals?.populationCount || 15234,
      activeEntities: metrics?.vitals?.activeEntities || 12453,
      visitorCount: metrics?.vitals?.visitorCount || 892,
      peakHoursStatus: metrics?.vitals?.peakHoursStatus || "Optimal"
    };
  } catch (error4) {
    console.error("Error fetching vitals metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch vitals metrics" }), { status: 500 });
  }
}).get("/metrics/environmental", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      airQuality: metrics?.environmental?.airQuality || 92,
      noiseLevel: metrics?.environmental?.noiseLevel || 45,
      crowdingLevel: metrics?.environmental?.crowdingLevel || 68,
      greenSpaceUsage: metrics?.environmental?.greenSpaceUsage || 78
    };
  } catch (error4) {
    console.error("Error fetching environmental metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch environmental metrics" }), { status: 500 });
  }
}).get("/activity", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      activeEvents: metrics?.community?.activeEvents || 12,
      ongoingMeetings: metrics?.community?.ongoingMeetings || 5,
      collaborationSessions: metrics?.community?.collaborationSessions || 8,
      chatActivity: metrics?.community?.chatActivity || "High"
    };
  } catch (error4) {
    console.error("Error fetching activity metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch activity metrics" }), { status: 500 });
  }
}).get("/metrics/safety", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      overallScore: metrics?.safety?.overallScore || 95,
      recentIncidents: metrics?.safety?.recentIncidents || 3,
      responseTime: metrics?.safety?.responseTime || "2.5 min",
      serviceAvailability: metrics?.safety?.serviceAvailability || 98
    };
  } catch (error4) {
    console.error("Error fetching safety metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch safety metrics" }), { status: 500 });
  }
}).get("/resources", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      energyConsumption: metrics?.resources?.energyConsumption || 72,
      waterUsage: metrics?.resources?.waterUsage || 65,
      wasteManagement: metrics?.resources?.wasteManagement || 88,
      efficiency: metrics?.resources?.efficiency || 91
    };
  } catch (error4) {
    console.error("Error fetching resource metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch resource metrics" }), { status: 500 });
  }
}).get("/transport", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      trafficDensity: metrics?.transport?.trafficDensity || 45,
      publicTransportLoad: metrics?.transport?.publicTransportLoad || 68,
      parkingAvailable: metrics?.transport?.parkingAvailable || 342,
      avgTransitTime: metrics?.transport?.avgTransitTime || 15
    };
  } catch (error4) {
    console.error("Error fetching transport metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch transport metrics" }), { status: 500 });
  }
}).get("/metrics/economic", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      businessActivity: metrics?.economic?.businessActivity || 82,
      growthRate: metrics?.economic?.growthRate || 4.2,
      activeTransactions: metrics?.economic?.activeTransactions || 1243,
      marketSentiment: metrics?.economic?.marketSentiment || "Positive"
    };
  } catch (error4) {
    console.error("Error fetching economic metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch economic metrics" }), { status: 500 });
  }
}).get("/metrics/cultural", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      eventAttendance: metrics?.cultural?.eventAttendance || 89,
      culturalSiteVisits: metrics?.cultural?.culturalSiteVisits || 1205,
      communityEngagement: metrics?.cultural?.communityEngagement || 86,
      socialCohesion: metrics?.cultural?.socialCohesion || 92
    };
  } catch (error4) {
    console.error("Error fetching cultural metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch cultural metrics" }), { status: 500 });
  }
}).get("/infrastructure", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      maintenanceRequests: metrics?.infrastructure?.maintenanceRequests || 23,
      serviceUptime: metrics?.infrastructure?.serviceUptime || 99.9,
      healthScore: metrics?.infrastructure?.healthScore || 94,
      developmentProgress: metrics?.infrastructure?.developmentProgress || 78
    };
  } catch (error4) {
    console.error("Error fetching infrastructure metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch infrastructure metrics" }), { status: 500 });
  }
}).get("/budget", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      currentStatus: metrics?.budget?.currentStatus || 8500000,
      monthlySpending: metrics?.budget?.monthlySpending || 750000,
      efficiency: metrics?.budget?.efficiency || 92,
      allocation: metrics?.budget?.allocation || {
        infrastructure: 35,
        services: 25,
        development: 20,
        emergency: 20
      }
    };
  } catch (error4) {
    console.error("Error fetching budget metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch budget metrics" }), { status: 500 });
  }
}).get("/departments", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      responseTimes: metrics?.departments?.responseTimes || 95,
      serviceQuality: metrics?.departments?.serviceQuality || 89,
      resourceUtilization: metrics?.departments?.resourceUtilization || 86,
      efficiency: metrics?.departments?.efficiency || 91
    };
  } catch (error4) {
    console.error("Error fetching department metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch department metrics" }), { status: 500 });
  }
}).get("/donations", async ({ params: { id }, store }) => {
  const appStore = store;
  try {
    const metrics = await appStore.services.metricsService.getCurrentMetrics(id);
    return {
      activeCampaigns: metrics?.donations?.activeCampaigns || 5,
      totalDonations: metrics?.donations?.totalDonations || 2500000,
      goalProgress: metrics?.donations?.goalProgress || 75,
      impactScore: metrics?.donations?.impactScore || 89
    };
  } catch (error4) {
    console.error("Error fetching donation metrics:", error4);
    return new Response(JSON.stringify({ error: "Failed to fetch donation metrics" }), { status: 500 });
  }
}).ws("/live", {
  body: t.Object({
    type: t.String(),
    data: t.Optional(t.Any())
  }),
  open(ws) {
    const store = this.store;
    const districtId = ws.data.params.id;
    store.services.districtWebSocket.handleConnection(ws, districtId);
  }
});

// src/index.ts
var store = createStore();
async function initializeAISystem() {
  try {
    const allAgents = [...allCityAgents.map((agent) => agent.id)];
    const residentAgentIds = residentAgents.map((a) => a.id).join(",");
    const cityAgentIds = cityManagementAgents.map((a) => a.id).join(",");
    const result = await store.services.aiIntegration.initializeSystem({
      agents: allAgents,
      protocol: {
        name: "city-management",
        version: "1.0.0",
        rules: [
          "The city is a living organism that evolves and adapts to the needs of its residents.",
          "The city is a collaborative entity that works together to achieve its goals.",
          "The city is a sustainable entity that works together to achieve its goals.",
          "The city is a resilient entity that works together to achieve its goals."
        ]
      },
      initialState: {
        resident_agents: residentAgentIds,
        city_agents: cityAgentIds,
        agent_count: allAgents.length,
        initialized: true,
        agent_types: allAgents.map((id) => {
          if (residentAgents.map((a) => a.id).includes(id))
            return `${id}:resident`;
          if (cityManagementAgents.map((a) => a.id).includes(id))
            return `${id}:management`;
          return `${id}:unknown`;
        })
      }
    });
    console.log("\uD83E\uDD16 AI System initialized with", allAgents.length, "agents");
    return result;
  } catch (error4) {
    console.error("Failed to initialize AI system:", error4);
    throw error4;
  }
}
var app = new Elysia().use(swagger({
  documentation: {
    info: {
      title: "AI City API",
      version: "1.0.0"
    },
    security: [
      {
        bearerAuth: []
      }
    ],
    components: {
      securitySchemes: {
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          bearerFormat: "JWT"
        }
      }
    }
  }
})).use(jwt({
  name: "jwt",
  secret: "wpEUqPAcrmc5uET3n/qr9V4ouPjHTzyAHWXIby4IUBo="
})).use(cors()).onError(({ code, error: error4 }) => {
  console.error(`Error ${code}:`, error4);
  return {
    success: false,
    error: error4.message,
    code: typeof code === "string" ? 500 : code
  };
}).derive(({ jwt: jwt2 }) => {
  return {
    jwt: jwt2,
    store
  };
});
var apiGroup = app.group("/api", (app2) => {
  return app2.use(CityRhythmController({ store })).use(CityCoordinatorController({ store })).use(DonationController(store.services.donationService)).use(DistrictMetricsController).use(DepartmentController).use(DistrictController).use(AIController).use((app3) => new AdaptiveLearningController(store).setup(app3)).use((app3) => new AIIntegrationController(store.services.aiIntegration).setup(app3)).group("ai", (app3) => {
    return app3.post("/initialize", async ({ body, jwt: jwt2 }) => {
      const result = await store.services.aiIntegration.initializeSystem(body);
      const accessToken = await jwt2.sign({
        systemId: result.systemId,
        timestamp: Date.now()
      });
      return {
        success: true,
        data: {
          ...result,
          accessToken
        }
      };
    }, {
      body: t.Object({
        agents: t.Array(t.String()),
        protocol: t.String(),
        initialState: t.Optional(t.Record(t.String(), t.Any()))
      })
    }).post("/decision", async ({ body }) => {
      await store.services.aiIntegration.recordDecision(body.agentId, body.decision, body.context);
      return { success: true, data: null };
    }, {
      beforeHandle: [
        verifyAuth,
        () => {
          if (!store.services.aiIntegration.isInitialized()) {
            throw new Error("System not initialized");
          }
        }
      ],
      body: t.Object({
        agentId: t.String(),
        decision: t.String(),
        context: t.Record(t.String(), t.Any())
      })
    }).post("/pattern", async ({ body }) => {
      await store.services.aiIntegration.storePattern(body.pattern, body.context, body.confidence);
      return { success: true, data: null };
    }, {
      beforeHandle: [
        verifyAuth,
        () => {
          if (!store.services.aiIntegration.isInitialized()) {
            throw new Error("System not initialized");
          }
        }
      ],
      body: t.Object({
        pattern: t.String(),
        context: t.Record(t.String(), t.Any()),
        confidence: t.Number()
      })
    }).get("/similar-decisions", async ({ query }) => {
      const decisions = await store.services.aiIntegration.findSimilarDecisions(query.content, query.limit ? parseInt(query.limit) : undefined);
      return { success: true, data: decisions };
    }, {
      beforeHandle: [
        verifyAuth,
        () => {
          if (!store.services.aiIntegration.isInitialized()) {
            throw new Error("System not initialized");
          }
        }
      ],
      query: t.Object({
        content: t.String(),
        limit: t.Optional(t.String())
      })
    }).get("/similar-patterns", async ({ query }) => {
      const patterns3 = await store.services.aiIntegration.findSimilarPatterns(query.content, query.limit ? parseInt(query.limit) : undefined);
      return { success: true, data: patterns3 };
    }, {
      beforeHandle: [
        verifyAuth,
        () => {
          if (!store.services.aiIntegration.isInitialized()) {
            throw new Error("System not initialized");
          }
        }
      ],
      query: t.Object({
        content: t.String(),
        limit: t.Optional(t.String())
      })
    }).get("/status", async () => {
      const status = store.services.aiIntegration.getSystemStatus();
      return { success: true, data: status };
    }, {
      beforeHandle: [
        verifyAuth,
        () => {
          if (!store.services.aiIntegration.isInitialized()) {
            throw new Error("System not initialized");
          }
        }
      ]
    });
  });
});
app.use(apiGroup);
initializeAISystem().then(() => {
  app.listen("3000");
  console.log(`\uD83E\uDD8A AI City server is running at ${app.server?.hostname}:${app.server?.port}`);
}).catch((error4) => {
  console.error("Failed to start server:", error4);
  process.exit(1);
});
